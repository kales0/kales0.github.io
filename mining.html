<!DOCTYPE html>
<!--
==========================================================================
RULES FOR AI ASSISTANT â€” READ BEFORE MAKING ANY CHANGES
==========================================================================

RULE MANAGEMENT:
  - Any game generation rule, coding rule, or convention outlined by the
    user must be added to this header block so it persists for future sessions
  - Always confirm with the user before adding or modifying rules in this header

VERSIONING:
  - Format: YY.M.edit (e.g. 26.2.67 = year 2026, February, edit 67)
  - Each output file increments the edit number by 1
  - Filename must match: mining_YY-M-edit.html (e.g. mining_26-2-67.html)
  - Internal GAME_VERSION constant must match the filename
  - New month resets edit to 1 (e.g. 26.2.99 â†’ 26.3.1)

STATIC DATA â€” DO NOT REGENERATE:
  - All biome configs (e.g. for rock biome, rock_1 through rock_8) contain
    hand-tuned static data for terrain (hills) and items (trees, rocks, sticks, minables)
  - New configs are generated using the generationRules when requested by the user

BIOME GENERATION RULES:
  - Rock biome: rocky terrain with scattered trees, rocks, and minable
    material clusters (currently crystal). Hills are taller at the back, shorter at the front.
    See generationRules object and ROCK BIOME HILL GENERATION RULES
    comment block within BIOMES.rock for specific ranges and values.
  - Forest biome: dense fir tree clusters on a single hill. Each config has
    1 hill (rectangular or triangular) against one edge, covering full width.
    Hills use shape:'rect' (wx/wz half-widths) or shape:'tri' (corner-based).
    Trees generated via generateForestShape(), then baked to static data.
    See generationRules within BIOMES.forest for specific ranges and values.

COORDINATE SYSTEM:
  - Regions use UV [0,1] mapped to local [-S, +S] via: x = -S + u * 2 * S
  - World offset: ox = gx * REGION_SIZE, oz = gz * REGION_SIZE
  - Ground shader adds uWorldOffset to local vertex positions
  - Trees/rocks/minables store world-space positions (already include ox/oz)
  - Hills blend across region boundaries via getBlendedHeight() (all biomes)

EDGE BLENDING:
  - EDGE_OVERLAP (0.15) extends ground mesh beyond UV [0,1]
  - edgeMask() in fragment shader uses discard for blocky noise blend

SHADER PRECISION:
  - Fragment shaders using hash/noise functions MUST use precision highp float
  - mediump (16-bit on some Android GPUs) breaks hash function precision,
    producing incorrect noise values and visual artifacts

AI ASSISTANT BEHAVIOR:
  - Never guess or assume about the current state of the code. Always read
    the relevant code before making claims about what it does or doesn't do.
    If unsure, check first, then respond. No speculating about functionality.

WORLD EDGE MARGINS:
  - The isometric camera looks from (+X, +Y, +Z) toward the origin.
  - "Top-left world edge" = the -X edge of the grid (gx === -GRID_HALF).
    These regions' LEFT side faces the world boundary in the top-left
    screen direction. Regions: (-1,-1), (-1,0), (-1,1).
  - "Top-right world edge" = the -Z edge of the grid (gz === -GRID_HALF).
    These regions' TOP side faces the world boundary in the top-right
    screen direction. Regions: (-1,-1), (0,-1), (1,-1).
  - Only these two edges (top-left and top-right) get 0 margin at the
    world boundary, because they face away from the camera and there is
    nothing beyond them to overlap with visually.
  - The bottom-left (+Z max) and bottom-right (+X max) world edges keep
    normal margin behavior (they face toward the camera).

==========================================================================
-->
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mining Game</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #08080c; overflow: hidden; display: flex; align-items: center; justify-content: center; height: 100dvh; height: 100vh; }
canvas { display: block; }
#fsBtn {
  position: fixed; top: 14px; right: 14px; z-index: 10;
  width: 38px; height: 37px; border: 1px solid #3a3a40; border-radius: 6px;
  background: linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%);
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  padding: 0; margin: 0; line-height: 0;
}
#fsBtn svg, #colBtn svg, #statsToggle svg { display: block; }
#fsBtn svg { width: 18px; height: 18px; stroke: rgba(255,255,255,0.7); fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
#colBtn {
  position: fixed; top: 14px; right: 58px; z-index: 10;
  width: 38px; height: 37px; border: 1px solid #3a3a40; border-radius: 6px;
  background: linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%);
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  padding: 0; margin: 0; line-height: 0;
}
#colBtn svg { width: 18px; height: 18px; stroke: rgba(255,255,255,0.7); fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
#fsBtn, #colBtn, #hillBtn, #statsToggle, #configDropdown, #biomeDropdown, #fpsCapBtn { outline: none; }
#colBtn.active { background: #1a1a3a; }
#hillBtn {
  position: fixed; top: 14px; right: 102px; z-index: 10;
  width: 38px; height: 37px; border: 1px solid #3a3a40; border-radius: 6px;
  background: linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%);
  cursor: pointer; display: flex; align-items: center; justify-content: center;
  padding: 0; margin: 0; line-height: 0;
}
#hillBtn svg { width: 18px; height: 18px; stroke: rgba(255,255,255,0.7); fill: none; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
#hillBtn.active { background: #1a1a3a; }
#biomeHud {
  position: fixed; top: 14px; right: 208px; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  font: 12px/1 -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
}
#biomeName {
  color: rgba(255,255,255,0.45); letter-spacing: 0.03em;
  text-transform: uppercase; font-size: 11px; font-weight: 500;
}
#biomeDropdown {
  position: relative; display: inline-block; cursor: pointer;
  background: linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%);
  border: 1px solid #3a3a40;
  border-radius: 5px; padding: 0 22px 0 8px;
  font: 11px/1 -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  color: rgba(255,255,255,0.5); transition: background 0.2s, border-color 0.2s;
  user-select: none; min-width: 56px; text-align: center;
  height: 37px; line-height: 37px;
}
#biomeOptions {
  display: none; position: absolute; top: calc(100% + 4px); left: -1px; right: -1px;
  background: rgba(20,20,30,0.95); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 5px; overflow: hidden; z-index: 100;
  backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
}
#biomeOptions.open { display: block; }
.biome-opt {
  padding: 4px 10px; color: rgba(255,255,255,0.55); font-size: 11px;
  text-align: center; transition: background 0.15s; line-height: 1;
}
.biome-opt:hover { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.8); }
.biome-opt.active { color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.35); }
#configDropdown {
  position: relative; display: inline-block; cursor: pointer;
  background: linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%);
  border: 1px solid #3a3a40;
  border-radius: 5px; padding: 0 22px 0 8px;
  font: 11px/1 -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  color: rgba(255,255,255,0.5); transition: background 0.2s, border-color 0.2s;
  user-select: none; min-width: 28px; text-align: center;
  height: 37px; line-height: 37px;
}
#configOptions {
  display: none; position: absolute; top: calc(100% + 4px); left: -1px; right: -1px;
  background: rgba(20,20,30,0.95); border: 1px solid rgba(255,255,255,0.1);
  border-radius: 5px; overflow: hidden; z-index: 100;
  backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px);
}
#configOptions.open { display: block; }
.cfg-opt {
  padding: 4px 10px; color: rgba(255,255,255,0.55); font-size: 11px;
  text-align: center; transition: background 0.15s; line-height: 1;
}
.cfg-opt:hover { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.8); }
.cfg-opt.active { color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.35); }
</style>
</head>
<body>
<div id="statsWrap" style="position:fixed;top:10px;left:10px;z-index:10;display:flex;align-items:flex-start;gap:14px;transition:transform 0.3s ease;">
  <div id="stats" style="color:rgba(255,255,255,0.5);font:11px/1.6 monospace;pointer-events:none;white-space:pre;">164 FPS | 0.0ms (0.0-2.0)
747 Draws | 16,516 Tris
Zoom 0 | 26.2.345</div>
  <button id="statsToggle" title="Hide stats" style="
    width:27px;height:37px;border:1px solid #3a3a40;border-radius:6px;
    background:linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%);
    cursor:pointer;display:flex;align-items:center;justify-content:center;
    transition:background 0.2s,border-color 0.2s;flex-shrink:0;padding:0;margin:4px 0 0 0;line-height:0;
  ">
    <svg id="statsArrow" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.7)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
  </button>
</div>
<div id="biomeHud">
  <div style="display:flex;flex-direction:column;gap:2px;">
    <div>
      <span style="color:rgba(255,255,255,0.3);font-size:11px;">Region:</span>
      <span id="regionCoords" style="color:rgba(255,255,255,0.45);font-size:11px;">0, 0</span>
    </div>
  </div>
  <div id="biomeDropdown">
    <div id="biomeSelected">Forest</div>
    <svg width="10" height="6" style="position:absolute;right:7px;top:50%;transform:translateY(-50%);pointer-events:none;" fill="none"><path d="M1 1l4 4 4-4" stroke="rgba(255,255,255,0.35)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>
    <div id="biomeOptions"><div class="biome-opt" data-biome="rock">Rock</div><div class="biome-opt active" data-biome="forest">Forest</div><div class="biome-opt" data-biome="desert">Desert</div></div>
  </div>
  <div id="configDropdown">
    <div id="configSelected">4</div>
    <svg width="10" height="6" style="position:absolute;right:7px;top:50%;transform:translateY(-50%);pointer-events:none;" fill="none"><path d="M1 1l4 4 4-4" stroke="rgba(255,255,255,0.35)" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path></svg>
    <div id="configOptions"><div class="cfg-opt" data-idx="0">1</div><div class="cfg-opt" data-idx="1">2</div><div class="cfg-opt" data-idx="2">3</div><div class="cfg-opt active" data-idx="3">4</div><div class="cfg-opt" data-idx="4">5</div><div class="cfg-opt" data-idx="5">6</div><div class="cfg-opt" data-idx="6">7</div><div class="cfg-opt" data-idx="7">8</div><div class="cfg-opt" data-idx="8">9</div></div>
  </div>
</div>
<button id="colBtn" title="Toggle colliders">
  <svg viewBox="0 0 24 24">
    <circle cx="12" cy="12" r="9"></circle>
    <line x1="12" y1="3" x2="12" y2="21"></line>
    <line x1="3" y1="12" x2="21" y2="12"></line>
  </svg>
</button>
<button id="hillBtn" title="Toggle hills">
  <svg viewBox="0 0 24 24">
    <polyline points="2 20 9 8 13 14 16 10 22 20"></polyline>
  </svg>
</button>
<button id="fpsCapBtn" title="FPS cap: off" style="
  position:fixed;top:14px;right:146px;z-index:10;
  width:38px;height:37px;border:1px solid #3a3a40;border-radius:6px;
  background:linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%);
  cursor:pointer;display:flex;align-items:center;justify-content:center;
  transition:background 0.2s,border-color 0.2s;padding:0;margin:0;
  font:11px/1 monospace;color:rgba(255,255,255,0.7);
"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.7)" stroke-width="2.5" stroke-linecap="round"><line x1="5" y1="19" x2="19" y2="5"></line></svg></button>
<button id="fsBtn" title="Toggle fullscreen">
  <svg id="fsIcon" viewBox="0 0 24 24">
    <polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline>
    <line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>
  </svg>
</button>

<canvas id="gl" width="2486" height="1326" style="width: 1906px; height: 1017px;"></canvas>
<script>
// ============================================================
// SCREEN DIRECTION REFERENCE (isometric camera at camRotY = PI/4)
//
// The camera looks from (+X, +Y, +Z) toward the origin.
// On screen, the four cardinal directions map to world coords as:
//
//   UP    (away from camera)  = equal parts -X and -Z  â†’ toward (-1, -1)
//   DOWN  (toward camera)     = equal parts +X and +Z  â†’ toward (+1, +1)
//   RIGHT (screen right)      = equal parts +X and -Z  â†’ toward (+1, -1)
//   LEFT  (screen left)       = equal parts -X and +Z  â†’ toward (-1, +1)
//
// So to move something "up" on screen, decrease both X and Z equally.
// To move something "right" on screen, increase X and decrease Z equally.
// ============================================================

// ============================================================
// VERSION TRACKING
// Format: YY.M.edit  (e.g. 26.2.1 = 2026, February, edit 1)
// Rule: Each edit increments the last digit. New month resets
// edit to 1 and increments month. E.g. 26.2.2 -> 26.3.1
// ============================================================
const GAME_VERSION = '26.2.345';
window._debugFlatTerrain = false;

const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl');

function resize() {
  const dpr = window.devicePixelRatio || 1;
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  gl.viewport(0, 0, canvas.width, canvas.height);
}
resize();
window.addEventListener('resize', resize);

// --- Shaders ---
const vsSource = `
  attribute vec3 aPos;
  attribute vec2 aUV;
  uniform mat4 uProj;
  uniform mat4 uView;
  uniform vec3 uWorldOffset;
  varying vec2 vUV;
  varying vec3 vWorldPos;
  void main() {
    vec3 pos = aPos + uWorldOffset;
    vUV = aUV;
    vWorldPos = pos;
    gl_Position = uProj * uView * vec4(pos, 1.0);
  }
`;

const fsSource = `
  precision highp float;
  varying vec2 vUV;
  varying vec3 vWorldPos;
  uniform vec3 uPlayerPos;
  uniform float uMineralOnly;
  uniform sampler2D uMineralMask;
  uniform sampler2D uMineralColorTex;
  uniform sampler2D uLocalTex;

  float hash(vec2 p) {
    p = fract(p * vec2(579.83, 264.37));
    p += dot(p, p + 91.14);
    return fract(p.x * p.y);
  }

  float pixelNoise(vec2 uv, float scale) {
    vec2 id = floor(uv * scale);
    return hash(id);
  }

  // Edge mask: inside UV 0-1 always solid. In overlap zone (outside 0-1),
  // blocky noise determines survival. A small solid zone at the boundary
  // prevents gaps between core and overlap. Beyond that, noise fades out.
  // All four directions use the same pattern. Two-pass rendering ensures symmetry.
  float edgeMask(vec2 uv, vec3 worldPos) {
    if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) return 1.0;

    float blockScale = 1.2;
    vec2 wc = worldPos.xz * blockScale;
    float ax = 1.0;
    float az = 1.0;
    float overlap = 0.15;
    float solidZone = 0.25; // fraction of overlap that stays solid (no noise)

    if (uv.x < 0.0) {
      float t = -uv.x / overlap;
      if (t > solidZone) {
        float nt = (t - solidZone) / (1.0 - solidZone); // remap to 0-1
        ax = step(nt, pixelNoise(wc, 1.0));
      }
    } else if (uv.x > 1.0) {
      float t = (uv.x - 1.0) / overlap;
      if (t > solidZone) {
        float nt = (t - solidZone) / (1.0 - solidZone);
        ax = step(nt, pixelNoise(wc, 1.0));
      }
    }

    if (uv.y < 0.0) {
      float t = -uv.y / overlap;
      if (t > solidZone) {
        float nt = (t - solidZone) / (1.0 - solidZone);
        az = step(nt, pixelNoise(wc + 33.3, 1.0));
      }
    } else if (uv.y > 1.0) {
      float t = (uv.y - 1.0) / overlap;
      if (t > solidZone) {
        float nt = (t - solidZone) / (1.0 - solidZone);
        az = step(nt, pixelNoise(wc + 33.3, 1.0));
      }
    }

    return ax * az;
  }

  void main() {
    vec2 uv = vUV;

    if (uMineralOnly > 0.5) {
      float mask = texture2D(uMineralMask, vUV).r;
      if (mask < 0.004) discard;
      vec2 mineralUV = vWorldPos.xz / 30.0;
      vec4 mineralCol = texture2D(uMineralColorTex, mineralUV);
      vec3 color = mineralCol.rgb;
      float emissive = mineralCol.a * 0.25;
      float dx = vWorldPos.x - uPlayerPos.x;
      float dz = vWorldPos.z - uPlayerPos.z;
      float dist = sqrt(dx * dx + dz * dz);
      float shadow = smoothstep(3.0, 12.0, dist);
      vec3 shadowed = color * mix(1.0, 0.55, shadow);
      float worldHalf = 15.0;
      float fadeStart = 3.0;
      float edgeDist = min(min(worldHalf - vWorldPos.x, worldHalf + vWorldPos.x),
                           min(worldHalf - vWorldPos.z, worldHalf + vWorldPos.z));
      float worldEdgeShadow = smoothstep(0.0, fadeStart, edgeDist);
      shadowed *= mix(0.625, 1.0, worldEdgeShadow);
      color = shadowed + color * emissive;
      gl_FragColor = vec4(color, 1.0);
      return;
    }

    // Discard overlap pixels that don't survive the blocky noise mask
    float mask = edgeMask(uv, vWorldPos);
    if (mask < 0.5) discard;

    vec3 color = texture2D(uLocalTex, uv).rgb;

    // Region shadow
    float dx = vWorldPos.x - uPlayerPos.x;
    float dz = vWorldPos.z - uPlayerPos.z;
    float dist = sqrt(dx * dx + dz * dz);
    float shadow = smoothstep(3.0, 12.0, dist);
    color *= mix(1.0, 0.55, shadow);

    // Darken at world edges
    float worldHalf = 15.0;
    float fadeStart = 3.0;
    float edgeDist = min(min(worldHalf - vWorldPos.x, worldHalf + vWorldPos.x),
                         min(worldHalf - vWorldPos.z, worldHalf + vWorldPos.z));
    float worldEdgeShadow = smoothstep(0.0, fadeStart, edgeDist);
    color *= mix(0.625, 1.0, worldEdgeShadow);

    gl_FragColor = vec4(color, 1.0);
  }
`;

function createShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    gl.deleteShader(s);
    return null;
  }
  return s;
}

const vs = createShader(gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
const prog = gl.createProgram();
gl.attachShader(prog, vs);
gl.attachShader(prog, fs);
gl.linkProgram(prog);
gl.useProgram(prog);

const aPos = gl.getAttribLocation(prog, 'aPos');
const aUV = gl.getAttribLocation(prog, 'aUV');
const uProj = gl.getUniformLocation(prog, 'uProj');
const uView = gl.getUniformLocation(prog, 'uView');
const uWorldOffset = gl.getUniformLocation(prog, 'uWorldOffset');
const uPlayerPos = gl.getUniformLocation(prog, 'uPlayerPos');
const uMineralOnly = gl.getUniformLocation(prog, 'uMineralOnly');
const uMineralMask = gl.getUniformLocation(prog, 'uMineralMask');
const uMineralColorTex = gl.getUniformLocation(prog, 'uMineralColorTex');
const uLocalTex = gl.getUniformLocation(prog, 'uLocalTex');

// --- GPU-baked ground textures (512x512) ---
const GROUND_TEX_RES = 512;
let rockGroundTex = null;
let grassGroundTex = null;
let desertGroundTex = null;
const groundBakeVS = `
attribute vec2 aP;
varying vec2 vUV;
void main() { vUV = aP * 0.5 + 0.5; gl_Position = vec4(aP, 0.0, 1.0); }`;
const groundBakeFS = `
precision highp float;
varying vec2 vUV;
uniform float uMode;
float hash(vec2 p) { p = fract(p * vec2(123.34, 456.21)); p += dot(p, p + 45.32); return fract(p.x * p.y); }
float pixelNoise(vec2 uv, float scale) { return hash(floor(uv * scale)); }
float rockTexture(vec2 uv) {
  float n = 0.0;
  n += pixelNoise(uv, 8.0) * 0.4; n += pixelNoise(uv + 7.7, 16.0) * 0.25;
  n += pixelNoise(uv + 3.3, 32.0) * 0.2; n += pixelNoise(uv + 11.1, 64.0) * 0.15;
  return n;
}
vec3 rockGround(vec2 uv) {
  float rock = floor(rockTexture(uv) * 6.0) / 6.0;
  vec3 color = mix(vec3(0.22,0.20,0.19), vec3(0.30,0.27,0.24), rock);
  float hl = pixelNoise(uv + 5.5, 24.0); hl = step(0.82, hl);
  color = mix(color, vec3(0.38,0.34,0.30), hl * 0.5);
  float fleck = pixelNoise(uv + 99.9, 48.0);
  if (fleck > 0.93) { float ft = pixelNoise(uv + 44.4, 48.0);
    if (ft > 0.6) color = mix(color, vec3(0.45,0.38,0.25), 0.4);
    else if (ft > 0.3) color = mix(color, vec3(0.30,0.32,0.38), 0.4);
    else color = mix(color, vec3(0.35,0.25,0.30), 0.3);
  }
  // Scattered small dark squares
  float dk = pixelNoise(uv + 66.6, 40.0);
  color *= mix(1.0, 0.92, step(0.955, dk));
  return color;
}
vec3 grassGround(vec2 uv) {
  float n = pixelNoise(uv, 10.0)*0.5 + pixelNoise(uv+3.14, 18.0)*0.3 + pixelNoise(uv+7.77, 32.0)*0.2;
  n = floor(n * 5.0) / 5.0;
  vec3 color = mix(vec3(0.18,0.28,0.10), vec3(0.26,0.38,0.14), n);
  float hl = floor(pixelNoise(uv+22.2, 14.0)*4.0)/4.0;
  color = mix(color, vec3(0.34,0.44,0.18), step(0.7,hl)*0.5);
  color = mix(color, vec3(0.38,0.34,0.16), step(0.72, pixelNoise(uv+55.5,6.0))*0.6);
  float dm = step(0.78, pixelNoise(uv+88.8,8.0)) * step(0.4, pixelNoise(uv+33.3,20.0));
  color = mix(color, vec3(0.30,0.22,0.12), dm*0.7);
  color *= mix(1.0, 0.82, step(0.88, pixelNoise(uv+11.11,40.0)));
  return color;
}
vec3 desertGround(vec2 uv) {
  float n = pixelNoise(uv, 8.0)*0.4 + pixelNoise(uv+2.71, 16.0)*0.3 + pixelNoise(uv+5.55, 32.0)*0.2 + pixelNoise(uv+9.99, 64.0)*0.1;
  n = floor(n * 6.0) / 6.0;
  vec3 color = mix(vec3(0.62,0.50,0.32), vec3(0.72,0.60,0.40), n);
  float ripple = pixelNoise(vec2(uv.x*0.5, uv.y), 12.0);
  color = mix(color, vec3(0.68,0.56,0.36), step(0.72, ripple)*0.3);
  float peb = pixelNoise(uv + 77.7, 48.0);
  if (peb > 0.92) {
    float pt = pixelNoise(uv + 33.3, 48.0);
    if (pt > 0.5) color = mix(color, vec3(0.42,0.34,0.22), 0.5);
    else color = mix(color, vec3(0.50,0.42,0.30), 0.4);
  }
  float crack = pixelNoise(uv + 44.4, 6.0);
  if (crack > 0.8) {
    color = mix(color, vec3(0.52,0.40,0.26), 0.4);
    float edge = pixelNoise(uv + 22.2, 24.0);
    color = mix(color, vec3(0.38,0.30,0.20), step(0.7, edge)*0.3);
  }
  float sun = pixelNoise(uv + 88.8, 10.0);
  color = mix(color, vec3(0.78,0.68,0.50), step(0.85, sun)*0.35);
  color *= mix(1.0, 0.90, step(0.92, pixelNoise(uv+11.1, 40.0)));
  return color;
}
void main() {
  vec3 c;
  if (uMode < 0.5) c = rockGround(vUV);
  else if (uMode < 1.5) c = grassGround(vUV);
  else c = desertGround(vUV);
  gl_FragColor = vec4(c, 1.0);
}`;
(function() {
  const pVP = gl.getParameter(gl.VIEWPORT), pProg = gl.getParameter(gl.CURRENT_PROGRAM);
  const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, groundBakeVS); gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, groundBakeFS); gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error('Ground bake FS:', gl.getShaderInfoLog(fs));
  const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
  const qb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, qb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const a = gl.getAttribLocation(p, 'aP'), m = gl.getUniformLocation(p, 'uMode');
  const fb = gl.createFramebuffer();
  function bake(mode) {
    const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, GROUND_TEX_RES, GROUND_TEX_RES, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
    gl.viewport(0, 0, GROUND_TEX_RES, GROUND_TEX_RES); gl.useProgram(p);
    gl.enableVertexAttribArray(a); gl.bindBuffer(gl.ARRAY_BUFFER, qb);
    gl.vertexAttribPointer(a, 2, gl.FLOAT, false, 0, 0);
    gl.uniform1f(m, mode); gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return tex;
  }
  rockGroundTex = bake(0.0);
  grassGroundTex = bake(1.0);
  desertGroundTex = bake(2.0);
  gl.deleteShader(vs); gl.deleteShader(fs); gl.deleteProgram(p);
  gl.deleteBuffer(qb); gl.deleteFramebuffer(fb);
  gl.viewport(pVP[0], pVP[1], pVP[2], pVP[3]); gl.useProgram(pProg);
})();

// --- GPU-baked mineral color texture (512x512, world-space) ---
// Bakes mineralGround() color + uniform desaturation once at startup.
// Per-region masks are baked separately on CPU.
const MINERAL_TEX_RES = 512;
let mineralColorTex = null;
const mineralBakeVS = `
attribute vec2 aP;
varying vec2 vUV;
void main() { vUV = aP * 0.5 + 0.5; gl_Position = vec4(aP, 0.0, 1.0); }`;
const mineralBakeFS = `
precision highp float;
varying vec2 vUV;
float hash(vec2 p) { p = fract(p * vec2(123.34, 456.21)); p += dot(p, p + 45.32); return fract(p.x * p.y); }
float pixelNoise(vec2 uv, float scale) { return hash(floor(uv * scale)); }
void main() {
  vec2 worldXZ = vUV * 30.0;
  vec2 wc = worldXZ * 0.42;
  float base = pixelNoise(wc, 10.0);
  float mid = pixelNoise(wc + 5.5, 17.0);
  float n = base * 0.6 + mid * 0.4;
  n = floor(n * 5.0) / 5.0;
  vec3 color = mix(vec3(0.13,0.18,0.34), vec3(0.16,0.24,0.42), n);
  float hl = pixelNoise(wc + 17.7, 12.0);
  color = mix(color, vec3(0.13,0.21,0.44), step(0.72, hl) * 0.25);
  float fleck = pixelNoise(wc + 44.4, 18.0);
  float fleckMask = step(0.85, fleck);
  color = mix(color, vec3(0.14,0.23,0.48), fleckMask * 0.3);
  // Uniform desaturation + darken to match old combined bake
  float gr = color.r*0.3 + color.g*0.3 + color.b*0.4;
  color = mix(color, vec3(gr), 0.3);
  color *= 0.85;
  float emissive = 0.05 + fleckMask * 0.08;
  gl_FragColor = vec4(color, emissive * 4.0);
}`;
(function() {
  const pVP = gl.getParameter(gl.VIEWPORT), pProg = gl.getParameter(gl.CURRENT_PROGRAM);
  const vs = gl.createShader(gl.VERTEX_SHADER); gl.shaderSource(vs, mineralBakeVS); gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER); gl.shaderSource(fs, mineralBakeFS); gl.compileShader(fs);
  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error('Mineral bake FS:', gl.getShaderInfoLog(fs));
  const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
  const qb = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, qb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,1,1]), gl.STATIC_DRAW);
  const a = gl.getAttribLocation(p, 'aP');
  const fb = gl.createFramebuffer();
  mineralColorTex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, mineralColorTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, MINERAL_TEX_RES, MINERAL_TEX_RES, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, mineralColorTex, 0);
  gl.viewport(0, 0, MINERAL_TEX_RES, MINERAL_TEX_RES); gl.useProgram(p);
  gl.enableVertexAttribArray(a); gl.bindBuffer(gl.ARRAY_BUFFER, qb);
  gl.vertexAttribPointer(a, 2, gl.FLOAT, false, 0, 0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteShader(vs); gl.deleteShader(fs); gl.deleteProgram(p);
  gl.deleteBuffer(qb); gl.deleteFramebuffer(fb);
  gl.viewport(pVP[0], pVP[1], pVP[2], pVP[3]); gl.useProgram(pProg);
})();
// ============================================================
// Simplex 2D noise (seeded) for procedural terrain generation
// ============================================================
const SimplexNoise = (() => {
  const F2 = 0.5 * (Math.sqrt(3) - 1);
  const G2 = (3 - Math.sqrt(3)) / 6;
  const grad2 = [[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];

  function create(seed) {
    // Build permutation table from seed
    const perm = new Uint8Array(512);
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    // Fisher-Yates shuffle with seeded PRNG
    let s = seed | 0;
    function rng() { s = (s * 1664525 + 1013904223) & 0xFFFFFFFF; return (s >>> 0) / 4294967296; }
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(rng() * (i + 1));
      const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
    }
    for (let i = 0; i < 512; i++) perm[i] = p[i & 255];

    return function noise2D(x, y) {
      const s = (x + y) * F2;
      const i = Math.floor(x + s), j = Math.floor(y + s);
      const t = (i + j) * G2;
      const x0 = x - (i - t), y0 = y - (j - t);
      const i1 = x0 > y0 ? 1 : 0, j1 = x0 > y0 ? 0 : 1;
      const x1 = x0 - i1 + G2, y1 = y0 - j1 + G2;
      const x2 = x0 - 1 + 2 * G2, y2 = y0 - 1 + 2 * G2;
      const ii = i & 255, jj = j & 255;
      const gi0 = perm[ii + perm[jj]] & 7;
      const gi1 = perm[ii + i1 + perm[jj + j1]] & 7;
      const gi2 = perm[ii + 1 + perm[jj + 1]] & 7;
      let n0 = 0, n1 = 0, n2 = 0;
      let t0 = 0.5 - x0 * x0 - y0 * y0;
      if (t0 > 0) { t0 *= t0; n0 = t0 * t0 * (grad2[gi0][0] * x0 + grad2[gi0][1] * y0); }
      let t1 = 0.5 - x1 * x1 - y1 * y1;
      if (t1 > 0) { t1 *= t1; n1 = t1 * t1 * (grad2[gi1][0] * x1 + grad2[gi1][1] * y1); }
      let t2 = 0.5 - x2 * x2 - y2 * y2;
      if (t2 > 0) { t2 *= t2; n2 = t2 * t2 * (grad2[gi2][0] * x2 + grad2[gi2][1] * y2); }
      return 70 * (n0 + n1 + n2); // range approx -1 to 1
    };
  }
  return { create };
})();

// ============================================================
// Forest shape generator
// Uses simplex noise to create organic forest patches.
// Returns an array of {x, z} in [0,1] normalized coordinates.
//
// Parameters:
//   seed       - integer seed for deterministic generation
//   frequency  - noise scale (lower = larger patches, e.g. 2-5)
//   threshold  - noise cutoff for tree placement (e.g. 0.1 = dense, 0.3 = sparse patches)
//   density    - candidate grid resolution (higher = more potential trees, e.g. 30-60)
//   octaves    - fractal layers for shape complexity (1-3)
//   lacunarity - frequency multiplier per octave (default 2.0)
//   persistence- amplitude multiplier per octave (default 0.5)
//   margin     - border margin to avoid edge trees (default 0.03)
//   jitter     - random offset from grid points (0-1, default 0.8)
// ============================================================
// ============================================================
// Forest Hill Generator
// Generates exactly 1 hill per forest config: rectangular or triangular,
// pushed against 1 of the 4 edges, covering the full width of that edge.
//
// opts:
//   seed  - random seed (determines edge, shape, and dimensions)
//
// Returns array with exactly 1 hill object:
//   Rectangular: { shape:'rect', x, z, wx, wz, height }
//     - Center (x,z) on the chosen edge (e.g. x=0.5, z=0.0 for back)
//     - Edge-parallel half-width: 0.55-0.65 (covers full edge)
//     - Depth half-width: 0.35-0.50
//     - Height: 0.15-0.30
//   Triangular: { shape:'tri', x, z, wx, wz, dirX, dirZ, height }
//     - Corner at a region corner (e.g. 0,0 or 1,1)
//     - Extents from corner: 0.70-0.90
//     - dirX, dirZ: +1 or -1 (direction triangle extends)
//     - Height: 0.18-0.30
// ============================================================
function generateForestHill(opts) {
  const { seed = 42 } = opts || {};
  let s = (seed * 6271 + 3) | 0;
  function rng() { s = (s * 1664525 + 1013904223) & 0xFFFFFFFF; return (s >>> 0) / 4294967296; }

  // Pick edge: 0=back(z=0), 1=front(z=1), 2=left(x=0), 3=right(x=1)
  const edge = Math.floor(rng() * 4);
  // Pick shape: ~60% rectangular, ~40% triangular
  const isTriangle = rng() < 0.4;

  if (isTriangle) {
    // Triangle at the corner of the chosen edge
    const wx = 0.70 + rng() * 0.20;  // 0.70-0.90
    const wz = 0.70 + rng() * 0.20;
    const height = 0.35 + rng() * 0.15; // 0.35-0.50
    // Corner position and direction based on edge + random corner choice
    const corners = [
      { x: 0.0, z: 0.0, dirX: 1, dirZ: 1 },   // back-left
      { x: 1.0, z: 0.0, dirX: -1, dirZ: 1 },   // back-right
      { x: 0.0, z: 1.0, dirX: 1, dirZ: -1 },   // front-left
      { x: 1.0, z: 1.0, dirX: -1, dirZ: -1 },   // front-right
    ];
    // Pick a corner on the chosen edge
    const edgeCorners = [
      [0, 1], // back: back-left, back-right
      [2, 3], // front: front-left, front-right
      [0, 2], // left: back-left, front-left
      [1, 3], // right: back-right, front-right
    ];
    const ci = edgeCorners[edge][rng() < 0.5 ? 0 : 1];
    const c = corners[ci];
    return [{ shape: 'tri', x: c.x, z: c.z, wx, wz, dirX: c.dirX, dirZ: c.dirZ, height }];
  } else {
    // Rectangle against the chosen edge
    const height = 0.35 + rng() * 0.15; // 0.35-0.50
    if (edge === 0 || edge === 1) {
      // Back or front edge: wide in X, shallow in Z
      const wx = 0.55 + rng() * 0.10; // 0.55-0.65
      const wz = 0.35 + rng() * 0.15; // 0.35-0.50
      return [{ shape: 'rect', x: 0.50, z: edge === 0 ? 0.0 : 1.0, wx, wz, height }];
    } else {
      // Left or right edge: wide in Z, shallow in X
      const wx = 0.35 + rng() * 0.15; // 0.35-0.50
      const wz = 0.55 + rng() * 0.10; // 0.55-0.65
      return [{ shape: 'rect', x: edge === 2 ? 0.0 : 1.0, z: 0.50, wx, wz, height }];
    }
  }
}

// Check if a collider circle at (cx, cz) with radius r stays within [0,1] UV.
// Returns false if any part extends out of bounds (with float epsilon tolerance).
function collidersInBounds(circles) {
  const EPS = 1e-6;
  for (const [cx, cz, r] of circles) {
    if (cx - r < -EPS || cx + r > 1 + EPS || cz - r < -EPS || cz + r > 1 + EPS) return false;
  }
  return true;
}

function generateForestShape(opts) {
  const {
    seed = 42,
    frequency = 3.5,
    threshold = 0.15,
    density = 40,
    octaves = 2,
    lacunarity = 2.0,
    persistence = 0.5,
    jitter = 0.8,
  } = opts || {};

  const noise = SimplexNoise.create(seed);

  // Seeded PRNG for jitter
  let s = (seed * 7919 + 1) | 0;
  function rng() { s = (s * 1664525 + 1013904223) & 0xFFFFFFFF; return (s >>> 0) / 4294967296; }

  // Sample fractal noise at a point
  function fbm(x, y) {
    let val = 0, amp = 1, freq = frequency, totalAmp = 0;
    for (let o = 0; o < octaves; o++) {
      val += amp * noise(x * freq, y * freq);
      totalAmp += amp;
      freq *= lacunarity;
      amp *= persistence;
    }
    return val / totalAmp; // normalized to approx -1..1
  }

  const trees = [];
  const step = 1 / density;
  // Per-variant collider data in UV space (world values / REGION_SIZE)
  const variants = ['fir_cluster_3', 'fir_cluster_5', 'fir_cluster_7'];
  // Collider offset from anchor in UV (colOff / REGION_SIZE)
  // For variants with colGroups, list ALL collider offsets
  const variantColOffUV = {
    fir_cluster_3: [-0.24/10, -0.22/10],
    fir_cluster_5: [-0.22/10, -0.23/10],
    fir_cluster_7: [-0.48/10, -0.36/10],
  };
  // All collider groups in UV for overlap checking (primary + extras)
  const variantColGroupsUV = {
    fir_cluster_3: [{ off: [-0.24/10, -0.22/10], r: 0.028 }],
    fir_cluster_5: [
      { off: [-0.22/10, -0.23/10], r: 0.033 },
      { off: [-0.31/10, -0.32/10], r: 0.033 },
    ],
    fir_cluster_7: [
      { off: [-0.48/10, -0.36/10], r: 0.040 },
      { off: [-0.82/10, -0.78/10], r: 0.040 },
    ],
  };
  // Collider radius in UV (colR / REGION_SIZE) â€” primary collider
  const variantColRUV = { fir_cluster_3: 0.028, fir_cluster_5: 0.033, fir_cluster_7: 0.040 };

  function getVariant(x, z) {
    return variants[Math.floor((x * 7919 + z * 6271) * 1000) % variants.length];
  }

  // Get all collider centers+radii in UV for a tree at (ax, az) with variant v
  function colCenters(ax, az, v) {
    const groups = variantColGroupsUV[v];
    if (groups) return groups.map(g => [ax + g.off[0], az + g.off[1], g.r]);
    const off = variantColOffUV[v] || [0, 0];
    return [[ax + off[0], az + off[1], variantColRUV[v] || 0.040]];
  }

  const COLLIDER_OVERLAP = 0.175; // allow 17.5% penetration into each collider

  for (let gx = 0; gx < density; gx++) {
    for (let gz = 0; gz < density; gz++) {
      // Base grid position with jitter
      const bx = (gx + 0.5) * step;
      const bz = (gz + 0.5) * step;
      const jx = bx + (rng() - 0.5) * step * jitter;
      const jz = bz + (rng() - 0.5) * step * jitter;

      // Clamp to [0,1]
      const x = Math.max(0, Math.min(1, jx));
      const z = Math.max(0, Math.min(1, jz));
      const v = getVariant(x, z);

      // Reject if any collider circle extends past [0,1]
      const cols = colCenters(x, z, v);
      if (!collidersInBounds(cols)) continue;

      // Sample noise
      const n = fbm(x, z);

      // Place tree if above threshold
      if (n > threshold) {
        let tooClose = false;
        // Check ALL collider circles of new tree against ALL collider circles of existing trees
        const newCols = colCenters(x, z, v);
        for (const t of trees) {
          const existCols = colCenters(t.x, t.z, t.v);
          for (const [ncx, ncz, nR] of newCols) {
            for (const [ecx, ecz, eR] of existCols) {
              const dx = ncx - ecx, dz = ncz - ecz;
              const pairMinDist = (nR + eR) * (1 - COLLIDER_OVERLAP);
              if (dx * dx + dz * dz < pairMinDist * pairMinDist) {
                tooClose = true;
                break;
              }
            }
            if (tooClose) break;
          }
          if (tooClose) break;
        }
        if (!tooClose) trees.push({ x, z, v });
      }
    }
  }

  return trees;
}

// ============================================================
// Forest Stick Generator
// Places forked sticks on the ground, avoiding tree colliders.
// Trees carry per-variant avoidance radii (collider reach from anchor + stick half).
// opts:
//   seed      - random seed
//   count     - number of sticks to attempt placing
//   trees     - array of {x, z, v} tree positions in UV space with variant name
//   margin    - border margin in UV (default 0.025)
// Returns array of { x, z, rotY, flip } in UV space [0,1]
// ============================================================
// Per-variant stick avoidance radius in UV: (offset_magnitude + colR + stick_half) / REGION_SIZE + buffer
const STICK_AVOID_UV = {
  fir_cluster_3: (Math.sqrt(0.24*0.24+0.22*0.22) + 0.28 + 0.32) / 10 + 0.003, // ~0.096
  fir_cluster_5: (Math.sqrt(0.31*0.31+0.32*0.32) + 0.33 + 0.32) / 10 + 0.003, // ~0.113 (uses furthest collider)
  fir_cluster_7: (Math.sqrt(0.82*0.82+0.78*0.78) + 0.40 + 0.32) / 10 + 0.003, // ~0.188 (uses furthest collider)
};
function generateForestSticks(opts) {
  const {
    seed = 42,
    count = 6,
    minCount = 4,
    trees = [],
    margin = 0.025,
  } = opts || {};

  // Stick collider in UV space
  const stickColRUV = 0.22 / 10; // STICK_PASSTHROUGH_RADIUS / REGION_SIZE
  const stickColOffZUV = 0.06 / 10; // STICK_COL_OFFSET_Z / REGION_SIZE

  let s = (seed * 6271 + 3) | 0;
  function rng() { s = (s * 1664525 + 1013904223) & 0xFFFFFFFF; return (s >>> 0) / 4294967296; }

  const sticks = [];
  const stickMinDistSq = 0.04 * 0.04;
  const nearbyDist = 0.12;
  const nearbyDistSq = nearbyDist * nearbyDist;
  const minRotDiff = Math.PI / 4;

  // Build grid of open positions (not blocked by trees)
  // Sample densely then pick from valid spots
  const gridRes = 40;
  const gridStep = 1.0 / gridRes;
  const openSpots = [];
  for (let gi = 0; gi < gridRes; gi++) {
    for (let gj = 0; gj < gridRes; gj++) {
      const x = (gi + 0.5) * gridStep;
      const z = (gj + 0.5) * gridStep;
      let blocked = false;
      for (const t of trees) {
        const dx = x - t.x, dz = z - t.z;
        const avR = STICK_AVOID_UV[t.v] || 0.12;
        if (dx * dx + dz * dz < avR * avR) { blocked = true; break; }
      }
      if (!blocked && collidersInBounds([[x, z + stickColOffZUV, stickColRUV]])) openSpots.push({ x, z });
    }
  }

  // Shuffle open spots using seeded rng
  for (let i = openSpots.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    const tmp = openSpots[i]; openSpots[i] = openSpots[j]; openSpots[j] = tmp;
  }

  // If not enough open spots even at grid resolution, relax tree avoidance
  // by shrinking the radius in steps until we have enough candidates
  if (openSpots.length < minCount) {
    for (let shrink = 0.85; shrink >= 0.5 && openSpots.length < minCount; shrink -= 0.1) {
      for (let gi = 0; gi < gridRes; gi++) {
        for (let gj = 0; gj < gridRes; gj++) {
          const x = (gi + 0.5) * gridStep;
          const z = (gj + 0.5) * gridStep;
          // Check if already in openSpots
          let already = false;
          for (const sp of openSpots) {
            if (Math.abs(sp.x - x) < 0.001 && Math.abs(sp.z - z) < 0.001) { already = true; break; }
          }
          if (already) continue;
          let blocked = false;
          for (const t of trees) {
            const dx = x - t.x, dz = z - t.z;
            const avR = (STICK_AVOID_UV[t.v] || 0.12) * shrink;
            if (dx * dx + dz * dz < avR * avR) { blocked = true; break; }
          }
          if (!blocked && collidersInBounds([[x, z + stickColOffZUV, stickColRUV]])) openSpots.push({ x, z });
        }
      }
    }
  }

  // Place sticks from open spots, checking inter-stick distance and rotation
  const target = Math.min(count, openSpots.length);
  for (let si = 0; si < openSpots.length && sticks.length < target; si++) {
    const { x, z } = openSpots[si];

    // Check distance from existing sticks
    let tooClose = false;
    for (const st of sticks) {
      const dx = x - st.x, dz = z - st.z;
      if (dx * dx + dz * dz < stickMinDistSq) { tooClose = true; break; }
    }
    if (tooClose) continue;

    // Pick rotation that differs from nearby sticks
    let rotY;
    let rotOk = false;
    for (let rotAttempt = 0; rotAttempt < 8; rotAttempt++) {
      rotY = rng() * Math.PI * 2;
      rotOk = true;
      for (const st of sticks) {
        const dx = x - st.x, dz = z - st.z;
        if (dx * dx + dz * dz < nearbyDistSq) {
          let diff = Math.abs(rotY - st.rotY) % Math.PI;
          if (diff > Math.PI / 2) diff = Math.PI - diff;
          if (diff < minRotDiff) { rotOk = false; break; }
        }
      }
      if (rotOk) break;
    }
    if (!rotOk) continue;

    const flip = rng() > 0.5 ? 1 : 0;
    // Check stick collider stays in [0,1] UV
    if (!collidersInBounds([[x, z + stickColOffZUV, stickColRUV]])) continue;
    sticks.push({
      x: Math.round(x * 1000) / 1000,
      z: Math.round(z * 1000) / 1000,
      rotY: Math.round(rotY * 100) / 100,
      flip,
      scale: 0.5,
    });
  }

  // If still below minimum (extremely dense), relax stick-to-stick distance
  if (sticks.length < minCount) {
    const relaxedMinDistSq = 0.02 * 0.02;
    for (let si = 0; si < openSpots.length && sticks.length < minCount; si++) {
      const { x, z } = openSpots[si];
      let tooClose = false;
      for (const st of sticks) {
        const dx = x - st.x, dz = z - st.z;
        if (dx * dx + dz * dz < relaxedMinDistSq) { tooClose = true; break; }
      }
      if (tooClose) continue;
      const rotY = rng() * Math.PI * 2;
      const flip = rng() > 0.5 ? 1 : 0;
      if (!collidersInBounds([[x, z + stickColOffZUV, stickColRUV]])) continue;
      sticks.push({
        x: Math.round(x * 1000) / 1000,
        z: Math.round(z * 1000) / 1000,
        rotY: Math.round(rotY * 100) / 100,
        flip,
        scale: 0.5,
      });
    }
  }

  return sticks;
}

// ============================================================
// Forest Config Generator (wrapper)
// Calls generateForestHill, generateForestShape, and
// generateForestSticks to produce a complete forest config.
// Randomizes sub-generator parameters within generationRules
// ranges using a master seed.
//
// Usage:
//   const config = generateForestConfig({ seed: 5001, id: 'forest_new' });
//   BIOMES.forest.configs.push(config);
// ============================================================
function generateForestConfig(opts) {
  const { seed = 42, id = 'forest_new' } = opts || {};
  // Master PRNG to derive sub-seeds and randomize parameters
  let s = (seed * 9173 + 7) | 0;
  function rng() { s = (s * 1664525 + 1013904223) & 0xFFFFFFFF; return (s >>> 0) / 4294967296; }
  function rngRange(min, max) { return min + rng() * (max - min); }
  function rngInt(min, max) { return Math.floor(rngRange(min, max + 0.999)); }

  // Derive unique sub-seeds
  const hillSeed = Math.floor(rng() * 100000);
  const shapeSeed = Math.floor(rng() * 100000);
  const stickSeed = Math.floor(rng() * 100000);

  // Generate hill
  const hills = generateForestHill({ seed: hillSeed });

  // Randomize shape parameters within generationRules ranges
  const trees = generateForestShape({
    seed: shapeSeed,
    frequency: rngRange(2.5, 4.5),
    threshold: rngRange(0.12, 0.22),
    density: rngInt(35, 45),
    octaves: rngInt(1, 3),
    jitter: rngRange(0.6, 0.9),
  });

  // Generate sticks (needs full variant names for avoidance radii)
  const stickCount = rngInt(4, 8);
  const sticks = generateForestSticks({
    seed: stickSeed,
    count: stickCount,
    trees: trees, // full variant names (fir_cluster_3 etc.)
  });

  // Shorten variant names for static config format
  const VARIANT_SHORT = {
    fir_cluster_3: 'c3', fir_cluster_5: 'c5', fir_cluster_7: 'c7',
  };
  const shortTrees = trees.map(t => ({
    x: Math.round(t.x * 1000) / 1000,
    z: Math.round(t.z * 1000) / 1000,
    v: VARIANT_SHORT[t.v] || t.v,
  }));

  return { id, seed, terrain: { hills }, items: { trees: shortTrees, rocks: [], sticks, minables: [] } };
}

// ============================================================
// Rock Config Generator
// Produces a complete rock biome config from a seed, using the
// generationRules defined on the rock biome. Output format
// matches the static configs (terrain.hills, items.{trees, rocks, sticks, minables}).
//
// Trees are {x, z} only â€” variant is assigned at build time via
// the hash in buildRegion (no 'v' property needed).
//
// Minable clusters include material:'crystal' and cubes with
// pre-scale values (cubeScaleFactor is applied at build time).
//
// Usage:
//   const config = generateRockConfig({ seed: 12345, id: 'rock_new' });
//   BIOMES.rock.configs.push(config);
// ============================================================
function generateRockConfig(opts) {
  const { seed = 42, id = 'rock_new' } = opts || {};
  let s = (seed * 6271 + 3) | 0;
  function rng() { s = (s * 1664525 + 1013904223) & 0xFFFFFFFF; return (s >>> 0) / 4294967296; }
  function rngRange(min, max) { return min + rng() * (max - min); }
  function rngInt(min, max) { return Math.floor(rngRange(min, max + 0.999)); }
  function round(v, d) { const m = Math.pow(10, d); return Math.round(v * m) / m; }

  // --- Hills ---
  const hillCount = rngInt(7, 13);
  const hills = [];
  for (let i = 0; i < hillCount; i++) {
    const x = round(rngRange(0.0, 1.0), 2);
    // Weighted z distribution: 45% back, 30% mid, 25% front
    const zRoll = rng();
    let z, heightBase;
    if (zRoll < 0.45) {
      z = rngRange(0.0, 0.40);
      heightBase = 0.40;
    } else if (zRoll < 0.75) {
      z = rngRange(0.35, 0.60);
      heightBase = 0.25;
    } else {
      z = rngRange(0.60, 1.0);
      heightBase = 0.12;
    }
    const radius = round(rngRange(0.18, 0.40), 2);
    const height = round(heightBase + rngRange(0.00, 0.30), 2);
    hills.push({ x, z: round(z, 2), radius, height });
  }

  // --- Trees (clustered placement) ---
  // Rock trees use dry/sparse/bare/scraggly: colR=0.055, colOff=[0,0]
  const rockTreeColRUV = 0.055 / 10; // colR / REGION_SIZE
  const rockTreeVariants = ['dry', 'sparse', 'bare', 'scraggly'];
  function pickRockTreeVariant() {
    return rockTreeVariants[Math.floor(rng() * rockTreeVariants.length)];
  }
  const clusterCount = rngInt(8, 12);
  const allTrees = [];
  const treeMinDistSq = 0.012 * 0.012; // prevent exact overlaps
  for (let ci = 0; ci < clusterCount; ci++) {
    const cx = rngRange(0.0, 1.0);
    const cz = rngRange(0.0, 1.0);
    const treesInCluster = rngInt(4, 11);
    for (let ti = 0; ti < treesInCluster; ti++) {
      let tx, tz, placed = false;
      for (let attempt = 0; attempt < 20; attempt++) {
        const angle = rng() * Math.PI * 2;
        const dist = rng() * 0.12;
        tx = cx + Math.cos(angle) * dist;
        tz = cz + Math.sin(angle) * dist;
        tx = Math.max(0.0, Math.min(1.0, tx));
        tz = Math.max(0.0, Math.min(1.0, tz));
        if (!collidersInBounds([[tx, tz, rockTreeColRUV]])) continue;
        let tooClose = false;
        for (const et of allTrees) {
          const dx = tx - et.x, dz = tz - et.z;
          if (dx * dx + dz * dz < treeMinDistSq) { tooClose = true; break; }
        }
        if (!tooClose) { placed = true; break; }
      }
      if (placed) {
        allTrees.push({ x: round(tx, 3), z: round(tz, 3), v: pickRockTreeVariant() });
      }
    }
    // Early exit if we have enough trees
    if (allTrees.length >= 76) break;
  }
  // Trim to totalRange max if overshot
  while (allTrees.length > 76) allTrees.pop();

  // --- Rocks ---
  const rockColBase = 0.15; // ROCK_COLLISION_RADIUS_BASE
  const RS_UV = 10; // REGION_SIZE
  const rockCount = rngInt(8, 14);
  const rocks = [];
  const rockMinDistSq = 0.06 * 0.06;
  for (let ri = 0; ri < rockCount; ri++) {
    let rx, rz, rScale, placed = false;
    for (let attempt = 0; attempt < 30; attempt++) {
      rx = rngRange(0.0, 1.0);
      rz = rngRange(0.0, 1.0);
      rScale = round(rngRange(0.60, 1.00), 2);
      const rockColRUV = rockColBase * rScale / RS_UV;
      if (!collidersInBounds([[rx, rz, rockColRUV]])) continue;
      let tooClose = false;
      for (const er of rocks) {
        const dx = rx - er.x, dz = rz - er.z;
        if (dx * dx + dz * dz < rockMinDistSq) { tooClose = true; break; }
      }
      if (!tooClose) { placed = true; break; }
    }
    if (placed) {
      rocks.push({
        x: round(rx, 3),
        z: round(rz, 3),
        rotY: round(rngRange(0.0, 6.28), 1),
        scale: rScale,
      });
    }
  }

  // --- Minable clusters ---
  // Cluster visual extent: center ± 0.065 (cube dx/dz range) ± ~0.016 (half cube size in UV)
  // ≈ 0.08 UV radius per cluster. Enforce enough separation so clusters don't visually merge.
  // Edge margin ensures cluster center + max cube offset stays within [0,1] UV.
  const minableEdgeMargin = 0.09;
  const clusterMinDist = 0.22; // ~2x cluster visual radius
  const clusterMinDistSq = clusterMinDist * clusterMinDist;
  const clusterCountM = rngInt(2, 5);
  const minables = [];
  for (let mi = 0; mi < clusterCountM; mi++) {
    let mx, mz, placed = false;
    for (let attempt = 0; attempt < 40; attempt++) {
      mx = rngRange(minableEdgeMargin, 1.0 - minableEdgeMargin);
      mz = rngRange(minableEdgeMargin, 1.0 - minableEdgeMargin);
      let tooClose = false;
      for (const em of minables) {
        const dx = mx - em.x, dz = mz - em.z;
        if (dx * dx + dz * dz < clusterMinDistSq) { tooClose = true; break; }
      }
      if (!tooClose) { placed = true; break; }
    }
    if (!placed) continue;

    const cubeCount = rngInt(8, 15);
    const cubes = [];
    for (let ci = 0; ci < cubeCount; ci++) {
      cubes.push({
        dx: round(rngRange(-0.065, 0.065), 3),
        dz: round(rngRange(-0.065, 0.065), 3),
        sx: round(rngRange(0.10, 0.32), 2),
        sy: round(rngRange(0.12, 0.28), 2),
        sz: round(rngRange(0.10, 0.24), 2),
        rotY: round(rngRange(0.0, 6.28), 1),
        rotZ: round(rngRange(-0.28, 0.28), 2),
      });
    }
    // Compute cluster colliders in UV space via k-means grouping.
    // Stored as {dx, dz, r} offsets from cluster center; buildRegion converts to world space.
    const cubeScaleUV = 0.7 / 10; // cubeScaleFactor / REGION_SIZE
    const numK = Math.min(4, cubes.length);
    let kCenters = [];
    for (let ki = 0; ki < numK; ki++) {
      const c = cubes[Math.floor(ki * cubes.length / numK)];
      kCenters.push({ dx: c.dx, dz: c.dz });
    }
    for (let iter = 0; iter < 8; iter++) {
      const kGroups = kCenters.map(() => []);
      for (const c of cubes) {
        let best = 0, bestD = Infinity;
        for (let k = 0; k < kCenters.length; k++) {
          const ddx = c.dx - kCenters[k].dx, ddz = c.dz - kCenters[k].dz;
          if (ddx * ddx + ddz * ddz < bestD) { bestD = ddx * ddx + ddz * ddz; best = k; }
        }
        kGroups[best].push(c);
      }
      for (let k = 0; k < kCenters.length; k++) {
        if (kGroups[k].length === 0) continue;
        let sdx = 0, sdz = 0;
        for (const c of kGroups[k]) { sdx += c.dx; sdz += c.dz; }
        kCenters[k].dx = sdx / kGroups[k].length;
        kCenters[k].dz = sdz / kGroups[k].length;
      }
    }
    const kGroups = kCenters.map(() => []);
    for (const c of cubes) {
      let best = 0, bestD = Infinity;
      for (let k = 0; k < kCenters.length; k++) {
        const ddx = c.dx - kCenters[k].dx, ddz = c.dz - kCenters[k].dz;
        if (ddx * ddx + ddz * ddz < bestD) { bestD = ddx * ddx + ddz * ddz; best = k; }
      }
      kGroups[best].push(c);
    }
    const colliders = [];
    for (let k = 0; k < kCenters.length; k++) {
      if (kGroups[k].length === 0) continue;
      if (kGroups[k].length === 1) {
        const c = kGroups[k][0];
        const r = Math.max(c.sx, c.sz) * cubeScaleUV;
        colliders.push({ dx: round(kCenters[k].dx, 3), dz: round(kCenters[k].dz, 3), r: round(r, 4) });
      } else {
        let maxR = 0;
        for (const c of kGroups[k]) {
          const ddx = c.dx - kCenters[k].dx, ddz = c.dz - kCenters[k].dz;
          const r = Math.sqrt(ddx * ddx + ddz * ddz) + Math.max(c.sx, c.sz) * cubeScaleUV * 0.5;
          if (r > maxR) maxR = r;
        }
        colliders.push({ dx: round(kCenters[k].dx, 3), dz: round(kCenters[k].dz, 3), r: round(Math.max(maxR * 0.75, 0.004), 4) });
      }
    }
    for (const c of cubes) {
      let covered = false;
      for (const col of colliders) {
        const ddx = c.dx - col.dx, ddz = c.dz - col.dz;
        if (Math.sqrt(ddx * ddx + ddz * ddz) <= col.r + 0.001) { covered = true; break; }
      }
      if (!covered) {
        const r = Math.max(c.sx, c.sz) * cubeScaleUV;
        colliders.push({ dx: round(c.dx, 3), dz: round(c.dz, 3), r: round(r, 4) });
      }
    }
    // Nudge cluster center if any collider extends outside [0,1] UV
    let nudgeX = 0, nudgeZ = 0;
    for (const col of colliders) {
      const absX = mx + col.dx, absZ = mz + col.dz;
      if (absX - col.r < 0) nudgeX = Math.max(nudgeX, col.r - absX);
      if (absX + col.r > 1) nudgeX = Math.min(nudgeX, 1 - col.r - absX);
      if (absZ - col.r < 0) nudgeZ = Math.max(nudgeZ, col.r - absZ);
      if (absZ + col.r > 1) nudgeZ = Math.min(nudgeZ, 1 - col.r - absZ);
    }
    if (nudgeX !== 0 || nudgeZ !== 0) {
      mx = mx + nudgeX;
      mz = mz + nudgeZ;
    }
    minables.push({ material: 'crystal', x: round(mx, 3), z: round(mz, 3), cubes, colliders });
  }

  return { id, seed, terrain: { hills }, items: { trees: allTrees, rocks, sticks: [], minables } };
}

// ============================================================
// Desert Config Generator
// Produces a complete desert biome config from a seed.
// Deserts are flat (no hills) with scattered cacti, dead bushes,
// and a few rocks. No minables â€” no desert-specific minable
// material exists yet.
//
// Trees use short variant aliases: sg, br, pp, db
// weighted 40/25/20/15 per generationRules.
//
// Usage:
//   const config = generateDesertConfig({ seed: 9001, id: 'desert_new' });
//   BIOMES.desert.configs.push(config);
// ============================================================
function generateDesertConfig(opts) {
  const { seed = 42, id = 'desert_new' } = opts || {};
  let s = (seed * 6271 + 3) | 0;
  function rng() { s = (s * 1664525 + 1013904223) & 0xFFFFFFFF; return (s >>> 0) / 4294967296; }
  function rngRange(min, max) { return min + rng() * (max - min); }
  function rngInt(min, max) { return Math.floor(rngRange(min, max + 0.999)); }
  function round(v, d) { const m = Math.pow(10, d); return Math.round(v * m) / m; }

  // --- No hills (flat desert) ---
  const hills = [];

  // --- Trees (weighted variant selection, scattered placement) ---
  const treeCount = rngInt(14, 22);
  const trees = [];
  const treeMinDistSq = 0.06 * 0.06; // minSpacing from generationRules
  // Weighted variant selection: sg 40%, br 25%, pp 20%, db 15%
  function pickVariant() {
    const r = rng();
    if (r < 0.40) return 'sg';
    if (r < 0.65) return 'br';
    if (r < 0.85) return 'pp';
    return 'db';
  }
  // Desert tree colR in UV: max is prickly at 0.07/10 = 0.007, all colOff=[0,0]
  const desertMaxColRUV = 0.07 / 10;
  for (let ti = 0; ti < treeCount; ti++) {
    let tx, tz, tv, placed = false;
    for (let attempt = 0; attempt < 30; attempt++) {
      tx = rngRange(0.0, 1.0);
      tz = rngRange(0.0, 1.0);
      tv = pickVariant();
      if (!collidersInBounds([[tx, tz, desertMaxColRUV]])) continue;
      let tooClose = false;
      for (const et of trees) {
        const dx = tx - et.x, dz = tz - et.z;
        if (dx * dx + dz * dz < treeMinDistSq) { tooClose = true; break; }
      }
      if (!tooClose) { placed = true; break; }
    }
    if (placed) {
      trees.push({ x: round(tx, 3), z: round(tz, 3), v: tv });
    }
  }

  // --- Rocks ---
  const desertRockColBase = 0.15; // ROCK_COLLISION_RADIUS_BASE
  const desertRS = 10;
  const rockCount = rngInt(4, 8);
  const rocks = [];
  const rockMinDistSq = 0.06 * 0.06;
  for (let ri = 0; ri < rockCount; ri++) {
    let rx, rz, rScale, placed = false;
    for (let attempt = 0; attempt < 30; attempt++) {
      rx = rngRange(0.0, 1.0);
      rz = rngRange(0.0, 1.0);
      rScale = round(rngRange(0.50, 0.85), 2);
      const rColRUV = desertRockColBase * rScale / desertRS;
      if (!collidersInBounds([[rx, rz, rColRUV]])) continue;
      let tooClose = false;
      for (const er of rocks) {
        const dx = rx - er.x, dz = rz - er.z;
        if (dx * dx + dz * dz < rockMinDistSq) { tooClose = true; break; }
      }
      if (!tooClose) { placed = true; break; }
    }
    if (placed) {
      rocks.push({
        x: round(rx, 3),
        z: round(rz, 3),
        rotY: round(rngRange(0.0, 6.28), 1),
        scale: rScale,
      });
    }
  }

  // --- No minables yet (no desert-specific minable material defined) ---

  return { id, seed, terrain: { hills }, items: { trees, rocks, sticks: [], minables: [] } };
}

// ============================================================
// Biome Definitions
// Each biome has: terrain (hills, ground shader palette), and
// one or more configurations of trees, rocks, and minables.
// ============================================================

// ==========================================================
// MINABLE MATERIALS REGISTRY
// ==========================================================
// "Minable" is a gameplay concept â€” something the player can mine.
// Each material fully defines its own rendering. Different materials
// can look and behave completely differently â€” different meshes,
// colors, effects, ground treatments. Nothing is assumed shared.
//
// A biome region can contain clusters of different materials.
// Each cluster in a config specifies its material key.
//
// Rendering is material-driven: the render loop reads properties
// from this registry. To add a new material, define it here and
// add any material-specific rendering paths to the render loop.
//
const MINABLE_MATERIALS = {
  crystal: {
    name: 'Crystal',
    mesh: 'cube',                          // mesh key (currently only 'cube')
    color: [0.18, 0.38, 0.65],            // base RGB for 3D geometry
    emissiveBase: 0.15,                    // constant emissive
    emissiveWave: 0.15,                    // wave-proximity emissive boost
    shininess: 1.2,                        // specular (scaled by wave proximity)
    glow: { enabled: true, color: [0.08, 0.18, 0.65] },  // additive glow billboards
    crystalGroundOverlay: true,            // crystal-specific blue ground texture
  },
  // Future materials define their own properties. Examples:
  // amber: { name: 'Amber', mesh: 'cube', color: [...], emissiveBase: 0.08, ... }
  // fossils might use a custom mesh, no glow, no ground effect, etc.
};

const BIOMES = {
  rock: {
    name: 'Rock Biome',
    borderMargin: 0.03, // UV margin on edges adjacent to a different biome
    // --------------------------------------------------------
    // Generation rules used to produce each static config.
    // Apply these with a seeded PRNG to create new configs.
    // The static data below was generated from these rules
    // and should not be regenerated â€” only new configs use them.
    // --------------------------------------------------------
    generationRules: {
      hills: {
        count: { min: 7, max: 13 },
        x: { min: 0.0, max: 1.0 },
        z: { distribution: 'weighted', // 45% back, 30% mid, 25% front
          back:  { range: [0.05, 0.40], weight: 0.45 },
          mid:   { range: [0.35, 0.60], weight: 0.30 },
          front: { range: [0.60, 0.90], weight: 0.25 },
        },
        radius: { min: 0.18, max: 0.40 },
        height: { // base determined by z-zone, then random addition
          backBase: 0.40, midBase: 0.25, frontBase: 0.12,
          randomAdd: { min: 0.0, max: 0.30 },
        },
      },
      trees: {
        clusterCount: { min: 8, max: 12 },
        treesPerCluster: { min: 4, max: 11 },
        totalRange: { min: 46, max: 76 }, // observed across configs
        clusterCenter: { x: [0.0, 1.0], z: [0.0, 1.0] },
        intraClusterSpacing: { min: 0.025, max: 0.060 },
        clusterRadius: 0.12, // max distance from cluster center to member
      },
      rocks: {
        count: { min: 8, max: 14 },
        x: { min: 0.0, max: 1.0 },
        z: { min: 0.0, max: 1.0 },
        scale: { min: 0.60, max: 1.00 },
        rotY: { min: 0.0, max: 6.28 }, // full rotation
      },
      minables: {
        clusterCount: { min: 2, max: 5 },
        cubesPerCluster: { min: 8, max: 15 },
        clusterCenter: { x: [0.10, 0.90], z: [0.10, 0.90] },
        cube: {
          dx: { min: -0.065, max: 0.065 },
          dz: { min: -0.065, max: 0.065 },
          sx: { min: 0.10, max: 0.32 },
          sy: { min: 0.12, max: 0.28 },
          sz: { min: 0.10, max: 0.24 },
          rotY: { min: 0.0, max: 6.28 },
          rotZ: { min: -0.28, max: 0.28 },
        },
        cubeScaleFactor: 0.7, // applied at build time to sx/sy/sz
        glowSizeMultiplier: 1.8, // max(sx,sy,sz) * scaleFactor * this
      },
    },
    // ---- ROCK BIOME HILL GENERATION RULES ----
    // When generating new rock configs, follow these rules for hills:
    //   - Number of hills: 7-13 per config (vary for diversity)
    //   - Hill x position: 0.10 to 0.90 (avoid extreme edges)
    //   - Hill z distribution (weighted toward back):
    //       45% chance: back region,  z = 0.05 to 0.40
    //       30% chance: mid region,   z = 0.35 to 0.60
    //       25% chance: front region, z = 0.60 to 0.90
    //   - Radius: 0.18 to 0.40
    //   - Height varies by z region + random 0.00-0.30:
    //       back (z < 0.35):  base 0.40, total ~0.40-0.70
    //       mid (z 0.35-0.60): base 0.25, total ~0.25-0.55
    //       front (z > 0.60): base 0.12, total ~0.12-0.42
    // -------------------------------------------
    // Tree sprite variants for this biome
    treeVariants: ['dry', 'sparse', 'bare', 'scraggly'],
    // Configurations: different arrangements of trees/rocks/minables
    configs: [
      {
        id: 'rock_1',
        seed: 101,
        terrain: {
          hills: [
            { x: 0.69, z: 0.35, radius: 0.35, height: 0.47 },
            { x: 0.99, z: 0.18, radius: 0.39, height: 0.65 },
            { x: 0.96, z: 0.17, radius: 0.22, height: 0.43 },
            { x: 0.6, z: 0.94, radius: 0.29, height: 0.14 },
            { x: 0.69, z: 0.05, radius: 0.33, height: 0.68 },
            { x: 0.12, z: 0.12, radius: 0.32, height: 0.49 },
            { x: 0.46, z: 0.24, radius: 0.25, height: 0.66 },
            { x: 0.3, z: 0.55, radius: 0.36, height: 0.42 },
            { x: 0.53, z: 1, radius: 0.39, height: 0.31 },
            { x: 0.84, z: 0.09, radius: 0.23, height: 0.63 },
            { x: 0.66, z: 0.67, radius: 0.27, height: 0.27 }
          ]
        },
        items: {
          trees: [
            { x: 0.538, z: 0.076, v: 'scraggly' },
            { x: 0.518, z: 0.077, v: 'bare' },
            { x: 0.546, z: 0.199, v: 'sparse' },
            { x: 0.511, z: 0.171, v: 'dry' },
            { x: 0.549, z: 0.092, v: 'scraggly' },
            { x: 0.757, z: 0.511, v: 'bare' },
            { x: 0.817, z: 0.563, v: 'sparse' },
            { x: 0.678, z: 0.616, v: 'dry' },
            { x: 0.775, z: 0.599, v: 'sparse' },
            { x: 0.848, z: 0.626, v: 'dry' },
            { x: 0.757, z: 0.524, v: 'bare' },
            { x: 0.707, z: 0.634, v: 'sparse' },
            { x: 0.754, z: 0.665, v: 'scraggly' },
            { x: 0.799, z: 0.607, v: 'dry' },
            { x: 0.354, z: 0.015, v: 'dry' },
            { x: 0.299, z: 0.123, v: 'dry' },
            { x: 0.243, z: 0.086, v: 'dry' },
            { x: 0.29, z: 0.143, v: 'bare' },
            { x: 0.32, z: 0.008, v: 'dry' },
            { x: 0.334, z: 0.053, v: 'bare' },
            { x: 0.324, z: 0.023, v: 'bare' },
            { x: 0.935, z: 0.861, v: 'dry' },
            { x: 0.968, z: 0.882, v: 'scraggly' },
            { x: 0.943, z: 0.796, v: 'sparse' },
            { x: 0.847, z: 0.985, v: 'scraggly' },
            { x: 0.916, z: 0.98, v: 'sparse' },
            { x: 0.906, z: 0.902, v: 'bare' },
            { x: 0.921, z: 0.785, v: 'dry' },
            { x: 0.931, z: 0.926, v: 'sparse' },
            { x: 0.907, z: 0.854, v: 'bare' },
            { x: 0.011, z: 0.462, v: 'sparse' },
            { x: 0.069, z: 0.531, v: 'bare' },
            { x: 0.121, z: 0.499, v: 'bare' },
            { x: 0.131, z: 0.538, v: 'dry' },
            { x: 0.067, z: 0.593, v: 'dry' },
            { x: 0.049, z: 0.509, v: 'sparse' },
            { x: 0.09, z: 0.459, v: 'sparse' },
            { x: 0.095, z: 0.332, v: 'scraggly' },
            { x: 0.126, z: 0.39, v: 'scraggly' },
            { x: 0.095, z: 0.494, v: 'bare' },
            { x: 0.108, z: 0.414, v: 'sparse' },
            { x: 0.507, z: 0.762, v: 'bare' },
            { x: 0.588, z: 0.644, v: 'scraggly' },
            { x: 0.474, z: 0.727, v: 'dry' },
            { x: 0.575, z: 0.753, v: 'sparse' },
            { x: 0.583, z: 0.702, v: 'sparse' },
            { x: 0.661, z: 0.645, v: 'sparse' },
            { x: 0.551, z: 0.691, v: 'scraggly' },
            { x: 0.644, z: 0.667, v: 'sparse' },
            { x: 0.495, z: 0.844, v: 'scraggly' },
            { x: 0.479, z: 0.975, v: 'bare' },
            { x: 0.471, z: 0.917, v: 'bare' },
            { x: 0.546, z: 0.877, v: 'scraggly' },
            { x: 0.373, z: 0.992, v: 'sparse' },
            { x: 0.455, z: 0.95, v: 'scraggly' },
            { x: 0.429, z: 0.919, v: 'dry' },
            { x: 0.154, z: 0.049, v: 'scraggly' },
            { x: 0.162, z: 0.059, v: 'sparse' },
            { x: 0.098, z: 0.013, v: 'bare' },
            { x: 0.095, z: 0.104, v: 'dry' },
            { x: 0.173, z: 0.017, v: 'scraggly' },
            { x: 0.209, z: 0.122, v: 'sparse' },
            { x: 0.077, z: 0.016, v: 'sparse' },
            { x: 0.086, z: 0.025, v: 'dry' },
            { x: 0.188, z: 0.009, v: 'bare' },
            { x: 0.037, z: 0.026, v: 'bare' },
            { x: 0.049, z: 0.034, v: 'scraggly' },
            { x: 0.073, z: 0.067, v: 'scraggly' },
            { x: 0.071, z: 0.033, v: 'sparse' },
            { x: 0.084, z: 0.114, v: 'dry' },
            { x: 0.114, z: 0.03, v: 'dry' },
            { x: 0.039, z: 0.091, v: 'sparse' },
            { x: 0.378, z: 0.527, v: 'sparse' },
            { x: 0.366, z: 0.583, v: 'scraggly' },
            { x: 0.302, z: 0.635, v: 'bare' },
            { x: 0.366, z: 0.52, v: 'dry' }
          ],
          rocks: [
            { x: 0.945, z: 0.608, rotY: 0.5, scale: 0.89 },
            { x: 0.203, z: 0.38, rotY: 5.7, scale: 0.99 },
            { x: 0.273, z: 0.78, rotY: 4.4, scale: 0.78 },
            { x: 0.539, z: 0.184, rotY: 2.1, scale: 0.79 },
            { x: 0.677, z: 0.036, rotY: 2, scale: 0.95 },
            { x: 0.764, z: 0.857, rotY: 2.5, scale: 0.87 },
            { x: 0.757, z: 0.553, rotY: 1.5, scale: 0.78 },
            { x: 0.103, z: 0.958, rotY: 4.5, scale: 0.95 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.756,
              z: 0.872,
              cubes: [
                { dx: -0.056, dz: 0.019, sx: 0.11, sy: 0.24, sz: 0.17, rotY: 1.6, rotZ: -0.12 },
                { dx: 0.049, dz: 0.026, sx: 0.26, sy: 0.25, sz: 0.12, rotY: 3.7, rotZ: -0.12 },
                { dx: -0.059, dz: -0.009, sx: 0.18, sy: 0.14, sz: 0.17, rotY: 3.5, rotZ: -0.01 },
                { dx: 0.004, dz: -0.004, sx: 0.2, sy: 0.13, sz: 0.16, rotY: 0.5, rotZ: 0.2 },
                { dx: -0.024, dz: -0.005, sx: 0.13, sy: 0.15, sz: 0.17, rotY: 0.5, rotZ: 0 },
                { dx: -0.015, dz: -0.025, sx: 0.17, sy: 0.27, sz: 0.22, rotY: 2.8, rotZ: -0.01 },
                { dx: 0.016, dz: 0.017, sx: 0.26, sy: 0.17, sz: 0.12, rotY: 3.5, rotZ: 0.14 },
                { dx: 0.046, dz: 0.023, sx: 0.2, sy: 0.2, sz: 0.12, rotY: 0.8, rotZ: 0.06 },
                { dx: -0.055, dz: -0.058, sx: 0.2, sy: 0.16, sz: 0.13, rotY: 0, rotZ: 0.24 },
                { dx: 0.026, dz: 0.065, sx: 0.29, sy: 0.24, sz: 0.19, rotY: 0.5, rotZ: 0.01 },
                { dx: 0.065, dz: -0.058, sx: 0.27, sy: 0.2, sz: 0.21, rotY: 2.9, rotZ: 0.27 },
                { dx: -0.012, dz: 0.015, sx: 0.15, sy: 0.21, sz: 0.2, rotY: 4.1, rotZ: -0.23 },
                { dx: -0.017, dz: -0.045, sx: 0.13, sy: 0.26, sz: 0.17, rotY: 4.3, rotZ: -0.26 },
                { dx: 0.041, dz: 0.022, sx: 0.14, sy: 0.17, sz: 0.12, rotY: 5, rotZ: 0.14 },
                { dx: 0.019, dz: -0.052, sx: 0.15, sy: 0.17, sz: 0.21, rotY: 0.1, rotZ: 0.27 }
              ],
              colliders: [
                { dx: -0.057, dz: -0.016, r: 0.0368 },
                { dx: 0.022, dz: -0.052, r: 0.0394 },
                { dx: 0.036, dz: 0.031, r: 0.0344 },
                { dx: -0.012, dz: -0.005, r: 0.0212 },
                { dx: -0.055, dz: -0.058, r: 0.014 },
                { dx: 0.026, dz: 0.065, r: 0.0203 },
                { dx: 0.065, dz: -0.058, r: 0.0189 }
              ]
            },
            {
              material: 'crystal',
              x: 0.177,
              z: 0.113,
              cubes: [
                { dx: 0.05, dz: -0.024, sx: 0.19, sy: 0.2, sz: 0.15, rotY: 0.4, rotZ: -0.12 },
                { dx: -0.062, dz: 0.053, sx: 0.13, sy: 0.27, sz: 0.17, rotY: 1, rotZ: -0.07 },
                { dx: 0.052, dz: 0.025, sx: 0.27, sy: 0.15, sz: 0.17, rotY: 2.8, rotZ: -0.21 },
                { dx: -0.054, dz: 0.011, sx: 0.31, sy: 0.18, sz: 0.23, rotY: 2.3, rotZ: -0.21 },
                { dx: 0.045, dz: 0.003, sx: 0.15, sy: 0.18, sz: 0.19, rotY: 0.1, rotZ: 0.04 },
                { dx: 0.04, dz: 0, sx: 0.26, sy: 0.28, sz: 0.19, rotY: 0.1, rotZ: -0.01 },
                { dx: 0.031, dz: 0.004, sx: 0.15, sy: 0.15, sz: 0.12, rotY: 1.3, rotZ: -0.1 },
                { dx: -0.025, dz: 0.059, sx: 0.11, sy: 0.13, sz: 0.21, rotY: 3, rotZ: -0.18 },
                { dx: -0.042, dz: -0.011, sx: 0.24, sy: 0.24, sz: 0.17, rotY: 0.9, rotZ: -0.13 },
                { dx: 0.02, dz: -0.063, sx: 0.29, sy: 0.2, sz: 0.11, rotY: 1.6, rotZ: -0.16 },
                { dx: 0.018, dz: 0.062, sx: 0.26, sy: 0.19, sz: 0.18, rotY: 0.8, rotZ: -0.12 }
              ],
              colliders: [
                { dx: 0.035, dz: -0.043, r: 0.0261 },
                { dx: 0.035, dz: 0.044, r: 0.0259 },
                { dx: 0.039, dz: 0.002, r: 0.0098 },
                { dx: -0.046, dz: 0.028, r: 0.0357 },
                { dx: -0.025, dz: 0.059, r: 0.0147 },
                { dx: -0.042, dz: -0.011, r: 0.0168 }
              ]
            },
            {
              material: 'crystal',
              x: 0.372,
              z: 0.804,
              cubes: [
                { dx: 0.02, dz: -0.015, sx: 0.2, sy: 0.26, sz: 0.19, rotY: 2.5, rotZ: 0.13 },
                { dx: -0.01, dz: 0.004, sx: 0.25, sy: 0.15, sz: 0.12, rotY: 2.6, rotZ: -0.03 },
                { dx: 0.057, dz: 0.006, sx: 0.22, sy: 0.21, sz: 0.2, rotY: 3.9, rotZ: 0.19 },
                { dx: 0.006, dz: 0.025, sx: 0.27, sy: 0.15, sz: 0.11, rotY: 1.1, rotZ: -0.11 },
                { dx: -0.026, dz: -0.062, sx: 0.14, sy: 0.2, sz: 0.22, rotY: 3.1, rotZ: 0.25 },
                { dx: -0.035, dz: 0.03, sx: 0.31, sy: 0.17, sz: 0.1, rotY: 2.7, rotZ: 0 },
                { dx: -0.01, dz: 0.024, sx: 0.22, sy: 0.27, sz: 0.12, rotY: 4.2, rotZ: -0.14 },
                { dx: -0.061, dz: -0.028, sx: 0.17, sy: 0.17, sz: 0.15, rotY: 0.5, rotZ: 0.01 },
                { dx: 0.035, dz: -0.03, sx: 0.11, sy: 0.13, sz: 0.19, rotY: 3.7, rotZ: -0.14 },
                { dx: 0.057, dz: 0, sx: 0.1, sy: 0.24, sz: 0.23, rotY: 0.3, rotZ: -0.22 },
                { dx: 0.013, dz: -0.061, sx: 0.11, sy: 0.18, sz: 0.17, rotY: 3.2, rotZ: -0.16 },
                { dx: -0.033, dz: 0.04, sx: 0.28, sy: 0.27, sz: 0.19, rotY: 1.6, rotZ: -0.06 },
                { dx: 0.014, dz: 0.033, sx: 0.16, sy: 0.17, sz: 0.23, rotY: 4.7, rotZ: 0.03 },
                { dx: -0.023, dz: 0.064, sx: 0.19, sy: 0.15, sz: 0.15, rotY: 6.2, rotZ: 0.13 },
                { dx: -0.007, dz: -0.041, sx: 0.16, sy: 0.13, sz: 0.19, rotY: 1.3, rotZ: 0.06 }
              ],
              colliders: [
                { dx: 0.036, dz: -0.02, r: 0.0399 },
                { dx: 0, dz: 0.022, r: 0.0217 },
                { dx: -0.031, dz: -0.044, r: 0.0296 },
                { dx: -0.03, dz: 0.045, r: 0.0205 },
                { dx: -0.061, dz: -0.028, r: 0.0119 },
                { dx: 0.013, dz: -0.061, r: 0.0119 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_2',
        seed: 201,
        terrain: {
          hills: [
            { x: 0.02, z: 0.93, radius: 0.35, height: 0.34 },
            { x: 0.32, z: 0.53, radius: 0.38, height: 0.3 },
            { x: 0.67, z: 0.7, radius: 0.37, height: 0.25 },
            { x: 0.61, z: 0.61, radius: 0.33, height: 0.33 },
            { x: 0.66, z: 0.04, radius: 0.35, height: 0.6 },
            { x: 0.08, z: 0.66, radius: 0.2, height: 0.3 },
            { x: 0.66, z: 0.42, radius: 0.3, height: 0.49 },
            { x: 0.85, z: 0.55, radius: 0.36, height: 0.31 },
            { x: 0.44, z: 0.1, radius: 0.34, height: 0.61 },
            { x: 0.88, z: 0.14, radius: 0.26, height: 0.64 },
            { x: 0.61, z: 0.58, radius: 0.21, height: 0.5 },
            { x: 0.6, z: 0.44, radius: 0.25, height: 0.33 }
          ]
        },
        items: {
          trees: [
            { x: 0.3, z: 0.085, v: 'sparse' },
            { x: 0.173, z: 0.087, v: 'scraggly' },
            { x: 0.128, z: 0.035, v: 'dry' },
            { x: 0.276, z: 0.064, v: 'bare' },
            { x: 0.261, z: 0.078, v: 'bare' },
            { x: 0.832, z: 0.238, v: 'sparse' },
            { x: 0.862, z: 0.215, v: 'bare' },
            { x: 0.928, z: 0.275, v: 'sparse' },
            { x: 0.889, z: 0.197, v: 'dry' },
            { x: 0.807, z: 0.151, v: 'bare' },
            { x: 0.854, z: 0.144, v: 'bare' },
            { x: 0.921, z: 0.212, v: 'dry' },
            { x: 0.851, z: 0.234, v: 'scraggly' },
            { x: 0.806, z: 0.19, v: 'bare' },
            { x: 0.819, z: 0.239, v: 'scraggly' },
            { x: 0.833, z: 0.158, v: 'sparse' },
            { x: 0.046, z: 0.838, v: 'sparse' },
            { x: 0.038, z: 0.772, v: 'bare' },
            { x: 0.093, z: 0.835, v: 'scraggly' },
            { x: 0.056, z: 0.878, v: 'sparse' },
            { x: 0.023, z: 0.851, v: 'scraggly' },
            { x: 0.133, z: 0.858, v: 'scraggly' },
            { x: 0.069, z: 0.757, v: 'bare' },
            { x: 0.028, z: 0.826, v: 'sparse' },
            { x: 0.021, z: 0.717, v: 'scraggly' },
            { x: 0.69, z: 0.186, v: 'dry' },
            { x: 0.741, z: 0.27, v: 'bare' },
            { x: 0.578, z: 0.225, v: 'bare' },
            { x: 0.69, z: 0.253, v: 'scraggly' },
            { x: 0.699, z: 0.244, v: 'scraggly' },
            { x: 0.767, z: 0.18, v: 'scraggly' },
            { x: 0.707, z: 0.257, v: 'scraggly' },
            { x: 0.513, z: 0.263, v: 'bare' },
            { x: 0.504, z: 0.183, v: 'sparse' },
            { x: 0.604, z: 0.283, v: 'sparse' },
            { x: 0.523, z: 0.235, v: 'bare' },
            { x: 0.484, z: 0.229, v: 'dry' },
            { x: 0.47, z: 0.313, v: 'bare' },
            { x: 0.578, z: 0.242, v: 'dry' },
            { x: 0.487, z: 0.279, v: 'dry' },
            { x: 0.527, z: 0.38, v: 'sparse' },
            { x: 0.515, z: 0.383, v: 'bare' },
            { x: 0.512, z: 0.339, v: 'bare' },
            { x: 0.915, z: 0.501, v: 'scraggly' },
            { x: 0.936, z: 0.441, v: 'scraggly' },
            { x: 0.966, z: 0.542, v: 'sparse' },
            { x: 0.903, z: 0.431, v: 'bare' },
            { x: 0.745, z: 0.113, v: 'dry' },
            { x: 0.717, z: 0.115, v: 'bare' },
            { x: 0.702, z: 0.057, v: 'scraggly' },
            { x: 0.687, z: 0.153, v: 'sparse' },
            { x: 0.804, z: 0.125, v: 'scraggly' },
            { x: 0.719, z: 0.15, v: 'sparse' },
            { x: 0.596, z: 0.097, v: 'scraggly' },
            { x: 0.748, z: 0.069, v: 'dry' },
            { x: 0.629, z: 0.123, v: 'dry' },
            { x: 0.725, z: 0.124, v: 'bare' },
            { x: 0.791, z: 0.117, v: 'sparse' },
            { x: 0.695, z: 0.296, v: 'dry' },
            { x: 0.706, z: 0.393, v: 'sparse' },
            { x: 0.576, z: 0.316, v: 'sparse' },
            { x: 0.747, z: 0.336, v: 'bare' },
            { x: 0.659, z: 0.219, v: 'dry' },
            { x: 0.713, z: 0.281, v: 'sparse' }
          ],
          rocks: [
            { x: 0.808, z: 0.196, rotY: 3.4, scale: 0.6 },
            { x: 0.312, z: 0.5, rotY: 0, scale: 0.85 },
            { x: 0.677, z: 0.529, rotY: 2.2, scale: 0.63 },
            { x: 0.314, z: 0.634, rotY: 3.8, scale: 0.72 },
            { x: 0.291, z: 0.954, rotY: 2.9, scale: 0.96 },
            { x: 0.686, z: 0.199, rotY: 3.8, scale: 0.97 },
            { x: 0.498, z: 0.234, rotY: 2, scale: 0.62 },
            { x: 0.073, z: 0.649, rotY: 4.5, scale: 0.61 },
            { x: 0.827, z: 0.722, rotY: 0.1, scale: 0.82 },
            { x: 0.477, z: 0.739, rotY: 1.3, scale: 0.63 },
            { x: 0.691, z: 0.587, rotY: 2.4, scale: 0.73 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.548,
              z: 0.599,
              cubes: [
                { dx: 0.046, dz: 0.034, sx: 0.13, sy: 0.15, sz: 0.2, rotY: 1.1, rotZ: 0.19 },
                { dx: 0.041, dz: 0.016, sx: 0.3, sy: 0.26, sz: 0.22, rotY: 6.2, rotZ: -0.25 },
                { dx: -0.008, dz: -0.031, sx: 0.18, sy: 0.14, sz: 0.2, rotY: 2.8, rotZ: -0.14 },
                { dx: -0.016, dz: 0.054, sx: 0.31, sy: 0.23, sz: 0.2, rotY: 2, rotZ: 0.18 },
                { dx: -0.013, dz: -0.059, sx: 0.17, sy: 0.22, sz: 0.13, rotY: 0.4, rotZ: 0.18 },
                { dx: 0.038, dz: 0.034, sx: 0.3, sy: 0.28, sz: 0.23, rotY: 1.5, rotZ: 0.19 },
                { dx: 0.028, dz: 0.058, sx: 0.32, sy: 0.2, sz: 0.16, rotY: 5.1, rotZ: -0.2 },
                { dx: -0.024, dz: -0.044, sx: 0.15, sy: 0.2, sz: 0.2, rotY: 1.1, rotZ: 0.27 },
                { dx: -0.03, dz: 0.012, sx: 0.12, sy: 0.18, sz: 0.17, rotY: 1.8, rotZ: 0.19 },
                { dx: 0.025, dz: 0.049, sx: 0.15, sy: 0.2, sz: 0.16, rotY: 4.2, rotZ: -0.17 },
                { dx: -0.053, dz: -0.042, sx: 0.25, sy: 0.15, sz: 0.2, rotY: 2.5, rotZ: -0.24 },
                { dx: 0.01, dz: 0.029, sx: 0.28, sy: 0.14, sz: 0.11, rotY: 5, rotZ: 0.07 },
                { dx: -0.057, dz: 0.042, sx: 0.3, sy: 0.16, sz: 0.24, rotY: 5.2, rotZ: 0.26 },
                { dx: -0.042, dz: 0.001, sx: 0.13, sy: 0.16, sz: 0.13, rotY: 5.4, rotZ: -0.02 }
              ],
              colliders: [
                { dx: 0.031, dz: 0.037, r: 0.025 },
                { dx: -0.034, dz: 0.036, r: 0.0274 },
                { dx: -0.015, dz: -0.045, r: 0.0168 },
                { dx: -0.047, dz: -0.02, r: 0.0232 }
              ]
            },
            {
              material: 'crystal',
              x: 0.204,
              z: 0.49,
              cubes: [
                { dx: -0.035, dz: -0.019, sx: 0.16, sy: 0.26, sz: 0.15, rotY: 2.9, rotZ: 0.1 },
                { dx: -0.042, dz: 0.009, sx: 0.28, sy: 0.17, sz: 0.11, rotY: 3.9, rotZ: 0.26 },
                { dx: 0.033, dz: 0.046, sx: 0.24, sy: 0.27, sz: 0.2, rotY: 4, rotZ: -0.19 },
                { dx: -0.038, dz: -0.005, sx: 0.18, sy: 0.24, sz: 0.23, rotY: 3.9, rotZ: -0.17 },
                { dx: 0.016, dz: -0.058, sx: 0.14, sy: 0.24, sz: 0.11, rotY: 4.6, rotZ: 0.23 },
                { dx: -0.061, dz: 0.048, sx: 0.21, sy: 0.19, sz: 0.23, rotY: 0.4, rotZ: -0.06 },
                { dx: 0.03, dz: 0.031, sx: 0.28, sy: 0.21, sz: 0.14, rotY: 6.1, rotZ: 0.22 },
                { dx: 0.04, dz: -0.033, sx: 0.21, sy: 0.18, sz: 0.12, rotY: 4.5, rotZ: 0.17 },
                { dx: 0.024, dz: -0.013, sx: 0.3, sy: 0.25, sz: 0.11, rotY: 1, rotZ: -0.1 },
                { dx: 0.011, dz: 0.028, sx: 0.31, sy: 0.23, sz: 0.23, rotY: 2.2, rotZ: -0.03 },
                { dx: -0.004, dz: 0.011, sx: 0.32, sy: 0.19, sz: 0.11, rotY: 4.4, rotZ: -0.25 },
                { dx: -0.065, dz: 0.036, sx: 0.24, sy: 0.14, sz: 0.23, rotY: 4.9, rotZ: -0.19 }
              ],
              colliders: [
                { dx: -0.01, dz: -0.038, r: 0.0283 },
                { dx: -0.052, dz: 0.022, r: 0.0287 },
                { dx: 0.034, dz: 0.015, r: 0.0415 },
                { dx: 0.01, dz: 0.009, r: 0.0271 },
                { dx: -0.035, dz: -0.019, r: 0.0112 },
                { dx: -0.038, dz: -0.005, r: 0.0161 },
                { dx: 0.016, dz: -0.058, r: 0.0098 },
                { dx: 0.04, dz: -0.033, r: 0.0147 }
              ]
            },
            {
              material: 'crystal',
              x: 0.407,
              z: 0.238,
              cubes: [
                { dx: -0.05, dz: 0.034, sx: 0.23, sy: 0.2, sz: 0.16, rotY: 4.4, rotZ: 0.21 },
                { dx: -0.003, dz: 0.016, sx: 0.28, sy: 0.2, sz: 0.14, rotY: 3.7, rotZ: -0.03 },
                { dx: 0.046, dz: 0.043, sx: 0.1, sy: 0.21, sz: 0.13, rotY: 4.4, rotZ: -0.03 },
                { dx: -0.018, dz: -0.04, sx: 0.16, sy: 0.15, sz: 0.21, rotY: 3, rotZ: -0.23 },
                { dx: 0.021, dz: -0.051, sx: 0.24, sy: 0.14, sz: 0.14, rotY: 0.9, rotZ: 0.03 },
                { dx: -0.036, dz: 0.046, sx: 0.13, sy: 0.14, sz: 0.22, rotY: 3.4, rotZ: 0.26 },
                { dx: 0.025, dz: -0.05, sx: 0.21, sy: 0.26, sz: 0.15, rotY: 4.7, rotZ: 0.15 },
                { dx: -0.005, dz: -0.032, sx: 0.2, sy: 0.17, sz: 0.14, rotY: 3.6, rotZ: 0.09 },
                { dx: -0.047, dz: -0.05, sx: 0.16, sy: 0.27, sz: 0.16, rotY: 3.7, rotZ: 0.2 },
                { dx: -0.04, dz: 0.048, sx: 0.17, sy: 0.24, sz: 0.16, rotY: 3.5, rotZ: -0.02 },
                { dx: -0.022, dz: -0.004, sx: 0.14, sy: 0.21, sz: 0.17, rotY: 4.8, rotZ: 0.01 },
                { dx: 0.004, dz: 0.021, sx: 0.25, sy: 0.28, sz: 0.17, rotY: 1.7, rotZ: 0.08 },
                { dx: 0.022, dz: -0.061, sx: 0.12, sy: 0.2, sz: 0.12, rotY: 0.7, rotZ: 0.25 }
              ],
              colliders: [
                { dx: -0.042, dz: 0.043, r: 0.0149 },
                { dx: -0.023, dz: -0.031, r: 0.0269 },
                { dx: 0.023, dz: -0.054, r: 0.009 },
                { dx: 0.016, dz: 0.027, r: 0.0293 },
                { dx: 0.046, dz: 0.043, r: 0.0091 },
                { dx: -0.047, dz: -0.05, r: 0.0112 }
              ]
            },
            {
              material: 'crystal',
              x: 0.161,
              z: 0.271,
              cubes: [
                { dx: -0.026, dz: -0.038, sx: 0.13, sy: 0.14, sz: 0.22, rotY: 5.4, rotZ: -0.27 },
                { dx: -0.016, dz: -0.002, sx: 0.3, sy: 0.2, sz: 0.21, rotY: 4.1, rotZ: 0.08 },
                { dx: 0.049, dz: -0.033, sx: 0.17, sy: 0.16, sz: 0.17, rotY: 6.2, rotZ: -0.08 },
                { dx: 0.063, dz: 0.009, sx: 0.16, sy: 0.15, sz: 0.1, rotY: 6.2, rotZ: 0.1 },
                { dx: 0.064, dz: -0.044, sx: 0.16, sy: 0.18, sz: 0.15, rotY: 4.1, rotZ: 0.28 },
                { dx: 0.033, dz: 0.028, sx: 0.27, sy: 0.21, sz: 0.12, rotY: 0.3, rotZ: 0.06 },
                { dx: 0.008, dz: 0.025, sx: 0.28, sy: 0.15, sz: 0.13, rotY: 0.1, rotZ: -0.25 },
                { dx: -0.022, dz: 0.038, sx: 0.2, sy: 0.25, sz: 0.2, rotY: 0.7, rotZ: -0.08 },
                { dx: 0.055, dz: -0.04, sx: 0.23, sy: 0.21, sz: 0.18, rotY: 5.1, rotZ: -0.2 },
                { dx: -0.051, dz: -0.013, sx: 0.15, sy: 0.27, sz: 0.19, rotY: 3.7, rotZ: 0.18 },
                { dx: 0.004, dz: 0.015, sx: 0.1, sy: 0.21, sz: 0.19, rotY: 1.3, rotZ: -0.14 },
                { dx: 0.024, dz: 0.012, sx: 0.3, sy: 0.2, sz: 0.23, rotY: 5.7, rotZ: 0.15 },
                { dx: -0.042, dz: -0.005, sx: 0.15, sy: 0.15, sz: 0.2, rotY: 4.4, rotZ: -0.27 },
                { dx: -0.036, dz: 0.014, sx: 0.23, sy: 0.25, sz: 0.17, rotY: 5.8, rotZ: 0.16 },
                { dx: -0.048, dz: 0.009, sx: 0.3, sy: 0.14, sz: 0.24, rotY: 1.4, rotZ: 0.21 }
              ],
              colliders: [
                { dx: -0.034, dz: -0.014, r: 0.0243 },
                { dx: 0.058, dz: -0.027, r: 0.0315 },
                { dx: -0.035, dz: 0.02, r: 0.0219 },
                { dx: 0.017, dz: 0.02, r: 0.0203 },
                { dx: 0.063, dz: 0.009, r: 0.0112 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_3',
        seed: 301,
        terrain: {
          hills: [
            { x: 0.35, z: 0.32, radius: 0.35, height: 0.46 },
            { x: 0.64, z: 0.39, radius: 0.37, height: 0.56 },
            { x: 0.38, z: 0.37, radius: 0.29, height: 0.47 },
            { x: 0.62, z: 0.07, radius: 0.38, height: 0.5 },
            { x: 0.62, z: 0.03, radius: 0.38, height: 0.52 },
            { x: 0.04, z: 0.99, radius: 0.31, height: 0.4 },
            { x: 0.86, z: 0.6, radius: 0.35, height: 0.34 },
            { x: 0.4, z: 0.55, radius: 0.36, height: 0.5 },
            { x: 0.35, z: 0.81, radius: 0.29, height: 0.35 },
            { x: 0.92, z: 0.2, radius: 0.3, height: 0.65 },
            { x: 0.56, z: 0.26, radius: 0.36, height: 0.45 },
            { x: 0.45, z: 0.87, radius: 0.26, height: 0.32 }
          ]
        },
        items: {
          trees: [
            { x: 0.59, z: 0.436, v: 'scraggly' },
            { x: 0.664, z: 0.519, v: 'sparse' },
            { x: 0.685, z: 0.43, v: 'sparse' },
            { x: 0.629, z: 0.46, v: 'dry' },
            { x: 0.639, z: 0.592, v: 'bare' },
            { x: 0.599, z: 0.457, v: 'bare' },
            { x: 0.068, z: 0.803, v: 'sparse' },
            { x: 0.048, z: 0.8, v: 'dry' },
            { x: 0.074, z: 0.786, v: 'bare' },
            { x: 0.039, z: 0.785, v: 'bare' },
            { x: 0.034, z: 0.722, v: 'sparse' },
            { x: 0.067, z: 0.758, v: 'bare' },
            { x: 0.006, z: 0.794, v: 'sparse' },
            { x: 0.369, z: 0.401, v: 'bare' },
            { x: 0.408, z: 0.35, v: 'scraggly' },
            { x: 0.393, z: 0.341, v: 'scraggly' },
            { x: 0.427, z: 0.332, v: 'bare' },
            { x: 0.36, z: 0.341, v: 'bare' },
            { x: 0.474, z: 0.322, v: 'dry' },
            { x: 0.44, z: 0.863, v: 'scraggly' },
            { x: 0.455, z: 0.742, v: 'sparse' },
            { x: 0.43, z: 0.924, v: 'bare' },
            { x: 0.47, z: 0.909, v: 'dry' },
            { x: 0.506, z: 0.748, v: 'dry' },
            { x: 0.484, z: 0.845, v: 'scraggly' },
            { x: 0.458, z: 0.811, v: 'sparse' },
            { x: 0.267, z: 0.509, v: 'sparse' },
            { x: 0.305, z: 0.504, v: 'dry' },
            { x: 0.319, z: 0.517, v: 'dry' },
            { x: 0.273, z: 0.527, v: 'scraggly' },
            { x: 0.34, z: 0.536, v: 'sparse' },
            { x: 0.325, z: 0.49, v: 'dry' },
            { x: 0.317, z: 0.529, v: 'dry' },
            { x: 0.172, z: 0.087, v: 'scraggly' },
            { x: 0.152, z: 0.011, v: 'bare' },
            { x: 0.212, z: 0.027, v: 'bare' },
            { x: 0.224, z: 0.097, v: 'bare' },
            { x: 0.071, z: 0.049, v: 'sparse' },
            { x: 0.031, z: 0.019, v: 'bare' },
            { x: 0.104, z: 0.037, v: 'dry' },
            { x: 0.151, z: 0.024, v: 'dry' },
            { x: 0.135, z: 0.037, v: 'sparse' },
            { x: 0.173, z: 0.044, v: 'bare' },
            { x: 0.152, z: 0.057, v: 'bare' },
            { x: 0.531, z: 0.696, v: 'bare' },
            { x: 0.608, z: 0.648, v: 'dry' },
            { x: 0.586, z: 0.655, v: 'dry' },
            { x: 0.598, z: 0.675, v: 'dry' },
            { x: 0.635, z: 0.664, v: 'bare' },
            { x: 0.557, z: 0.643, v: 'bare' },
            { x: 0.612, z: 0.666, v: 'sparse' },
            { x: 0.817, z: 0.557, v: 'sparse' },
            { x: 0.787, z: 0.555, v: 'sparse' },
            { x: 0.769, z: 0.541, v: 'bare' },
            { x: 0.784, z: 0.526, v: 'sparse' },
            { x: 0.764, z: 0.529, v: 'sparse' },
            { x: 0.166, z: 0.87, v: 'dry' },
            { x: 0.214, z: 0.944, v: 'scraggly' },
            { x: 0.197, z: 0.769, v: 'bare' },
            { x: 0.165, z: 0.802, v: 'dry' },
            { x: 0.196, z: 0.784, v: 'sparse' },
            { x: 0.145, z: 0.886, v: 'bare' },
            { x: 0.229, z: 0.86, v: 'dry' },
            { x: 0.113, z: 0.86, v: 'dry' },
            { x: 0.589, z: 0.21, v: 'dry' },
            { x: 0.623, z: 0.167, v: 'dry' },
            { x: 0.606, z: 0.205, v: 'sparse' },
            { x: 0.63, z: 0.127, v: 'bare' },
            { x: 0.564, z: 0.259, v: 'sparse' },
            { x: 0.694, z: 0.146, v: 'sparse' },
            { x: 0.516, z: 0.15, v: 'dry' },
            { x: 0.478, z: 0.757, v: 'bare' },
            { x: 0.446, z: 0.712, v: 'bare' },
            { x: 0.475, z: 0.636, v: 'bare' },
            { x: 0.421, z: 0.764, v: 'bare' },
            { x: 0.44, z: 0.691, v: 'sparse' }
          ],
          rocks: [
            { x: 0.535, z: 0.809, rotY: 3.5, scale: 0.85 },
            { x: 0.56, z: 0.218, rotY: 0.9, scale: 0.65 },
            { x: 0.209, z: 0.521, rotY: 5.6, scale: 0.63 },
            { x: 0.181, z: 0.905, rotY: 3, scale: 0.78 },
            { x: 0.234, z: 0.048, rotY: 1.7, scale: 0.75 },
            { x: 0.658, z: 0.644, rotY: 1.1, scale: 0.71 },
            { x: 0.761, z: 0.932, rotY: 4.1, scale: 0.86 },
            { x: 0.381, z: 0.24, rotY: 0.2, scale: 0.91 },
            { x: 0.405, z: 0.371, rotY: 0.1, scale: 0.91 },
            { x: 0.979, z: 0.049, rotY: 3.8, scale: 0.89 },
            { x: 0.127, z: 0.795, rotY: 1.2, scale: 0.62 },
            { x: 0.703, z: 0.601, rotY: 1.3, scale: 0.86 },
            { x: 0.801, z: 0.199, rotY: 1.1, scale: 0.8 },
            { x: 0.039, z: 0.018, rotY: 4, scale: 0.76 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.212,
              z: 0.677,
              cubes: [
                { dx: -0.055, dz: 0.053, sx: 0.31, sy: 0.18, sz: 0.22, rotY: 5.2, rotZ: 0.06 },
                { dx: -0.029, dz: 0.059, sx: 0.12, sy: 0.23, sz: 0.11, rotY: 5.1, rotZ: 0.23 },
                { dx: 0.018, dz: -0.037, sx: 0.18, sy: 0.14, sz: 0.11, rotY: 2, rotZ: -0.01 },
                { dx: -0.036, dz: 0.033, sx: 0.24, sy: 0.14, sz: 0.18, rotY: 2, rotZ: 0.12 },
                { dx: -0.051, dz: -0.025, sx: 0.26, sy: 0.23, sz: 0.2, rotY: 2.1, rotZ: -0.24 },
                { dx: -0.021, dz: -0.012, sx: 0.24, sy: 0.16, sz: 0.15, rotY: 0.9, rotZ: -0.07 },
                { dx: -0.05, dz: -0.006, sx: 0.1, sy: 0.24, sz: 0.16, rotY: 0.5, rotZ: 0.05 },
                { dx: 0.022, dz: -0.024, sx: 0.23, sy: 0.12, sz: 0.14, rotY: 5.1, rotZ: 0.07 },
                { dx: -0.045, dz: 0.03, sx: 0.18, sy: 0.24, sz: 0.18, rotY: 4, rotZ: -0.18 },
                { dx: -0.022, dz: 0.051, sx: 0.1, sy: 0.27, sz: 0.15, rotY: 3, rotZ: -0.04 },
                { dx: 0.038, dz: 0.052, sx: 0.24, sy: 0.14, sz: 0.17, rotY: 6.1, rotZ: -0.23 },
                { dx: -0.055, dz: -0.054, sx: 0.3, sy: 0.12, sz: 0.22, rotY: 3.3, rotZ: 0.06 },
                { dx: 0.047, dz: 0.043, sx: 0.12, sy: 0.19, sz: 0.18, rotY: 0.2, rotZ: 0.03 },
                { dx: -0.001, dz: -0.016, sx: 0.28, sy: 0.18, sz: 0.12, rotY: 5.1, rotZ: -0.21 },
                { dx: 0.006, dz: 0.048, sx: 0.13, sy: 0.26, sz: 0.17, rotY: 2.8, rotZ: 0 }
              ],
              colliders: [
                { dx: -0.037, dz: 0.045, r: 0.0226 },
                { dx: 0.03, dz: 0.048, r: 0.0227 },
                { dx: 0.004, dz: -0.022, r: 0.0269 },
                { dx: -0.052, dz: -0.028, r: 0.0273 },
                { dx: 0.006, dz: 0.048, r: 0.0119 }
              ]
            },
            {
              material: 'crystal',
              x: 0.715,
              z: 0.809,
              cubes: [
                { dx: 0.018, dz: -0.063, sx: 0.13, sy: 0.19, sz: 0.21, rotY: 6.1, rotZ: -0.28 },
                { dx: 0.054, dz: -0.027, sx: 0.13, sy: 0.19, sz: 0.17, rotY: 4, rotZ: -0.13 },
                { dx: 0.004, dz: 0.048, sx: 0.23, sy: 0.12, sz: 0.18, rotY: 4.8, rotZ: -0.22 },
                { dx: 0.01, dz: 0.062, sx: 0.3, sy: 0.17, sz: 0.16, rotY: 1.6, rotZ: 0.12 },
                { dx: 0.048, dz: 0.057, sx: 0.32, sy: 0.14, sz: 0.18, rotY: 1.2, rotZ: 0.28 },
                { dx: 0.051, dz: 0.017, sx: 0.1, sy: 0.15, sz: 0.21, rotY: 1.9, rotZ: 0 },
                { dx: -0.056, dz: -0.032, sx: 0.27, sy: 0.19, sz: 0.18, rotY: 1.5, rotZ: -0.01 },
                { dx: 0.036, dz: 0.055, sx: 0.24, sy: 0.28, sz: 0.24, rotY: 3.1, rotZ: 0.01 },
                { dx: 0.01, dz: 0.032, sx: 0.13, sy: 0.2, sz: 0.22, rotY: 3.1, rotZ: -0.2 }
              ],
              colliders: [
                { dx: 0.036, dz: -0.045, r: 0.0246 },
                { dx: 0.008, dz: 0.047, r: 0.019 },
                { dx: 0.045, dz: 0.043, r: 0.0255 },
                { dx: -0.056, dz: -0.032, r: 0.0189 },
                { dx: 0.051, dz: 0.017, r: 0.0147 }
              ]
            },
            {
              material: 'crystal',
              x: 0.63,
              z: 0.093,
              cubes: [
                { dx: 0.027, dz: 0.023, sx: 0.24, sy: 0.18, sz: 0.19, rotY: 1.2, rotZ: 0.04 },
                { dx: -0.019, dz: -0.014, sx: 0.26, sy: 0.21, sz: 0.14, rotY: 3.4, rotZ: -0.18 },
                { dx: -0.014, dz: 0.011, sx: 0.14, sy: 0.22, sz: 0.17, rotY: 2.9, rotZ: -0.07 },
                { dx: -0.038, dz: 0.031, sx: 0.24, sy: 0.22, sz: 0.16, rotY: 2.3, rotZ: -0.12 },
                { dx: -0.02, dz: 0.059, sx: 0.18, sy: 0.25, sz: 0.2, rotY: 2.4, rotZ: -0.26 },
                { dx: 0.026, dz: 0.053, sx: 0.18, sy: 0.27, sz: 0.16, rotY: 5.2, rotZ: 0.01 },
                { dx: -0.046, dz: 0.055, sx: 0.23, sy: 0.23, sz: 0.23, rotY: 0.9, rotZ: 0.18 },
                { dx: 0.002, dz: 0.005, sx: 0.19, sy: 0.26, sz: 0.14, rotY: 6.1, rotZ: -0.2 },
                { dx: -0.023, dz: -0.055, sx: 0.16, sy: 0.28, sz: 0.14, rotY: 0.3, rotZ: -0.16 }
              ],
              colliders: [
                { dx: 0.027, dz: 0.038, r: 0.0176 },
                { dx: -0.013, dz: -0.013, r: 0.0363 },
                { dx: -0.02, dz: 0.059, r: 0.014 },
                { dx: -0.042, dz: 0.043, r: 0.0158 },
                { dx: -0.023, dz: -0.055, r: 0.0112 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_4',
        seed: 401,
        terrain: {
          hills: [
            { x: 0.68, z: 0.9, radius: 0.35, height: 0.33 },
            { x: 0.96, z: 0.41, radius: 0.36, height: 0.52 },
            { x: 0.1, z: 0.37, radius: 0.22, height: 0.42 },
            { x: 0.62, z: 0.14, radius: 0.2, height: 0.7 },
            { x: 0.59, z: 0.02, radius: 0.18, height: 0.44 },
            { x: 1, z: 0.55, radius: 0.2, height: 0.33 },
            { x: 0.06, z: 0.28, radius: 0.18, height: 0.6 },
            { x: 0.95, z: 0.54, radius: 0.37, height: 0.38 },
            { x: 0.26, z: 0.32, radius: 0.25, height: 0.65 },
            { x: 0.96, z: 0.25, radius: 0.33, height: 0.66 },
            { x: 0.51, z: 0.76, radius: 0.3, height: 0.27 },
            { x: 0.3, z: 0.38, radius: 0.28, height: 0.43 }
          ]
        },
        items: {
          trees: [
            { x: 0.065, z: 0.969, v: 'dry' },
            { x: 0.05, z: 0.952, v: 'bare' },
            { x: 0.109, z: 0.863, v: 'sparse' },
            { x: 0.037, z: 0.972, v: 'scraggly' },
            { x: 0.063, z: 0.948, v: 'dry' },
            { x: 0.042, z: 0.928, v: 'sparse' },
            { x: 0.143, z: 0.924, v: 'sparse' },
            { x: 0.628, z: 0.96, v: 'bare' },
            { x: 0.621, z: 0.919, v: 'dry' },
            { x: 0.612, z: 0.89, v: 'scraggly' },
            { x: 0.597, z: 0.982, v: 'sparse' },
            { x: 0.655, z: 0.86, v: 'sparse' },
            { x: 0.623, z: 0.977, v: 'sparse' },
            { x: 0.583, z: 0.908, v: 'bare' },
            { x: 0.675, z: 0.954, v: 'bare' },
            { x: 0.844, z: 0.585, v: 'sparse' },
            { x: 0.844, z: 0.459, v: 'sparse' },
            { x: 0.756, z: 0.534, v: 'scraggly' },
            { x: 0.855, z: 0.573, v: 'sparse' },
            { x: 0.925, z: 0.583, v: 'sparse' },
            { x: 0.776, z: 0.606, v: 'dry' },
            { x: 0.818, z: 0.471, v: 'sparse' },
            { x: 0.939, z: 0.617, v: 'dry' },
            { x: 0.777, z: 0.633, v: 'sparse' },
            { x: 0.784, z: 0.32, v: 'scraggly' },
            { x: 0.825, z: 0.361, v: 'bare' },
            { x: 0.748, z: 0.387, v: 'scraggly' },
            { x: 0.754, z: 0.291, v: 'bare' },
            { x: 0.679, z: 0.317, v: 'scraggly' },
            { x: 0.805, z: 0.278, v: 'sparse' },
            { x: 0.848, z: 0.278, v: 'bare' },
            { x: 0.852, z: 0.376, v: 'dry' },
            { x: 0.861, z: 0.301, v: 'sparse' },
            { x: 0.755, z: 0.352, v: 'bare' },
            { x: 0.794, z: 0.664, v: 'scraggly' },
            { x: 0.717, z: 0.666, v: 'scraggly' },
            { x: 0.74, z: 0.586, v: 'scraggly' },
            { x: 0.735, z: 0.691, v: 'bare' },
            { x: 0.766, z: 0.598, v: 'sparse' },
            { x: 0.81, z: 0.551, v: 'scraggly' },
            { x: 0.772, z: 0.581, v: 'scraggly' },
            { x: 0.706, z: 0.49, v: 'dry' },
            { x: 0.783, z: 0.542, v: 'sparse' },
            { x: 0.761, z: 0.57, v: 'sparse' },
            { x: 0.079, z: 0.976, v: 'dry' },
            { x: 0.014, z: 0.952, v: 'scraggly' },
            { x: 0.079, z: 0.99, v: 'dry' },
            { x: 0.099, z: 0.94, v: 'bare' },
            { x: 0.085, z: 0.943, v: 'scraggly' },
            { x: 0.111, z: 0.923, v: 'bare' },
            { x: 0.011, z: 0.936, v: 'sparse' },
            { x: 0.022, z: 0.922, v: 'bare' },
            { x: 0.026, z: 0.908, v: 'scraggly' },
            { x: 0.056, z: 0.906, v: 'bare' },
            { x: 0.029, z: 0.849, v: 'scraggly' },
            { x: 0.288, z: 0.206, v: 'dry' },
            { x: 0.312, z: 0.36, v: 'sparse' },
            { x: 0.315, z: 0.292, v: 'scraggly' },
            { x: 0.381, z: 0.289, v: 'dry' },
            { x: 0.341, z: 0.269, v: 'sparse' },
            { x: 0.422, z: 0.289, v: 'bare' },
            { x: 0.397, z: 0.785, v: 'sparse' },
            { x: 0.411, z: 0.771, v: 'sparse' },
            { x: 0.407, z: 0.654, v: 'dry' },
            { x: 0.358, z: 0.788, v: 'dry' },
            { x: 0.655, z: 0.091, v: 'scraggly' },
            { x: 0.601, z: 0.175, v: 'scraggly' },
            { x: 0.712, z: 0.164, v: 'bare' },
            { x: 0.712, z: 0.089, v: 'sparse' },
            { x: 0.651, z: 0.132, v: 'sparse' },
            { x: 0.711, z: 0.143, v: 'scraggly' },
            { x: 0.741, z: 0.045, v: 'scraggly' },
            { x: 0.729, z: 0.034, v: 'dry' },
            { x: 0.679, z: 0.119, v: 'scraggly' },
            { x: 0.589, z: 0.1, v: 'dry' },
            { x: 0.665, z: 0.107, v: 'sparse' }
          ],
          rocks: [
            { x: 0.472, z: 0.591, rotY: 0.8, scale: 0.87 },
            { x: 0.112, z: 0.673, rotY: 5.4, scale: 0.72 },
            { x: 0.908, z: 0.083, rotY: 3.2, scale: 0.74 },
            { x: 0.457, z: 0.231, rotY: 2.3, scale: 0.72 },
            { x: 0.144, z: 0.458, rotY: 0.2, scale: 0.98 },
            { x: 0.569, z: 0.513, rotY: 2.1, scale: 0.99 },
            { x: 0.569, z: 0.638, rotY: 3, scale: 0.69 },
            { x: 0.226, z: 0.81, rotY: 6, scale: 0.93 },
            { x: 0.789, z: 0.53, rotY: 5.3, scale: 0.92 },
            { x: 0.739, z: 0.802, rotY: 0.5, scale: 0.82 },
            { x: 0.905, z: 0.267, rotY: 4, scale: 0.82 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.437,
              z: 0.745,
              cubes: [
                { dx: 0.007, dz: 0.001, sx: 0.21, sy: 0.24, sz: 0.24, rotY: 0.8, rotZ: 0.03 },
                { dx: -0.029, dz: 0.007, sx: 0.19, sy: 0.25, sz: 0.12, rotY: 2.7, rotZ: 0.13 },
                { dx: -0.032, dz: 0.022, sx: 0.27, sy: 0.14, sz: 0.21, rotY: 1.9, rotZ: 0.18 },
                { dx: 0.016, dz: 0.029, sx: 0.3, sy: 0.12, sz: 0.17, rotY: 0.7, rotZ: -0.03 },
                { dx: -0.039, dz: 0.052, sx: 0.16, sy: 0.18, sz: 0.11, rotY: 0.9, rotZ: 0.15 },
                { dx: 0.046, dz: 0.051, sx: 0.28, sy: 0.21, sz: 0.23, rotY: 3.4, rotZ: 0.24 },
                { dx: 0.001, dz: 0.056, sx: 0.31, sy: 0.25, sz: 0.23, rotY: 5.2, rotZ: -0.1 },
                { dx: 0.062, dz: -0.009, sx: 0.21, sy: 0.18, sz: 0.1, rotY: 5.2, rotZ: 0.17 },
                { dx: -0.043, dz: -0.028, sx: 0.3, sy: 0.15, sz: 0.15, rotY: 3.4, rotZ: 0.09 },
                { dx: -0.058, dz: 0.057, sx: 0.3, sy: 0.25, sz: 0.18, rotY: 0.2, rotZ: -0.24 },
                { dx: -0.052, dz: 0.005, sx: 0.22, sy: 0.23, sz: 0.14, rotY: 5.6, rotZ: -0.18 },
                { dx: -0.044, dz: -0.013, sx: 0.12, sy: 0.28, sz: 0.17, rotY: 1.8, rotZ: -0.03 },
                { dx: 0.048, dz: -0.059, sx: 0.16, sy: 0.24, sz: 0.22, rotY: 1.9, rotZ: -0.22 },
                { dx: -0.053, dz: 0.033, sx: 0.12, sy: 0.12, sz: 0.12, rotY: 5.3, rotZ: -0.09 }
              ],
              colliders: [
                { dx: 0.007, dz: 0.001, r: 0.0168 },
                { dx: 0.021, dz: 0.045, r: 0.0266 },
                { dx: 0.055, dz: -0.034, r: 0.0252 },
                { dx: -0.044, dz: 0.017, r: 0.0415 },
                { dx: -0.043, dz: -0.028, r: 0.021 }
              ]
            },
            {
              material: 'crystal',
              x: 0.676,
              z: 0.878,
              cubes: [
                { dx: 0.016, dz: 0.04, sx: 0.26, sy: 0.17, sz: 0.13, rotY: 3.8, rotZ: -0.23 },
                { dx: -0.047, dz: 0.02, sx: 0.23, sy: 0.21, sz: 0.11, rotY: 2.9, rotZ: 0.24 },
                { dx: -0.037, dz: -0.046, sx: 0.27, sy: 0.27, sz: 0.17, rotY: 2.6, rotZ: 0.06 },
                { dx: -0.063, dz: 0.008, sx: 0.26, sy: 0.25, sz: 0.19, rotY: 0.1, rotZ: -0.24 },
                { dx: 0.056, dz: 0.065, sx: 0.26, sy: 0.25, sz: 0.14, rotY: 1.2, rotZ: 0.18 },
                { dx: -0.008, dz: 0.012, sx: 0.1, sy: 0.22, sz: 0.11, rotY: 4.3, rotZ: 0.12 },
                { dx: 0.004, dz: -0.04, sx: 0.21, sy: 0.2, sz: 0.17, rotY: 5.1, rotZ: -0.11 },
                { dx: -0.004, dz: -0.007, sx: 0.17, sy: 0.22, sz: 0.23, rotY: 5.7, rotZ: 0.19 },
                { dx: 0.046, dz: -0.028, sx: 0.2, sy: 0.16, sz: 0.1, rotY: 5.4, rotZ: -0.27 }
              ],
              colliders: [
                { dx: -0.013, dz: 0.024, r: 0.0317 },
                { dx: -0.05, dz: -0.019, r: 0.0296 },
                { dx: 0.056, dz: 0.065, r: 0.0182 },
                { dx: 0.015, dz: -0.025, r: 0.0284 },
                { dx: 0.016, dz: 0.04, r: 0.0182 },
                { dx: -0.047, dz: 0.02, r: 0.0161 },
                { dx: 0.046, dz: -0.028, r: 0.014 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_5',
        seed: 501,
        terrain: {
          hills: [
            { x: 0.01, z: 0.53, radius: 0.34, height: 0.31 },
            { x: 0.28, z: 0.19, radius: 0.35, height: 0.47 },
            { x: 0.81, z: 0.9, radius: 0.36, height: 0.23 },
            { x: 0.63, z: 0.2, radius: 0.24, height: 0.59 },
            { x: 0.55, z: 0.01, radius: 0.21, height: 0.66 },
            { x: 0.96, z: 0.51, radius: 0.3, height: 0.42 },
            { x: 0.26, z: 0.17, radius: 0.23, height: 0.58 },
            { x: 0.5, z: 0.9, radius: 0.37, height: 0.14 },
            { x: 0.17, z: 0.62, radius: 0.2, height: 0.38 },
            { x: 1, z: 0.3, radius: 0.37, height: 0.67 },
            { x: 0.47, z: 0.05, radius: 0.24, height: 0.66 },
            { x: 0.15, z: 0.1, radius: 0.29, height: 0.55 }
          ]
        },
        items: {
          trees: [
            { x: 0.388, z: 0.354, v: 'bare' },
            { x: 0.508, z: 0.391, v: 'dry' },
            { x: 0.452, z: 0.424, v: 'bare' },
            { x: 0.389, z: 0.403, v: 'bare' },
            { x: 0.466, z: 0.414, v: 'dry' },
            { x: 0.355, z: 0.414, v: 'bare' },
            { x: 0.508, z: 0.523, v: 'sparse' },
            { x: 0.475, z: 0.428, v: 'dry' },
            { x: 0.814, z: 0.021, v: 'scraggly' },
            { x: 0.885, z: 0.054, v: 'bare' },
            { x: 0.798, z: 0.03, v: 'sparse' },
            { x: 0.806, z: 0.007, v: 'scraggly' },
            { x: 0.81, z: 0.033, v: 'sparse' },
            { x: 0.739, z: 0.025, v: 'sparse' },
            { x: 0.02, z: 0.899, v: 'dry' },
            { x: 0.082, z: 0.854, v: 'sparse' },
            { x: 0.098, z: 0.796, v: 'bare' },
            { x: 0.006, z: 0.886, v: 'bare' },
            { x: 0.049, z: 0.902, v: 'sparse' },
            { x: 0.046, z: 0.951, v: 'bare' },
            { x: 0.082, z: 0.943, v: 'sparse' },
            { x: 0.023, z: 0.872, v: 'bare' },
            { x: 0.02, z: 0.817, v: 'dry' },
            { x: 0.123, z: 0.895, v: 'scraggly' },
            { x: 0.083, z: 0.903, v: 'dry' },
            { x: 0.885, z: 0.567, v: 'dry' },
            { x: 0.822, z: 0.632, v: 'sparse' },
            { x: 0.907, z: 0.651, v: 'sparse' },
            { x: 0.865, z: 0.494, v: 'dry' },
            { x: 0.838, z: 0.63, v: 'scraggly' },
            { x: 0.949, z: 0.627, v: 'bare' },
            { x: 0.966, z: 0.574, v: 'scraggly' },
            { x: 0.834, z: 0.48, v: 'dry' },
            { x: 0.806, z: 0.624, v: 'scraggly' },
            { x: 0.917, z: 0.514, v: 'sparse' },
            { x: 0.008, z: 0.991, v: 'sparse' },
            { x: 0.09, z: 0.97, v: 'bare' },
            { x: 0.044, z: 0.987, v: 'scraggly' },
            { x: 0.12, z: 0.923, v: 'sparse' },
            { x: 0.012, z: 0.972, v: 'bare' },
            { x: 0.083, z: 0.983, v: 'dry' },
            { x: 0.124, z: 0.987, v: 'bare' },
            { x: 0.022, z: 0.959, v: 'bare' },
            { x: 0.46, z: 0.869, v: 'bare' },
            { x: 0.419, z: 0.961, v: 'sparse' },
            { x: 0.478, z: 0.966, v: 'scraggly' },
            { x: 0.431, z: 0.942, v: 'dry' },
            { x: 0.435, z: 0.977, v: 'sparse' },
            { x: 0.426, z: 0.894, v: 'sparse' },
            { x: 0.445, z: 0.857, v: 'dry' },
            { x: 0.269, z: 0.144, v: 'bare' },
            { x: 0.251, z: 0.043, v: 'dry' },
            { x: 0.168, z: 0.038, v: 'bare' },
            { x: 0.273, z: 0.055, v: 'scraggly' },
            { x: 0.262, z: 0.024, v: 'sparse' },
            { x: 0.365, z: 0.052, v: 'dry' },
            { x: 0.369, z: 0.109, v: 'sparse' },
            { x: 0.308, z: 0.044, v: 'scraggly' },
            { x: 0.262, z: 0.065, v: 'scraggly' },
            { x: 0.263, z: 0.938, v: 'dry' },
            { x: 0.274, z: 0.92, v: 'sparse' },
            { x: 0.258, z: 0.953, v: 'scraggly' },
            { x: 0.23, z: 0.915, v: 'scraggly' },
            { x: 0.217, z: 0.855, v: 'bare' },
            { x: 0.654, z: 0.499, v: 'dry' },
            { x: 0.684, z: 0.488, v: 'dry' },
            { x: 0.659, z: 0.473, v: 'bare' },
            { x: 0.75, z: 0.473, v: 'sparse' },
            { x: 0.738, z: 0.455, v: 'sparse' },
            { x: 0.665, z: 0.559, v: 'scraggly' },
            { x: 0.707, z: 0.507, v: 'dry' },
            { x: 0.666, z: 0.575, v: 'dry' },
            { x: 0.779, z: 0.426, v: 'dry' },
            { x: 0.435, z: 0.059, v: 'dry' },
            { x: 0.452, z: 0.267, v: 'bare' },
            { x: 0.379, z: 0.212, v: 'dry' }
          ],
          rocks: [
            { x: 0.093, z: 0.094, rotY: 6.2, scale: 0.7 },
            { x: 0.609, z: 0.567, rotY: 2.3, scale: 0.99 },
            { x: 0.946, z: 0.782, rotY: 2, scale: 0.9 },
            { x: 0.219, z: 0.896, rotY: 3.4, scale: 0.79 },
            { x: 0.125, z: 0.026, rotY: 2, scale: 0.98 },
            { x: 0.475, z: 0.241, rotY: 1.7, scale: 0.79 },
            { x: 0.581, z: 0.653, rotY: 6, scale: 0.8 },
            { x: 0.726, z: 0.471, rotY: 3.1, scale: 0.99 },
            { x: 0.528, z: 0.189, rotY: 2.9, scale: 0.68 },
            { x: 0.552, z: 0.101, rotY: 4.4, scale: 0.78 },
            { x: 0.237, z: 0.714, rotY: 0.2, scale: 0.95 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.256,
              z: 0.259,
              cubes: [
                { dx: -0.029, dz: 0.063, sx: 0.31, sy: 0.22, sz: 0.1, rotY: 4.7, rotZ: 0 },
                { dx: -0.005, dz: -0.006, sx: 0.21, sy: 0.21, sz: 0.23, rotY: 1.4, rotZ: 0.03 },
                { dx: 0.028, dz: 0.043, sx: 0.24, sy: 0.15, sz: 0.12, rotY: 1.7, rotZ: -0.17 },
                { dx: -0.064, dz: 0.061, sx: 0.11, sy: 0.22, sz: 0.19, rotY: 5.4, rotZ: 0.14 },
                { dx: 0.05, dz: 0.018, sx: 0.18, sy: 0.19, sz: 0.12, rotY: 3.3, rotZ: 0.26 },
                { dx: 0.058, dz: 0.026, sx: 0.21, sy: 0.25, sz: 0.17, rotY: 4.2, rotZ: -0.08 },
                { dx: -0.001, dz: -0.034, sx: 0.17, sy: 0.16, sz: 0.15, rotY: 3.5, rotZ: 0.15 },
                { dx: 0.016, dz: -0.064, sx: 0.2, sy: 0.21, sz: 0.15, rotY: 1.4, rotZ: 0.14 },
                { dx: 0.06, dz: -0.037, sx: 0.12, sy: 0.25, sz: 0.13, rotY: 4.2, rotZ: -0.28 },
                { dx: -0.009, dz: -0.051, sx: 0.1, sy: 0.16, sz: 0.11, rotY: 1.5, rotZ: -0.16 },
                { dx: -0.057, dz: 0.036, sx: 0.22, sy: 0.14, sz: 0.21, rotY: 0.4, rotZ: -0.06 }
              ],
              colliders: [
                { dx: -0.05, dz: 0.053, r: 0.0255 },
                { dx: 0.012, dz: 0.019, r: 0.0285 },
                { dx: 0.054, dz: 0.022, r: 0.0098 },
                { dx: 0.017, dz: -0.046, r: 0.0368 },
                { dx: -0.005, dz: -0.006, r: 0.0161 },
                { dx: 0.06, dz: -0.037, r: 0.0091 }
              ]
            },
            {
              material: 'crystal',
              x: 0.514,
              z: 0.858,
              cubes: [
                { dx: -0.017, dz: 0.046, sx: 0.2, sy: 0.23, sz: 0.2, rotY: 5.6, rotZ: 0.04 },
                { dx: -0.047, dz: -0.063, sx: 0.3, sy: 0.24, sz: 0.24, rotY: 3.4, rotZ: 0 },
                { dx: -0.063, dz: 0.015, sx: 0.2, sy: 0.24, sz: 0.2, rotY: 3.3, rotZ: 0.07 },
                { dx: -0.038, dz: 0.039, sx: 0.13, sy: 0.25, sz: 0.15, rotY: 5.6, rotZ: -0.1 },
                { dx: 0.011, dz: -0.03, sx: 0.26, sy: 0.18, sz: 0.24, rotY: 3.2, rotZ: 0.24 },
                { dx: 0.059, dz: -0.048, sx: 0.29, sy: 0.16, sz: 0.13, rotY: 0.6, rotZ: 0.22 },
                { dx: -0.033, dz: 0.048, sx: 0.22, sy: 0.16, sz: 0.2, rotY: 2.7, rotZ: -0.06 },
                { dx: -0.049, dz: 0.025, sx: 0.14, sy: 0.15, sz: 0.12, rotY: 2.9, rotZ: -0.22 },
                { dx: 0.046, dz: -0.007, sx: 0.23, sy: 0.24, sz: 0.21, rotY: 2.4, rotZ: -0.04 },
                { dx: 0.039, dz: -0.058, sx: 0.19, sy: 0.2, sz: 0.17, rotY: 2.5, rotZ: 0.21 },
                { dx: -0.005, dz: -0.008, sx: 0.11, sy: 0.15, sz: 0.11, rotY: 5.6, rotZ: 0.18 },
                { dx: -0.062, dz: 0.027, sx: 0.18, sy: 0.16, sz: 0.22, rotY: 2.6, rotZ: -0.1 },
                { dx: -0.017, dz: -0.046, sx: 0.19, sy: 0.24, sz: 0.17, rotY: 2.7, rotZ: 0.13 }
              ],
              colliders: [
                { dx: -0.005, dz: -0.008, r: 0.0077 },
                { dx: -0.058, dz: 0.022, r: 0.0119 },
                { dx: -0.029, dz: 0.044, r: 0.0146 },
                { dx: 0.015, dz: -0.042, r: 0.0571 },
                { dx: -0.047, dz: -0.063, r: 0.021 }
              ]
            },
            {
              material: 'crystal',
              x: 0.11,
              z: 0.624,
              cubes: [
                { dx: -0.036, dz: -0.034, sx: 0.14, sy: 0.21, sz: 0.21, rotY: 5.6, rotZ: -0.02 },
                { dx: -0.05, dz: -0.042, sx: 0.32, sy: 0.15, sz: 0.15, rotY: 6.1, rotZ: -0.11 },
                { dx: 0.017, dz: 0.047, sx: 0.13, sy: 0.28, sz: 0.13, rotY: 5.3, rotZ: 0.05 },
                { dx: -0.016, dz: -0.06, sx: 0.29, sy: 0.26, sz: 0.2, rotY: 0.4, rotZ: -0.27 },
                { dx: -0.03, dz: -0.002, sx: 0.24, sy: 0.27, sz: 0.19, rotY: 0.3, rotZ: 0.19 },
                { dx: -0.039, dz: -0.044, sx: 0.13, sy: 0.2, sz: 0.12, rotY: 2.2, rotZ: 0.01 },
                { dx: -0.018, dz: 0.041, sx: 0.24, sy: 0.15, sz: 0.11, rotY: 4.9, rotZ: -0.04 },
                { dx: 0.057, dz: 0.022, sx: 0.12, sy: 0.22, sz: 0.13, rotY: 1.6, rotZ: -0.12 },
                { dx: 0.055, dz: -0.035, sx: 0.2, sy: 0.22, sz: 0.14, rotY: 2.5, rotZ: 0.22 },
                { dx: 0.045, dz: -0.002, sx: 0.24, sy: 0.22, sz: 0.2, rotY: 3.7, rotZ: 0.01 },
                { dx: 0.056, dz: 0.06, sx: 0.27, sy: 0.17, sz: 0.24, rotY: 3.3, rotZ: -0.23 },
                { dx: 0.002, dz: 0.05, sx: 0.26, sy: 0.19, sz: 0.23, rotY: 5.6, rotZ: 0.24 },
                { dx: 0.01, dz: -0.052, sx: 0.17, sy: 0.27, sz: 0.19, rotY: 0.5, rotZ: -0.28 }
              ],
              colliders: [
                { dx: -0.039, dz: -0.031, r: 0.0287 },
                { dx: -0.003, dz: -0.056, r: 0.0178 },
                { dx: 0, dz: 0.046, r: 0.0206 },
                { dx: 0.053, dz: 0.011, r: 0.0437 },
                { dx: -0.03, dz: -0.002, r: 0.0168 },
                { dx: 0.055, dz: -0.035, r: 0.014 },
                { dx: 0.056, dz: 0.06, r: 0.0189 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_6',
        seed: 601,
        terrain: {
          hills: [
            { x: 0.34, z: 0.27, radius: 0.34, height: 0.6 },
            { x: 0.61, z: 0.54, radius: 0.34, height: 0.43 },
            { x: 0.52, z: 0.49, radius: 0.29, height: 0.46 },
            { x: 0.64, z: 0.26, radius: 0.28, height: 0.49 },
            { x: 0.51, z: 0.6, radius: 0.23, height: 0.3 },
            { x: 0.91, z: 0.19, radius: 0.19, height: 0.67 },
            { x: 0.46, z: 0.38, radius: 0.28, height: 0.4 },
            { x: 0.05, z: 0.89, radius: 0.37, height: 0.33 },
            { x: 0.09, z: 0.13, radius: 0.38, height: 0.68 },
            { x: 0.03, z: 0.35, radius: 0.18, height: 0.68 },
            { x: 0.42, z: 0.95, radius: 0.39, height: 0.18 },
            { x: 1, z: 0.21, radius: 0.31, height: 0.67 },
            { x: 0.84, z: 0.96, radius: 0.33, height: 0.16 }
          ]
        },
        items: {
          trees: [
            { x: 0.121, z: 0.281, v: 'sparse' },
            { x: 0.083, z: 0.335, v: 'scraggly' },
            { x: 0.064, z: 0.349, v: 'dry' },
            { x: 0.024, z: 0.38, v: 'bare' },
            { x: 0.663, z: 0.541, v: 'bare' },
            { x: 0.594, z: 0.511, v: 'bare' },
            { x: 0.547, z: 0.625, v: 'bare' },
            { x: 0.546, z: 0.457, v: 'dry' },
            { x: 0.675, z: 0.452, v: 'scraggly' },
            { x: 0.714, z: 0.36, v: 'bare' },
            { x: 0.825, z: 0.348, v: 'sparse' },
            { x: 0.76, z: 0.39, v: 'dry' },
            { x: 0.792, z: 0.397, v: 'sparse' },
            { x: 0.823, z: 0.025, v: 'dry' },
            { x: 0.837, z: 0.103, v: 'dry' },
            { x: 0.88, z: 0.068, v: 'scraggly' },
            { x: 0.9, z: 0.123, v: 'dry' },
            { x: 0.758, z: 0.062, v: 'bare' },
            { x: 0.861, z: 0.093, v: 'scraggly' },
            { x: 0.909, z: 0.096, v: 'bare' },
            { x: 0.82, z: 0.123, v: 'scraggly' },
            { x: 0.859, z: 0.038, v: 'scraggly' },
            { x: 0.815, z: 0.037, v: 'bare' },
            { x: 0.545, z: 0.368, v: 'bare' },
            { x: 0.52, z: 0.387, v: 'scraggly' },
            { x: 0.448, z: 0.402, v: 'dry' },
            { x: 0.638, z: 0.413, v: 'scraggly' },
            { x: 0.734, z: 0.769, v: 'bare' },
            { x: 0.733, z: 0.84, v: 'scraggly' },
            { x: 0.711, z: 0.766, v: 'bare' },
            { x: 0.629, z: 0.708, v: 'sparse' },
            { x: 0.643, z: 0.756, v: 'scraggly' },
            { x: 0.713, z: 0.798, v: 'dry' },
            { x: 0.746, z: 0.847, v: 'dry' },
            { x: 0.735, z: 0.853, v: 'dry' },
            { x: 0.136, z: 0.863, v: 'sparse' },
            { x: 0.053, z: 0.845, v: 'bare' },
            { x: 0.027, z: 0.88, v: 'dry' },
            { x: 0.033, z: 0.817, v: 'dry' },
            { x: 0.098, z: 0.717, v: 'scraggly' },
            { x: 0.15, z: 0.769, v: 'sparse' },
            { x: 0.069, z: 0.798, v: 'dry' },
            { x: 0.007, z: 0.811, v: 'sparse' },
            { x: 0.055, z: 0.824, v: 'sparse' },
            { x: 0.07, z: 0.774, v: 'dry' },
            { x: 0.765, z: 0.148, v: 'dry' },
            { x: 0.7, z: 0.16, v: 'bare' },
            { x: 0.751, z: 0.257, v: 'bare' },
            { x: 0.748, z: 0.172, v: 'scraggly' },
            { x: 0.788, z: 0.289, v: 'sparse' },
            { x: 0.796, z: 0.236, v: 'sparse' },
            { x: 0.023, z: 0.075, v: 'dry' },
            { x: 0.027, z: 0.062, v: 'sparse' },
            { x: 0.098, z: 0.137, v: 'bare' },
            { x: 0.053, z: 0.085, v: 'dry' },
            { x: 0.017, z: 0.033, v: 'dry' },
            { x: 0.646, z: 0.612, v: 'bare' },
            { x: 0.521, z: 0.77, v: 'bare' },
            { x: 0.602, z: 0.696, v: 'sparse' },
            { x: 0.461, z: 0.678, v: 'scraggly' },
            { x: 0.561, z: 0.695, v: 'dry' },
            { x: 0.526, z: 0.7, v: 'scraggly' }
          ],
          rocks: [
            { x: 0.154, z: 0.971, rotY: 5.1, scale: 0.81 },
            { x: 0.125, z: 0.755, rotY: 2.6, scale: 0.77 },
            { x: 0.112, z: 0.644, rotY: 3.3, scale: 0.82 },
            { x: 0.505, z: 0.15, rotY: 0.5, scale: 0.65 },
            { x: 0.698, z: 0.805, rotY: 5.8, scale: 0.78 },
            { x: 0.147, z: 0.407, rotY: 2.2, scale: 0.66 },
            { x: 0.36, z: 0.174, rotY: 0.8, scale: 0.79 },
            { x: 0.187, z: 0.464, rotY: 0.1, scale: 0.89 },
            { x: 0.332, z: 0.651, rotY: 5.5, scale: 0.62 },
            { x: 0.97, z: 0.122, rotY: 2.1, scale: 0.6 },
            { x: 0.038, z: 0.342, rotY: 6.2, scale: 0.7 },
            { x: 0.015, z: 0.944, rotY: 2.5, scale: 0.87 },
            { x: 0.243, z: 0.583, rotY: 5.5, scale: 0.69 },
            { x: 0.84, z: 0.792, rotY: 1.4, scale: 0.74 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.352,
              z: 0.102,
              cubes: [
                { dx: 0.015, dz: -0.063, sx: 0.2, sy: 0.19, sz: 0.17, rotY: 1.2, rotZ: 0.12 },
                { dx: 0.03, dz: -0.043, sx: 0.26, sy: 0.22, sz: 0.15, rotY: 0.9, rotZ: -0.19 },
                { dx: -0.025, dz: -0.048, sx: 0.25, sy: 0.27, sz: 0.1, rotY: 2.2, rotZ: 0 },
                { dx: -0.061, dz: -0.056, sx: 0.19, sy: 0.26, sz: 0.11, rotY: 2.2, rotZ: -0.05 },
                { dx: 0.022, dz: -0.017, sx: 0.11, sy: 0.14, sz: 0.11, rotY: 4.5, rotZ: -0.07 },
                { dx: -0.064, dz: -0.017, sx: 0.26, sy: 0.24, sz: 0.1, rotY: 2.4, rotZ: 0.19 },
                { dx: -0.052, dz: -0.002, sx: 0.21, sy: 0.13, sz: 0.17, rotY: 3.2, rotZ: 0.05 },
                { dx: -0.062, dz: -0.032, sx: 0.2, sy: 0.13, sz: 0.19, rotY: 2.7, rotZ: -0.12 },
                { dx: 0.057, dz: -0.021, sx: 0.26, sy: 0.24, sz: 0.19, rotY: 1.4, rotZ: -0.21 },
                { dx: -0.027, dz: -0.063, sx: 0.17, sy: 0.14, sz: 0.2, rotY: 4.2, rotZ: -0.11 },
                { dx: -0.024, dz: -0.031, sx: 0.2, sy: 0.17, sz: 0.15, rotY: 3, rotZ: -0.25 },
                { dx: -0.051, dz: 0.055, sx: 0.13, sy: 0.14, sz: 0.13, rotY: 1.6, rotZ: 0.18 },
                { dx: -0.024, dz: 0.002, sx: 0.3, sy: 0.16, sz: 0.22, rotY: 2.6, rotZ: -0.07 }
              ],
              colliders: [
                { dx: 0.031, dz: -0.036, r: 0.0293 },
                { dx: -0.062, dz: -0.035, r: 0.0208 },
                { dx: -0.042, dz: 0.018, r: 0.0317 },
                { dx: -0.025, dz: -0.047, r: 0.0175 },
                { dx: 0.015, dz: -0.063, r: 0.014 },
                { dx: -0.051, dz: 0.055, r: 0.0091 }
              ]
            },
            {
              material: 'crystal',
              x: 0.519,
              z: 0.469,
              cubes: [
                { dx: -0.024, dz: -0.019, sx: 0.32, sy: 0.27, sz: 0.2, rotY: 2.6, rotZ: -0.07 },
                { dx: 0.04, dz: -0.026, sx: 0.21, sy: 0.26, sz: 0.15, rotY: 4, rotZ: -0.01 },
                { dx: 0.021, dz: 0.065, sx: 0.16, sy: 0.23, sz: 0.2, rotY: 2.6, rotZ: 0.06 },
                { dx: 0.018, dz: -0.036, sx: 0.26, sy: 0.13, sz: 0.13, rotY: 1.9, rotZ: -0.06 },
                { dx: -0.015, dz: -0.024, sx: 0.15, sy: 0.18, sz: 0.15, rotY: 0.5, rotZ: 0.18 },
                { dx: 0.02, dz: 0.052, sx: 0.31, sy: 0.25, sz: 0.12, rotY: 3.4, rotZ: -0.24 },
                { dx: 0.042, dz: -0.005, sx: 0.19, sy: 0.15, sz: 0.11, rotY: 6.1, rotZ: 0.11 },
                { dx: 0.008, dz: 0.064, sx: 0.14, sy: 0.23, sz: 0.23, rotY: 0.2, rotZ: 0 },
                { dx: 0.011, dz: -0.024, sx: 0.19, sy: 0.23, sz: 0.12, rotY: 1.7, rotZ: 0.2 },
                { dx: 0.031, dz: -0.023, sx: 0.31, sy: 0.19, sz: 0.13, rotY: 1, rotZ: -0.23 },
                { dx: 0.017, dz: -0.029, sx: 0.3, sy: 0.19, sz: 0.11, rotY: 2.8, rotZ: 0 }
              ],
              colliders: [
                { dx: -0.019, dz: -0.021, r: 0.0123 },
                { dx: 0.015, dz: 0.065, r: 0.0109 },
                { dx: 0.02, dz: 0.052, r: 0.0217 },
                { dx: 0.027, dz: -0.024, r: 0.0233 }
              ]
            },
            {
              material: 'crystal',
              x: 0.605,
              z: 0.786,
              cubes: [
                { dx: 0.052, dz: 0.047, sx: 0.26, sy: 0.28, sz: 0.19, rotY: 4.5, rotZ: -0.05 },
                { dx: -0.047, dz: -0.062, sx: 0.3, sy: 0.13, sz: 0.24, rotY: 1.7, rotZ: 0.25 },
                { dx: -0.042, dz: 0.048, sx: 0.32, sy: 0.16, sz: 0.23, rotY: 1.4, rotZ: 0.15 },
                { dx: 0.014, dz: -0.062, sx: 0.17, sy: 0.17, sz: 0.13, rotY: 6.1, rotZ: -0.01 },
                { dx: 0.052, dz: -0.015, sx: 0.23, sy: 0.13, sz: 0.11, rotY: 2.5, rotZ: 0.15 },
                { dx: -0.04, dz: -0.014, sx: 0.31, sy: 0.19, sz: 0.24, rotY: 0.3, rotZ: 0.02 },
                { dx: 0.035, dz: -0.008, sx: 0.25, sy: 0.18, sz: 0.22, rotY: 4.6, rotZ: 0.03 },
                { dx: 0.036, dz: 0.006, sx: 0.15, sy: 0.24, sz: 0.13, rotY: 2.8, rotZ: -0.05 },
                { dx: 0.012, dz: -0.007, sx: 0.25, sy: 0.13, sz: 0.22, rotY: 2.8, rotZ: 0.07 },
                { dx: 0.007, dz: 0.056, sx: 0.25, sy: 0.15, sz: 0.22, rotY: 3.7, rotZ: 0.07 },
                { dx: -0.005, dz: -0.005, sx: 0.17, sy: 0.27, sz: 0.19, rotY: 2.6, rotZ: 0.06 },
                { dx: -0.06, dz: 0.011, sx: 0.29, sy: 0.24, sz: 0.13, rotY: 3.5, rotZ: -0.02 },
                { dx: 0.062, dz: -0.005, sx: 0.28, sy: 0.24, sz: 0.2, rotY: 0.8, rotZ: 0.19 },
                { dx: 0.059, dz: -0.059, sx: 0.16, sy: 0.17, sz: 0.23, rotY: 4.4, rotZ: 0.24 }
              ],
              colliders: [
                { dx: 0.03, dz: 0.052, r: 0.024 },
                { dx: 0.009, dz: -0.061, r: 0.0496 },
                { dx: 0.039, dz: -0.006, r: 0.0271 },
                { dx: -0.037, dz: 0.01, r: 0.0372 },
                { dx: -0.047, dz: -0.062, r: 0.021 },
                { dx: -0.042, dz: 0.048, r: 0.0224 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_7',
        seed: 701,
        terrain: {
          hills: [
            { x: 0.67, z: 0.51, radius: 0.34, height: 0.3 },
            { x: 0.93, z: 0, radius: 0.33, height: 0.68 },
            { x: 0.23, z: 0.16, radius: 0.21, height: 0.4 },
            { x: 0.64, z: 0.56, radius: 0.33, height: 0.53 },
            { x: 0.48, z: 0.99, radius: 0.26, height: 0.21 },
            { x: 0.87, z: 0.13, radius: 0.29, height: 0.46 },
            { x: 0.66, z: 0.56, radius: 0.33, height: 0.38 },
            { x: 0.6, z: 0.29, radius: 0.37, height: 0.5 },
            { x: 1, z: 0.83, radius: 0.33, height: 0.12 },
            { x: 0.07, z: 0.4, radius: 0.22, height: 0.68 },
            { x: 0.37, z: 0.5, radius: 0.33, height: 0.41 },
            { x: 0.85, z: 0.56, radius: 0.33, height: 0.34 },
            { x: 0.8, z: 0.15, radius: 0.35, height: 0.59 }
          ]
        },
        items: {
          trees: [
            { x: 0.511, z: 0.642, v: 'bare' },
            { x: 0.533, z: 0.62, v: 'dry' },
            { x: 0.548, z: 0.663, v: 'sparse' },
            { x: 0.46, z: 0.622, v: 'sparse' },
            { x: 0.463, z: 0.637, v: 'sparse' },
            { x: 0.531, z: 0.641, v: 'dry' },
            { x: 0.399, z: 0.716, v: 'scraggly' },
            { x: 0.558, z: 0.556, v: 'dry' },
            { x: 0.437, z: 0.527, v: 'bare' },
            { x: 0.483, z: 0.515, v: 'scraggly' },
            { x: 0.417, z: 0.5, v: 'bare' },
            { x: 0.395, z: 0.503, v: 'dry' },
            { x: 0.397, z: 0.527, v: 'sparse' },
            { x: 0.344, z: 0.565, v: 'sparse' },
            { x: 0.292, z: 0.533, v: 'sparse' },
            { x: 0.446, z: 0.432, v: 'sparse' },
            { x: 0.477, z: 0.441, v: 'sparse' },
            { x: 0.499, z: 0.558, v: 'bare' },
            { x: 0.411, z: 0.445, v: 'dry' },
            { x: 0.692, z: 0.452, v: 'sparse' },
            { x: 0.696, z: 0.508, v: 'dry' },
            { x: 0.67, z: 0.44, v: 'scraggly' },
            { x: 0.661, z: 0.423, v: 'scraggly' },
            { x: 0.676, z: 0.484, v: 'dry' },
            { x: 0.707, z: 0.467, v: 'scraggly' },
            { x: 0.729, z: 0.506, v: 'scraggly' },
            { x: 0.729, z: 0.465, v: 'scraggly' },
            { x: 0.378, z: 0.946, v: 'dry' },
            { x: 0.333, z: 0.806, v: 'dry' },
            { x: 0.324, z: 0.938, v: 'sparse' },
            { x: 0.332, z: 0.903, v: 'dry' },
            { x: 0.26, z: 0.962, v: 'scraggly' },
            { x: 0.334, z: 0.85, v: 'dry' },
            { x: 0.286, z: 0.94, v: 'bare' },
            { x: 0.305, z: 0.885, v: 'scraggly' },
            { x: 0.234, z: 0.97, v: 'sparse' },
            { x: 0.413, z: 0.893, v: 'dry' },
            { x: 0.33, z: 0.88, v: 'sparse' },
            { x: 0.718, z: 0.452, v: 'bare' },
            { x: 0.847, z: 0.434, v: 'dry' },
            { x: 0.757, z: 0.479, v: 'sparse' },
            { x: 0.865, z: 0.425, v: 'bare' },
            { x: 0.586, z: 0.2, v: 'bare' },
            { x: 0.61, z: 0.215, v: 'sparse' },
            { x: 0.581, z: 0.111, v: 'dry' },
            { x: 0.605, z: 0.161, v: 'sparse' },
            { x: 0.7, z: 0.224, v: 'sparse' },
            { x: 0.593, z: 0.119, v: 'dry' },
            { x: 0.68, z: 0.191, v: 'sparse' },
            { x: 0.679, z: 0.115, v: 'dry' },
            { x: 0.59, z: 0.183, v: 'scraggly' },
            { x: 0.535, z: 0.284, v: 'dry' },
            { x: 0.565, z: 0.21, v: 'dry' },
            { x: 0.397, z: 0.786, v: 'bare' },
            { x: 0.486, z: 0.697, v: 'scraggly' },
            { x: 0.434, z: 0.668, v: 'dry' },
            { x: 0.471, z: 0.648, v: 'scraggly' },
            { x: 0.498, z: 0.722, v: 'scraggly' },
            { x: 0.513, z: 0.62, v: 'dry' },
            { x: 0.423, z: 0.774, v: 'bare' },
            { x: 0.554, z: 0.624, v: 'bare' },
            { x: 0.478, z: 0.747, v: 'sparse' },
            { x: 0.423, z: 0.797, v: 'scraggly' },
            { x: 0.771, z: 0.464, v: 'sparse' },
            { x: 0.804, z: 0.446, v: 'bare' },
            { x: 0.697, z: 0.41, v: 'sparse' },
            { x: 0.731, z: 0.434, v: 'bare' },
            { x: 0.727, z: 0.53, v: 'bare' },
            { x: 0.737, z: 0.48, v: 'bare' },
            { x: 0.751, z: 0.535, v: 'dry' },
            { x: 0.762, z: 0.527, v: 'sparse' }
          ],
          rocks: [
            { x: 0.272, z: 0.904, rotY: 0.8, scale: 0.62 },
            { x: 0.747, z: 0.35, rotY: 4.9, scale: 0.77 },
            { x: 0.963, z: 0.165, rotY: 2.1, scale: 0.94 },
            { x: 0.529, z: 0.308, rotY: 4.2, scale: 0.97 },
            { x: 0.474, z: 0.677, rotY: 5.3, scale: 0.93 },
            { x: 0.728, z: 0.026, rotY: 0.1, scale: 0.71 },
            { x: 0.104, z: 0.449, rotY: 6.2, scale: 0.73 },
            { x: 0.781, z: 0.434, rotY: 2.4, scale: 0.73 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.338,
              z: 0.211,
              cubes: [
                { dx: 0.042, dz: 0.017, sx: 0.22, sy: 0.28, sz: 0.15, rotY: 4.5, rotZ: 0.27 },
                { dx: -0.049, dz: 0.012, sx: 0.21, sy: 0.23, sz: 0.19, rotY: 3.7, rotZ: -0.13 },
                { dx: -0.033, dz: -0.024, sx: 0.17, sy: 0.19, sz: 0.15, rotY: 2.4, rotZ: 0.26 },
                { dx: -0.06, dz: -0.05, sx: 0.2, sy: 0.23, sz: 0.13, rotY: 5.6, rotZ: 0.09 },
                { dx: 0.002, dz: 0.058, sx: 0.12, sy: 0.25, sz: 0.23, rotY: 0.2, rotZ: -0.21 },
                { dx: 0.024, dz: -0.055, sx: 0.28, sy: 0.13, sz: 0.12, rotY: 5, rotZ: -0.24 },
                { dx: 0.001, dz: -0.004, sx: 0.25, sy: 0.16, sz: 0.12, rotY: 3.1, rotZ: 0.22 },
                { dx: -0.008, dz: 0.044, sx: 0.2, sy: 0.27, sz: 0.16, rotY: 5.7, rotZ: -0.27 },
                { dx: 0.03, dz: -0.06, sx: 0.22, sy: 0.2, sz: 0.18, rotY: 3.1, rotZ: -0.21 },
                { dx: 0.004, dz: -0.05, sx: 0.16, sy: 0.22, sz: 0.21, rotY: 6.2, rotZ: -0.27 },
                { dx: -0.033, dz: 0.033, sx: 0.2, sy: 0.19, sz: 0.1, rotY: 4.3, rotZ: 0.25 },
                { dx: -0.053, dz: -0.02, sx: 0.25, sy: 0.14, sz: 0.14, rotY: 2.7, rotZ: -0.07 },
                { dx: -0.049, dz: -0.028, sx: 0.23, sy: 0.16, sz: 0.12, rotY: 5, rotZ: -0.14 },
                { dx: 0.065, dz: 0.062, sx: 0.2, sy: 0.19, sz: 0.18, rotY: 1.7, rotZ: -0.07 },
                { dx: -0.025, dz: -0.048, sx: 0.21, sy: 0.17, sz: 0.11, rotY: 6, rotZ: -0.19 }
              ],
              colliders: [
                { dx: 0.032, dz: -0.008, r: 0.0632 },
                { dx: -0.027, dz: -0.049, r: 0.03 },
                { dx: -0.013, dz: 0.045, r: 0.0227 },
                { dx: -0.046, dz: -0.015, r: 0.0259 },
                { dx: -0.049, dz: 0.012, r: 0.0147 },
                { dx: -0.06, dz: -0.05, r: 0.014 },
                { dx: 0.065, dz: 0.062, r: 0.014 }
              ]
            },
            {
              material: 'crystal',
              x: 0.502,
              z: 0.724,
              cubes: [
                { dx: -0.041, dz: 0.046, sx: 0.28, sy: 0.27, sz: 0.18, rotY: 1.7, rotZ: -0.13 },
                { dx: -0.03, dz: 0.04, sx: 0.2, sy: 0.24, sz: 0.11, rotY: 2, rotZ: 0.17 },
                { dx: 0.025, dz: 0.064, sx: 0.23, sy: 0.13, sz: 0.14, rotY: 1.2, rotZ: 0.27 },
                { dx: -0.014, dz: 0.02, sx: 0.26, sy: 0.14, sz: 0.23, rotY: 3.8, rotZ: -0.25 },
                { dx: 0.035, dz: 0.003, sx: 0.16, sy: 0.25, sz: 0.19, rotY: 2.3, rotZ: 0.06 },
                { dx: -0.024, dz: -0.015, sx: 0.24, sy: 0.25, sz: 0.16, rotY: 1.2, rotZ: 0.28 },
                { dx: 0.015, dz: 0.026, sx: 0.12, sy: 0.26, sz: 0.18, rotY: 4.9, rotZ: 0.07 },
                { dx: -0.035, dz: -0.056, sx: 0.22, sy: 0.22, sz: 0.14, rotY: 4, rotZ: 0.05 },
                { dx: -0.026, dz: -0.024, sx: 0.24, sy: 0.23, sz: 0.16, rotY: 1.7, rotZ: 0.24 },
                { dx: 0.059, dz: -0.038, sx: 0.14, sy: 0.12, sz: 0.17, rotY: 3.8, rotZ: 0.06 },
                { dx: -0.061, dz: -0.05, sx: 0.21, sy: 0.15, sz: 0.23, rotY: 4, rotZ: -0.05 },
                { dx: -0.037, dz: -0.002, sx: 0.16, sy: 0.27, sz: 0.18, rotY: 2.4, rotZ: 0.03 }
              ],
              colliders: [
                { dx: -0.028, dz: 0.035, r: 0.0226 },
                { dx: -0.037, dz: -0.029, r: 0.03 },
                { dx: 0.025, dz: 0.031, r: 0.0308 },
                { dx: 0.059, dz: -0.038, r: 0.0119 },
                { dx: 0.025, dz: 0.064, r: 0.0161 },
                { dx: -0.061, dz: -0.05, r: 0.0161 }
              ]
            },
            {
              material: 'crystal',
              x: 0.833,
              z: 0.763,
              cubes: [
                { dx: -0.002, dz: -0.018, sx: 0.13, sy: 0.27, sz: 0.14, rotY: 0.9, rotZ: 0.17 },
                { dx: 0.063, dz: -0.009, sx: 0.16, sy: 0.25, sz: 0.18, rotY: 3.4, rotZ: 0.18 },
                { dx: 0.065, dz: 0.041, sx: 0.2, sy: 0.26, sz: 0.24, rotY: 6.1, rotZ: -0.15 },
                { dx: -0.03, dz: 0.023, sx: 0.17, sy: 0.26, sz: 0.17, rotY: 3.7, rotZ: 0.03 },
                { dx: -0.025, dz: -0.014, sx: 0.32, sy: 0.14, sz: 0.13, rotY: 1.3, rotZ: 0.06 },
                { dx: -0.061, dz: 0.034, sx: 0.29, sy: 0.27, sz: 0.23, rotY: 2.9, rotZ: 0.08 },
                { dx: -0.023, dz: -0.055, sx: 0.32, sy: 0.27, sz: 0.24, rotY: 0.7, rotZ: 0.18 },
                { dx: -0.006, dz: -0.008, sx: 0.15, sy: 0.12, sz: 0.21, rotY: 2.4, rotZ: -0.17 }
              ],
              colliders: [
                { dx: -0.011, dz: -0.013, r: 0.0189 },
                { dx: 0.064, dz: 0.016, r: 0.0251 },
                { dx: -0.045, dz: 0.029, r: 0.0199 },
                { dx: -0.023, dz: -0.055, r: 0.0224 }
              ]
            },
            {
              material: 'crystal',
              x: 0.817,
              z: 0.141,
              cubes: [
                { dx: 0.02, dz: -0.016, sx: 0.19, sy: 0.21, sz: 0.2, rotY: 0.4, rotZ: -0.17 },
                { dx: -0.036, dz: -0.055, sx: 0.12, sy: 0.16, sz: 0.12, rotY: 3.7, rotZ: -0.21 },
                { dx: 0.051, dz: 0.038, sx: 0.27, sy: 0.15, sz: 0.11, rotY: 5.6, rotZ: -0.19 },
                { dx: 0, dz: -0.059, sx: 0.17, sy: 0.21, sz: 0.1, rotY: 3.9, rotZ: -0.1 },
                { dx: 0.027, dz: -0.025, sx: 0.23, sy: 0.17, sz: 0.23, rotY: 4.8, rotZ: 0.22 },
                { dx: -0.039, dz: 0.026, sx: 0.16, sy: 0.14, sz: 0.11, rotY: 1.1, rotZ: -0.11 },
                { dx: 0.034, dz: -0.061, sx: 0.17, sy: 0.2, sz: 0.15, rotY: 0.3, rotZ: 0.1 },
                { dx: -0.049, dz: -0.024, sx: 0.31, sy: 0.26, sz: 0.22, rotY: 4.9, rotZ: 0.23 },
                { dx: -0.051, dz: 0.065, sx: 0.26, sy: 0.26, sz: 0.16, rotY: 3.5, rotZ: -0.27 },
                { dx: -0.007, dz: 0.038, sx: 0.21, sy: 0.22, sz: 0.13, rotY: 2.6, rotZ: 0.25 },
                { dx: 0.06, dz: 0.065, sx: 0.13, sy: 0.17, sz: 0.13, rotY: 1.9, rotZ: -0.08 },
                { dx: 0.047, dz: -0.045, sx: 0.16, sy: 0.15, sz: 0.15, rotY: 4.4, rotZ: 0.25 },
                { dx: 0.004, dz: -0.049, sx: 0.3, sy: 0.16, sz: 0.22, rotY: 4, rotZ: -0.08 },
                { dx: 0.019, dz: 0.047, sx: 0.15, sy: 0.12, sz: 0.2, rotY: 6.3, rotZ: -0.23 }
              ],
              colliders: [
                { dx: 0.032, dz: -0.037, r: 0.0232 },
                { dx: -0.02, dz: -0.047, r: 0.0356 },
                { dx: -0.032, dz: 0.043, r: 0.0285 },
                { dx: 0.043, dz: 0.05, r: 0.0236 },
                { dx: -0.049, dz: -0.024, r: 0.0217 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_8',
        seed: 801,
        terrain: {
          hills: [
            { x: 0, z: 0.25, radius: 0.34, height: 0.59 },
            { x: 0.25, z: 0.71, radius: 0.32, height: 0.21 },
            { x: 0.94, z: 0.7, radius: 0.36, height: 0.22 },
            { x: 0.65, z: 0.6, radius: 0.37, height: 0.43 },
            { x: 0.44, z: 0.98, radius: 0.28, height: 0.13 },
            { x: 0.83, z: 0.66, radius: 0.4, height: 0.28 },
            { x: 0.87, z: 0.82, radius: 0.38, height: 0.23 },
            { x: 0.15, z: 0.28, radius: 0.37, height: 0.69 },
            { x: 0.91, z: 0.56, radius: 0.28, height: 0.27 },
            { x: 0.11, z: 0.05, radius: 0.25, height: 0.69 },
            { x: 0.32, z: 0.14, radius: 0.26, height: 0.67 },
            { x: 0.7, z: 0.38, radius: 0.34, height: 0.47 },
            { x: 0.76, z: 0.56, radius: 0.38, height: 0.29 }
          ]
        },
        items: {
          trees: [
            { x: 0.904, z: 0.061, v: 'scraggly' },
            { x: 0.937, z: 0.072, v: 'scraggly' },
            { x: 0.934, z: 0.022, v: 'bare' },
            { x: 0.908, z: 0.038, v: 'scraggly' },
            { x: 0.92, z: 0.033, v: 'sparse' },
            { x: 0.912, z: 0.915, v: 'dry' },
            { x: 0.986, z: 0.916, v: 'scraggly' },
            { x: 0.872, z: 0.935, v: 'dry' },
            { x: 0.85, z: 0.953, v: 'scraggly' },
            { x: 0.937, z: 0.924, v: 'dry' },
            { x: 0.956, z: 0.964, v: 'bare' },
            { x: 0.89, z: 0.932, v: 'sparse' },
            { x: 0.913, z: 0.938, v: 'sparse' },
            { x: 0.913, z: 0.975, v: 'scraggly' },
            { x: 0.9, z: 0.859, v: 'sparse' },
            { x: 0.768, z: 0.156, v: 'dry' },
            { x: 0.893, z: 0.08, v: 'bare' },
            { x: 0.859, z: 0.067, v: 'dry' },
            { x: 0.871, z: 0.082, v: 'bare' },
            { x: 0.835, z: 0.021, v: 'scraggly' },
            { x: 0.772, z: 0.021, v: 'dry' },
            { x: 0.835, z: 0.047, v: 'sparse' },
            { x: 0.886, z: 0.049, v: 'dry' },
            { x: 0.833, z: 0.122, v: 'dry' },
            { x: 0.934, z: 0.122, v: 'sparse' },
            { x: 0.789, z: 0.039, v: 'sparse' },
            { x: 0.625, z: 0.403, v: 'scraggly' },
            { x: 0.565, z: 0.501, v: 'sparse' },
            { x: 0.627, z: 0.443, v: 'dry' },
            { x: 0.633, z: 0.542, v: 'scraggly' },
            { x: 0.611, z: 0.517, v: 'bare' },
            { x: 0.609, z: 0.489, v: 'scraggly' },
            { x: 0.569, z: 0.484, v: 'scraggly' },
            { x: 0.659, z: 0.534, v: 'dry' },
            { x: 0.598, z: 0.493, v: 'bare' },
            { x: 0.562, z: 0.54, v: 'dry' },
            { x: 0.071, z: 0.705, v: 'bare' },
            { x: 0.142, z: 0.864, v: 'sparse' },
            { x: 0.155, z: 0.766, v: 'sparse' },
            { x: 0.152, z: 0.751, v: 'sparse' },
            { x: 0.113, z: 0.799, v: 'dry' },
            { x: 0.112, z: 0.699, v: 'scraggly' },
            { x: 0.131, z: 0.849, v: 'scraggly' },
            { x: 0.152, z: 0.826, v: 'scraggly' },
            { x: 0.054, z: 0.568, v: 'scraggly' },
            { x: 0.149, z: 0.628, v: 'scraggly' },
            { x: 0.1, z: 0.6, v: 'dry' },
            { x: 0.087, z: 0.664, v: 'scraggly' },
            { x: 0.176, z: 0.629, v: 'sparse' },
            { x: 0.105, z: 0.558, v: 'bare' },
            { x: 0.081, z: 0.584, v: 'bare' },
            { x: 0.057, z: 0.552, v: 'bare' },
            { x: 0.912, z: 0.863, v: 'bare' },
            { x: 0.886, z: 0.872, v: 'dry' },
            { x: 0.899, z: 0.979, v: 'dry' },
            { x: 0.865, z: 0.87, v: 'dry' },
            { x: 0.977, z: 0.964, v: 'scraggly' },
            { x: 0.952, z: 0.992, v: 'scraggly' },
            { x: 0.931, z: 0.883, v: 'dry' },
            { x: 0.939, z: 0.843, v: 'scraggly' },
            { x: 0.043, z: 0.785, v: 'scraggly' },
            { x: 0.049, z: 0.813, v: 'scraggly' },
            { x: 0.021, z: 0.867, v: 'scraggly' },
            { x: 0.019, z: 0.829, v: 'dry' },
            { x: 0.106, z: 0.644, v: 'scraggly' },
            { x: 0.033, z: 0.536, v: 'sparse' },
            { x: 0.077, z: 0.541, v: 'bare' },
            { x: 0.182, z: 0.535, v: 'sparse' },
            { x: 0.088, z: 0.512, v: 'dry' },
            { x: 0.086, z: 0.555, v: 'bare' },
            { x: 0.108, z: 0.621, v: 'bare' },
            { x: 0.577, z: 0.223, v: 'bare' },
            { x: 0.634, z: 0.311, v: 'sparse' },
            { x: 0.593, z: 0.328, v: 'sparse' },
            { x: 0.652, z: 0.338, v: 'dry' },
            { x: 0.521, z: 0.305, v: 'dry' }
          ],
          rocks: [
            { x: 0.807, z: 0.221, rotY: 5.6, scale: 0.77 },
            { x: 0.518, z: 0.041, rotY: 1.4, scale: 0.96 },
            { x: 0.965, z: 0.526, rotY: 1.7, scale: 0.97 },
            { x: 0.042, z: 0.85, rotY: 0.7, scale: 0.72 },
            { x: 0.726, z: 0.382, rotY: 6.1, scale: 0.72 },
            { x: 0.932, z: 0.841, rotY: 1.3, scale: 0.83 },
            { x: 0.402, z: 0.793, rotY: 2.3, scale: 0.69 },
            { x: 0.215, z: 0.24, rotY: 5.5, scale: 0.71 },
            { x: 0.294, z: 0.781, rotY: 6.2, scale: 0.85 },
            { x: 0.059, z: 0.754, rotY: 0.1, scale: 0.78 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.899,
              z: 0.338,
              cubes: [
                { dx: -0.009, dz: 0.051, sx: 0.12, sy: 0.15, sz: 0.16, rotY: 2, rotZ: -0.03 },
                { dx: -0.016, dz: 0.033, sx: 0.25, sy: 0.14, sz: 0.18, rotY: 3.8, rotZ: 0.08 },
                { dx: 0.002, dz: 0.031, sx: 0.29, sy: 0.23, sz: 0.12, rotY: 4.1, rotZ: -0.04 },
                { dx: 0.064, dz: 0.02, sx: 0.22, sy: 0.14, sz: 0.19, rotY: 1.8, rotZ: -0.15 },
                { dx: -0.048, dz: 0.045, sx: 0.11, sy: 0.22, sz: 0.12, rotY: 6.2, rotZ: -0.04 },
                { dx: 0.051, dz: -0.041, sx: 0.18, sy: 0.27, sz: 0.2, rotY: 3.6, rotZ: 0.02 },
                { dx: 0.001, dz: -0.023, sx: 0.24, sy: 0.26, sz: 0.18, rotY: 6.3, rotZ: -0.25 },
                { dx: 0.049, dz: 0.014, sx: 0.32, sy: 0.23, sz: 0.13, rotY: 6, rotZ: 0.14 },
                { dx: -0.061, dz: -0.006, sx: 0.28, sy: 0.19, sz: 0.17, rotY: 1.5, rotZ: -0.15 },
                { dx: 0.043, dz: -0.019, sx: 0.31, sy: 0.25, sz: 0.12, rotY: 2.7, rotZ: -0.02 },
                { dx: -0.042, dz: -0.04, sx: 0.19, sy: 0.21, sz: 0.18, rotY: 0.6, rotZ: 0.05 }
              ],
              colliders: [
                { dx: -0.024, dz: 0.043, r: 0.021 },
                { dx: 0.002, dz: 0.031, r: 0.0203 },
                { dx: 0.042, dz: -0.01, r: 0.0383 },
                { dx: -0.052, dz: -0.023, r: 0.022 },
                { dx: -0.048, dz: 0.045, r: 0.0084 },
                { dx: 0.001, dz: -0.023, r: 0.0168 }
              ]
            },
            {
              material: 'crystal',
              x: 0.633,
              z: 0.283,
              cubes: [
                { dx: 0, dz: -0.004, sx: 0.18, sy: 0.19, sz: 0.18, rotY: 3, rotZ: 0.04 },
                { dx: -0.016, dz: 0.027, sx: 0.16, sy: 0.16, sz: 0.15, rotY: 4.6, rotZ: -0.12 },
                { dx: 0.039, dz: -0.064, sx: 0.27, sy: 0.2, sz: 0.2, rotY: 0.3, rotZ: -0.04 },
                { dx: 0.054, dz: 0.008, sx: 0.16, sy: 0.21, sz: 0.13, rotY: 2.8, rotZ: -0.09 },
                { dx: 0.062, dz: 0.014, sx: 0.31, sy: 0.14, sz: 0.2, rotY: 4.9, rotZ: -0.24 },
                { dx: -0.059, dz: 0.016, sx: 0.3, sy: 0.24, sz: 0.22, rotY: 2.7, rotZ: -0.05 },
                { dx: -0.017, dz: 0.026, sx: 0.3, sy: 0.22, sz: 0.14, rotY: 2, rotZ: -0.2 },
                { dx: -0.056, dz: -0.004, sx: 0.3, sy: 0.2, sz: 0.11, rotY: 4.2, rotZ: 0.21 },
                { dx: 0.04, dz: -0.033, sx: 0.3, sy: 0.18, sz: 0.1, rotY: 5.5, rotZ: 0.24 },
                { dx: 0.035, dz: 0.055, sx: 0.3, sy: 0.17, sz: 0.12, rotY: 2.8, rotZ: 0.03 },
                { dx: 0.044, dz: -0.033, sx: 0.27, sy: 0.21, sz: 0.14, rotY: 6.1, rotZ: 0.18 },
                { dx: -0.005, dz: -0.055, sx: 0.12, sy: 0.26, sz: 0.23, rotY: 2.9, rotZ: 0.09 },
                { dx: -0.053, dz: -0.035, sx: 0.17, sy: 0.23, sz: 0.11, rotY: 4, rotZ: -0.26 },
                { dx: -0.008, dz: -0.01, sx: 0.13, sy: 0.13, sz: 0.23, rotY: 2.3, rotZ: 0.16 }
              ],
              colliders: [
                { dx: -0.01, dz: 0.01, r: 0.0211 },
                { dx: 0.05, dz: 0.026, r: 0.0327 },
                { dx: -0.056, dz: -0.008, r: 0.0258 },
                { dx: 0.03, dz: -0.046, r: 0.0327 },
                { dx: -0.005, dz: -0.055, r: 0.0161 },
                { dx: -0.053, dz: -0.035, r: 0.0119 }
              ]
            }
          ]
        }
      },
      {
        id: 'rock_9',
        seed: 901,
        terrain: {
          hills: [
            { x: 0.33, z: 0.49, radius: 0.34, height: 0.29 },
            { x: 0.58, z: 0.21, radius: 0.3, height: 0.6 },
            { x: 0.65, z: 0.37, radius: 0.28, height: 0.44 },
            { x: 0.66, z: 0.38, radius: 0.19, height: 0.32 },
            { x: 0.4, z: 0.58, radius: 0.3, height: 0.48 },
            { x: 0.79, z: 1, radius: 0.28, height: 0.38 },
            { x: 0.07, z: 0.1, radius: 0.21, height: 0.49 },
            { x: 0.7, z: 0.27, radius: 0.37, height: 0.57 },
            { x: 0.82, z: 0.65, radius: 0.24, height: 0.16 },
            { x: 0.15, z: 0.7, radius: 0.28, height: 0.42 },
            { x: 0.27, z: 0.63, radius: 0.2, height: 0.19 },
            { x: 0.55, z: 0.76, radius: 0.36, height: 0.16 },
            { x: 0.72, z: 0.12, radius: 0.4, height: 0.59 }
          ]
        },
        items: {
          trees: [
            { x: 0.249, z: 0.383, v: 'dry' },
            { x: 0.362, z: 0.427, v: 'sparse' },
            { x: 0.221, z: 0.414, v: 'sparse' },
            { x: 0.362, z: 0.445, v: 'scraggly' },
            { x: 0.334, z: 0.408, v: 'bare' },
            { x: 0.303, z: 0.338, v: 'scraggly' },
            { x: 0.367, z: 0.311, v: 'sparse' },
            { x: 0.408, z: 0.328, v: 'scraggly' },
            { x: 0.389, z: 0.378, v: 'scraggly' },
            { x: 0.801, z: 0.64, v: 'dry' },
            { x: 0.872, z: 0.633, v: 'dry' },
            { x: 0.9, z: 0.637, v: 'dry' },
            { x: 0.809, z: 0.674, v: 'dry' },
            { x: 0.786, z: 0.604, v: 'scraggly' },
            { x: 0.855, z: 0.73, v: 'bare' },
            { x: 0.745, z: 0.575, v: 'sparse' },
            { x: 0.927, z: 0.67, v: 'bare' },
            { x: 0.882, z: 0.537, v: 'scraggly' },
            { x: 0.932, z: 0.695, v: 'dry' },
            { x: 0.381, z: 0.015, v: 'bare' },
            { x: 0.315, z: 0.098, v: 'scraggly' },
            { x: 0.304, z: 0.123, v: 'bare' },
            { x: 0.35, z: 0.052, v: 'bare' },
            { x: 0.841, z: 0.478, v: 'dry' },
            { x: 0.81, z: 0.497, v: 'bare' },
            { x: 0.796, z: 0.559, v: 'bare' },
            { x: 0.824, z: 0.651, v: 'sparse' },
            { x: 0.904, z: 0.585, v: 'bare' },
            { x: 0.838, z: 0.639, v: 'dry' },
            { x: 0.831, z: 0.52, v: 'scraggly' },
            { x: 0.766, z: 0.502, v: 'scraggly' },
            { x: 0.709, z: 0.588, v: 'bare' },
            { x: 0.86, z: 0.429, v: 'sparse' },
            { x: 0.757, z: 0.408, v: 'bare' },
            { x: 0.785, z: 0.363, v: 'scraggly' },
            { x: 0.854, z: 0.443, v: 'scraggly' },
            { x: 0.776, z: 0.388, v: 'scraggly' },
            { x: 0.893, z: 0.558, v: 'dry' },
            { x: 0.166, z: 0.486, v: 'sparse' },
            { x: 0.211, z: 0.479, v: 'dry' },
            { x: 0.198, z: 0.372, v: 'bare' },
            { x: 0.288, z: 0.394, v: 'bare' },
            { x: 0.195, z: 0.455, v: 'scraggly' },
            { x: 0.26, z: 0.561, v: 'sparse' },
            { x: 0.203, z: 0.47, v: 'sparse' },
            { x: 0.29, z: 0.511, v: 'bare' },
            { x: 0.258, z: 0.424, v: 'bare' },
            { x: 0.205, z: 0.499, v: 'scraggly' },
            { x: 0.157, z: 0.572, v: 'sparse' },
            { x: 0.458, z: 0.55, v: 'bare' },
            { x: 0.554, z: 0.377, v: 'dry' },
            { x: 0.537, z: 0.372, v: 'scraggly' },
            { x: 0.497, z: 0.463, v: 'sparse' },
            { x: 0.486, z: 0.47, v: 'dry' },
            { x: 0.429, z: 0.56, v: 'dry' },
            { x: 0.506, z: 0.377, v: 'sparse' },
            { x: 0.486, z: 0.449, v: 'bare' },
            { x: 0.544, z: 0.416, v: 'sparse' },
            { x: 0.456, z: 0.449, v: 'dry' },
            { x: 0.387, z: 0.822, v: 'bare' },
            { x: 0.37, z: 0.595, v: 'sparse' },
            { x: 0.402, z: 0.724, v: 'scraggly' },
            { x: 0.387, z: 0.75, v: 'scraggly' },
            { x: 0.35, z: 0.728, v: 'bare' },
            { x: 0.356, z: 0.635, v: 'sparse' },
            { x: 0.657, z: 0.77, v: 'scraggly' },
            { x: 0.642, z: 0.643, v: 'sparse' },
            { x: 0.671, z: 0.608, v: 'scraggly' },
            { x: 0.679, z: 0.733, v: 'scraggly' },
            { x: 0.688, z: 0.723, v: 'bare' },
            { x: 0.526, z: 0.847, v: 'scraggly' },
            { x: 0.439, z: 0.739, v: 'sparse' },
            { x: 0.443, z: 0.905, v: 'dry' },
            { x: 0.495, z: 0.823, v: 'scraggly' },
            { x: 0.483, z: 0.855, v: 'sparse' },
            { x: 0.489, z: 0.779, v: 'bare' }
          ],
          rocks: [
            { x: 0.283, z: 0.541, rotY: 0.5, scale: 0.72 },
            { x: 0.913, z: 0.794, rotY: 4.3, scale: 0.72 },
            { x: 0.925, z: 0.278, rotY: 2, scale: 0.93 },
            { x: 0.098, z: 0.956, rotY: 0.1, scale: 0.93 },
            { x: 0.294, z: 0.707, rotY: 4.6, scale: 0.61 },
            { x: 0.751, z: 0.103, rotY: 6.2, scale: 0.96 },
            { x: 0.551, z: 0.509, rotY: 4.7, scale: 0.97 },
            { x: 0.718, z: 0.629, rotY: 0.4, scale: 0.77 }
          ],
          sticks: [],
          minables: [
            {
              material: 'crystal',
              x: 0.446,
              z: 0.404,
              cubes: [
                { dx: -0.044, dz: 0.003, sx: 0.13, sy: 0.15, sz: 0.16, rotY: 3.7, rotZ: -0.13 },
                { dx: 0.01, dz: 0.06, sx: 0.22, sy: 0.22, sz: 0.21, rotY: 4.2, rotZ: -0.14 },
                { dx: -0.063, dz: -0.025, sx: 0.31, sy: 0.16, sz: 0.21, rotY: 4.4, rotZ: -0.25 },
                { dx: -0.039, dz: -0.031, sx: 0.27, sy: 0.24, sz: 0.18, rotY: 2.1, rotZ: 0.12 },
                { dx: 0.056, dz: -0.037, sx: 0.12, sy: 0.2, sz: 0.15, rotY: 0.8, rotZ: 0.07 },
                { dx: -0.026, dz: -0.029, sx: 0.2, sy: 0.15, sz: 0.11, rotY: 4.1, rotZ: 0 },
                { dx: 0.001, dz: 0, sx: 0.28, sy: 0.14, sz: 0.21, rotY: 6.1, rotZ: -0.04 },
                { dx: 0.008, dz: 0.043, sx: 0.25, sy: 0.19, sz: 0.22, rotY: 2, rotZ: -0.06 },
                { dx: -0.003, dz: 0.022, sx: 0.3, sy: 0.23, sz: 0.18, rotY: 3.2, rotZ: -0.22 },
                { dx: 0.001, dz: 0.001, sx: 0.19, sy: 0.24, sz: 0.19, rotY: 4, rotZ: 0.28 }
              ],
              colliders: [
                { dx: -0.044, dz: 0.003, r: 0.0112 },
                { dx: -0.043, dz: -0.028, r: 0.0236 },
                { dx: 0.019, dz: -0.012, r: 0.0372 },
                { dx: 0.005, dz: 0.042, r: 0.0238 },
                { dx: 0.056, dz: -0.037, r: 0.0105 }
              ]
            },
            {
              material: 'crystal',
              x: 0.625,
              z: 0.224,
              cubes: [
                { dx: 0.039, dz: 0.059, sx: 0.16, sy: 0.26, sz: 0.22, rotY: 5, rotZ: -0.09 },
                { dx: 0.027, dz: -0.052, sx: 0.26, sy: 0.23, sz: 0.14, rotY: 0.7, rotZ: 0.17 },
                { dx: -0.063, dz: -0.055, sx: 0.14, sy: 0.18, sz: 0.1, rotY: 1.8, rotZ: -0.04 },
                { dx: -0.058, dz: 0.022, sx: 0.13, sy: 0.2, sz: 0.23, rotY: 2.3, rotZ: -0.21 },
                { dx: 0.036, dz: 0.036, sx: 0.18, sy: 0.18, sz: 0.19, rotY: 1.6, rotZ: -0.08 },
                { dx: -0.019, dz: 0.019, sx: 0.19, sy: 0.16, sz: 0.13, rotY: 1.4, rotZ: -0.15 },
                { dx: -0.032, dz: 0.025, sx: 0.12, sy: 0.25, sz: 0.22, rotY: 1.9, rotZ: 0.11 },
                { dx: 0.016, dz: 0.031, sx: 0.14, sy: 0.26, sz: 0.17, rotY: 5, rotZ: -0.28 },
                { dx: -0.001, dz: 0.045, sx: 0.13, sy: 0.22, sz: 0.2, rotY: 1.2, rotZ: -0.25 },
                { dx: -0.01, dz: 0.018, sx: 0.19, sy: 0.16, sz: 0.17, rotY: 3.5, rotZ: 0.21 },
                { dx: 0.044, dz: -0.004, sx: 0.17, sy: 0.17, sz: 0.2, rotY: 6, rotZ: 0.26 },
                { dx: 0.064, dz: 0.064, sx: 0.2, sy: 0.19, sz: 0.13, rotY: 0.9, rotZ: -0.16 }
              ],
              colliders: [
                { dx: 0.039, dz: 0.048, r: 0.0279 },
                { dx: -0.063, dz: -0.055, r: 0.0098 },
                { dx: -0.024, dz: 0.026, r: 0.0317 },
                { dx: 0.036, dz: -0.028, r: 0.0259 },
                { dx: -0.058, dz: 0.022, r: 0.0161 },
                { dx: 0.064, dz: 0.064, r: 0.014 }
              ]
            },
            {
              material: 'crystal',
              x: 0.437,
              z: 0.835,
              cubes: [
                { dx: 0.049, dz: 0, sx: 0.17, sy: 0.17, sz: 0.16, rotY: 5.7, rotZ: 0.26 },
                { dx: 0.017, dz: 0.004, sx: 0.11, sy: 0.14, sz: 0.17, rotY: 3.1, rotZ: -0.08 },
                { dx: -0.004, dz: 0.039, sx: 0.11, sy: 0.24, sz: 0.13, rotY: 0.3, rotZ: 0.13 },
                { dx: -0.025, dz: -0.02, sx: 0.21, sy: 0.2, sz: 0.12, rotY: 3.2, rotZ: 0.06 },
                { dx: -0.034, dz: 0.005, sx: 0.28, sy: 0.27, sz: 0.19, rotY: 4.2, rotZ: -0.08 },
                { dx: 0.045, dz: -0.061, sx: 0.28, sy: 0.22, sz: 0.14, rotY: 1, rotZ: 0.02 },
                { dx: 0.042, dz: 0.037, sx: 0.17, sy: 0.21, sz: 0.15, rotY: 0.6, rotZ: 0.02 },
                { dx: 0.054, dz: -0.019, sx: 0.26, sy: 0.12, sz: 0.22, rotY: 2.4, rotZ: -0.13 }
              ],
              colliders: [
                { dx: 0.041, dz: -0.019, r: 0.039 },
                { dx: -0.004, dz: 0.039, r: 0.0091 },
                { dx: -0.03, dz: -0.007, r: 0.0173 },
                { dx: 0.042, dz: 0.037, r: 0.0119 },
                { dx: 0.045, dz: -0.061, r: 0.0196 }
              ]
            },
            {
              material: 'crystal',
              x: 0.764,
              z: 0.9,
              cubes: [
                { dx: 0.025, dz: 0.047, sx: 0.18, sy: 0.22, sz: 0.16, rotY: 1, rotZ: -0.18 },
                { dx: -0.032, dz: -0.009, sx: 0.19, sy: 0.13, sz: 0.12, rotY: 0.5, rotZ: -0.09 },
                { dx: -0.018, dz: 0.011, sx: 0.1, sy: 0.23, sz: 0.17, rotY: 4.7, rotZ: -0.21 },
                { dx: 0.029, dz: -0.032, sx: 0.15, sy: 0.28, sz: 0.12, rotY: 4.9, rotZ: -0.24 },
                { dx: -0.053, dz: 0.008, sx: 0.25, sy: 0.25, sz: 0.11, rotY: 3.5, rotZ: 0.21 },
                { dx: 0.021, dz: 0.051, sx: 0.22, sy: 0.15, sz: 0.16, rotY: 1.9, rotZ: 0.15 },
                { dx: 0.017, dz: 0.054, sx: 0.11, sy: 0.22, sz: 0.13, rotY: 1.5, rotZ: -0.18 },
                { dx: -0.02, dz: -0.039, sx: 0.25, sy: 0.22, sz: 0.16, rotY: 1.1, rotZ: 0.13 },
                { dx: 0.024, dz: 0.029, sx: 0.17, sy: 0.24, sz: 0.19, rotY: 2.1, rotZ: 0.02 },
                { dx: 0.064, dz: 0, sx: 0.23, sy: 0.24, sz: 0.15, rotY: 0.1, rotZ: 0.19 },
                { dx: 0.047, dz: 0.009, sx: 0.19, sy: 0.23, sz: 0.2, rotY: 5.4, rotZ: -0.23 }
              ],
              colliders: [
                { dx: 0.024, dz: 0.029, r: 0.0133 },
                { dx: -0.031, dz: -0.007, r: 0.0317 },
                { dx: 0.021, dz: 0.051, r: 0.0088 },
                { dx: 0.047, dz: -0.008, r: 0.0265 },
                { dx: 0.029, dz: -0.032, r: 0.0105 },
                { dx: -0.02, dz: -0.039, r: 0.0175 }
              ]
            },
            {
              material: 'crystal',
              x: 0.642,
              z: 0.531,
              cubes: [
                { dx: 0.047, dz: -0.005, sx: 0.13, sy: 0.25, sz: 0.14, rotY: 4.8, rotZ: -0.25 },
                { dx: -0.015, dz: 0.008, sx: 0.18, sy: 0.16, sz: 0.11, rotY: 0, rotZ: -0.21 },
                { dx: -0.009, dz: 0.05, sx: 0.3, sy: 0.16, sz: 0.16, rotY: 3.1, rotZ: -0.13 },
                { dx: 0.065, dz: 0.04, sx: 0.17, sy: 0.27, sz: 0.24, rotY: 4.6, rotZ: 0.26 },
                { dx: 0.056, dz: 0.061, sx: 0.12, sy: 0.19, sz: 0.14, rotY: 5.4, rotZ: 0.07 },
                { dx: 0.025, dz: 0.055, sx: 0.22, sy: 0.26, sz: 0.13, rotY: 1.6, rotZ: -0.03 },
                { dx: -0.045, dz: 0.054, sx: 0.25, sy: 0.13, sz: 0.13, rotY: 3.5, rotZ: -0.22 },
                { dx: 0.064, dz: -0.047, sx: 0.16, sy: 0.13, sz: 0.24, rotY: 3.9, rotZ: -0.26 },
                { dx: -0.029, dz: -0.05, sx: 0.19, sy: 0.15, sz: 0.13, rotY: 2.1, rotZ: -0.13 }
              ],
              colliders: [
                { dx: 0.027, dz: -0.034, r: 0.0489 },
                { dx: -0.012, dz: 0.029, r: 0.0238 },
                { dx: 0.049, dz: 0.052, r: 0.0237 },
                { dx: -0.045, dz: 0.054, r: 0.0175 },
                { dx: -0.029, dz: -0.05, r: 0.0133 }
              ]
            }
          ]
        }
      }
    ],
  },
  forest: {
    name: 'Forest Biome',
    borderMargin: 0.04, // UV margin on edges adjacent to a different biome
    generationRules: {
      // Each config defines exactly 1 hill formation covering ~half the region,
      // pushed against one of the 4 edges. Shape is rectangular or triangular, low.
      hills: {
        count: 1, // exactly 1 hill per config
        // The hill is pushed against one of the 4 edges and covers the
        // full width of that edge. Shape is either rectangular or triangular.
        //
        // Rectangular (shape:'rect'):
        //   Center (x,z) on the edge (e.g. x=0.5,z=0.0 for back edge)
        //   wx, wz = half-widths. The edge-parallel axis is wide (0.55-0.65)
        //   to cover the full edge. The depth axis is 0.35-0.50.
        //   height: 0.35-0.50 (moderate mound)
        //
        // Triangular (shape:'tri'):
        //   Corner (x,z) at a region corner (e.g. 0,0 or 1,1)
        //   wx, wz = extent from corner (0.70-0.90)
        //   dirX, dirZ = +1 or -1 indicating which direction the triangle extends
        //   height: 0.35-0.50
      },
      trees: {
        // RULE: All tree proximity/collision checks use the collider (colX, colZ, colR),
        // never the billboard anchor or billboard bounds. This applies to: overlap testing
        // during generation, spawn clearance, and player blocking at runtime.
        //
        // Generated via generateForestShape(), then baked to static data.
        // To create a new config: call generateForestShape(opts), copy the
        // returned array into the config as static data.
        generator: 'generateForestShape',
        seed: 'unique integer per config (e.g. 101, 202, 303)',
        frequency: { min: 2.5, max: 4.5 },   // noise scale â€” lower = larger patches
        threshold: { min: 0.12, max: 0.22 },  // noise cutoff â€” lower = denser forest
        density: { min: 35, max: 45 },         // noise sampling grid resolution (higher = more candidates = denser forest)
        octaves: { min: 1, max: 3 },           // fractal complexity
        margin: 0.1,                           // border margin in UV (must match biome margin)
        jitter: { min: 0.6, max: 0.9 },       // random offset from grid points
        // Variant baked per-tree at generation time via hash: floor((x*7919+z*6271)*1000) % 3
        // Per-variant collider radii: c3=0.24, c5=0.28, c7=0.38 (world units)
        // Per-variant margin: offset_magnitude + colR (see variantReachUV in generator)
        // Overlap: collider centers checked â€” min dist = (rA+rB) * 0.825 (allows ~17.5% penetration)
        // Billboard sizes: fir_cluster_3 = 0.65w, fir_cluster_5 = 0.85w, fir_cluster_7 = 1.32w
        // Each billboard represents 3/5/7 visual trees (avg 5)
        // Typical output: 22-66 placements per config (representing ~110-330 visual trees)
      },
      rocks: null,    // not yet defined
      minables: null, // not yet defined
      sticks: {
        // Generated via generateForestSticks(), then baked to static data.
        // To create: call generateForestSticks(opts) with config's trees array,
        // copy returned array into config as static data.
        generator: 'generateForestSticks',
        seed: 'unique integer per config (e.g. 1501, 1502)',
        count: { min: 4, max: 8 },            // target stick count (~6 per region)
        // Per-variant stick avoidance: (offset_magnitude + colR + STICK_PASSTHROUGH_RADIUS) / 10 + buffer
        // See STICK_AVOID_UV map for exact values per variant (0.082-0.123 UV)
        margin: 0.025,                         // border margin in UV
        stickMinDist: 0.04,                    // min UV distance between stick centers
        nearbyDist: 0.12,                      // UV radius for rotation similarity check
        minRotDiff: 'PI/4 (45 degrees)',       // min rotation diff for sticks within nearbyDist
        // Rotation constraint: nearby sticks (within nearbyDist UV) must differ
        //   by >= 45 degrees (mod 180 degrees, since 180 flip looks identical).
        //   Generator retries rotation up to 8 times per candidate; skips if no valid angle found.
        // Flip: ~50% of sticks get flip:1 (mirrors mesh on Z axis via negative scale,
        //   reversing fork direction for visual variety).
        // Output fields per stick: { x, z, rotY, flip }
        // Rendering: forked stick mesh (3 box prisms, 36 tris), scale 0.5 world units,
        //   warm brown with rock-style face shading. No physics collision.
        // Debug: passthrough collider shown as dotted cyan circle (STICK_PASSTHROUGH_RADIUS=0.22).
      },
    },
    treeVariants: ['fir_cluster_3', 'fir_cluster_5', 'fir_cluster_7'],
    configs: [
      {
        id: 'forest_1',
        seed: 201,
        terrain: {
          hills: [
            { shape: 'tri', x: 0, z: 0, wx: 0.8871930221095681, wz: 0.8123405234422534, dirX: 1, dirZ: 1, height: 0.39274723364505915 }
          ]
        },
        items: {
          trees: [
            { x: 0.053, z: 0.05, v: 'c3' },
            { x: 0.052, z: 0.409, v: 'c3' },
            { x: 0.075, z: 0.35, v: 'c3' },
            { x: 0.102, z: 0.438, v: 'c3' },
            { x: 0.096, z: 0.497, v: 'c5' },
            { x: 0.119, z: 0.594, v: 'c5' },
            { x: 0.122, z: 0.658, v: 'c3' },
            { x: 0.146, z: 0.188, v: 'c7' },
            { x: 0.138, z: 0.706, v: 'c3' },
            { x: 0.146, z: 0.831, v: 'c5' },
            { x: 0.171, z: 0.616, v: 'c3' },
            { x: 0.196, z: 0.15, v: 'c5' },
            { x: 0.182, z: 0.207, v: 'c3' },
            { x: 0.19, z: 0.884, v: 'c3' },
            { x: 0.184, z: 0.972, v: 'c5' },
            { x: 0.206, z: 0.516, v: 'c5' },
            { x: 0.239, z: 0.218, v: 'c5' },
            { x: 0.237, z: 0.283, v: 'c5' },
            { x: 0.228, z: 0.566, v: 'c3' },
            { x: 0.25, z: 0.08, v: 'c3' },
            { x: 0.258, z: 0.15, v: 'c3' },
            { x: 0.257, z: 0.609, v: 'c3' },
            { x: 0.25, z: 0.839, v: 'c5' },
            { x: 0.251, z: 0.926, v: 'c3' },
            { x: 0.26, z: 0.987, v: 'c3' },
            { x: 0.278, z: 0.548, v: 'c5' },
            { x: 0.307, z: 0.196, v: 'c5' },
            { x: 0.302, z: 0.276, v: 'c5' },
            { x: 0.3, z: 0.66, v: 'c5' },
            { x: 0.299, z: 0.877, v: 'c3' },
            { x: 0.302, z: 0.967, v: 'c3' },
            { x: 0.321, z: 0.077, v: 'c3' },
            { x: 0.329, z: 0.589, v: 'c3' },
            { x: 0.35, z: 0.706, v: 'c5' },
            { x: 0.371, z: 0.145, v: 'c3' },
            { x: 0.36, z: 0.41, v: 'c7' },
            { x: 0.373, z: 0.9, v: 'c5' },
            { x: 0.396, z: 0.373, v: 'c5' },
            { x: 0.39, z: 0.985, v: 'c5' },
            { x: 0.43, z: 0.317, v: 'c5' },
            { x: 0.45, z: 0.387, v: 'c3' },
            { x: 0.455, z: 0.967, v: 'c5' },
            { x: 0.499, z: 0.081, v: 'c3' },
            { x: 0.5, z: 0.25, v: 'c5' },
            { x: 0.499, z: 0.392, v: 'c3' },
            { x: 0.521, z: 0.478, v: 'c3' },
            { x: 0.548, z: 0.195, v: 'c7' },
            { x: 0.552, z: 0.259, v: 'c3' },
            { x: 0.546, z: 0.395, v: 'c3' },
            { x: 0.548, z: 0.52, v: 'c3' },
            { x: 0.548, z: 0.871, v: 'c7' },
            { x: 0.566, z: 0.306, v: 'c3' },
            { x: 0.567, z: 0.718, v: 'c3' },
            { x: 0.566, z: 0.79, v: 'c5' },
            { x: 0.591, z: 0.192, v: 'c3' },
            { x: 0.593, z: 0.457, v: 'c3' },
            { x: 0.596, z: 0.529, v: 'c3' },
            { x: 0.592, z: 0.899, v: 'c5' },
            { x: 0.614, z: 0.385, v: 'c5' },
            { x: 0.614, z: 0.747, v: 'c3' },
            { x: 0.64, z: 0.124, v: 'c5' },
            { x: 0.63, z: 0.563, v: 'c3' },
            { x: 0.639, z: 0.828, v: 'c5' },
            { x: 0.656, z: 0.417, v: 'c3' },
            { x: 0.65, z: 0.516, v: 'c3' },
            { x: 0.66, z: 0.939, v: 'c5' },
            { x: 0.684, z: 0.855, v: 'c3' },
            { x: 0.704, z: 0.127, v: 'c3' },
            { x: 0.699, z: 0.808, v: 'c5' },
            { x: 0.739, z: 0.081, v: 'c5' },
            { x: 0.747, z: 0.763, v: 'c3' },
            { x: 0.772, z: 0.144, v: 'c3' },
            { x: 0.763, z: 0.276, v: 'c5' },
            { x: 0.771, z: 0.896, v: 'c5' },
            { x: 0.79, z: 0.386, v: 'c5' },
            { x: 0.787, z: 0.606, v: 'c3' },
            { x: 0.796, z: 0.809, v: 'c5' },
            { x: 0.817, z: 0.516, v: 'c3' },
            { x: 0.817, z: 0.729, v: 'c5' },
            { x: 0.83, z: 0.629, v: 'c3' },
            { x: 0.835, z: 0.874, v: 'c5' },
            { x: 0.861, z: 0.074, v: 'c5' },
            { x: 0.856, z: 0.434, v: 'c3' },
            { x: 0.854, z: 0.569, v: 'c5' },
            { x: 0.856, z: 0.992, v: 'c3' },
            { x: 0.874, z: 0.493, v: 'c3' },
            { x: 0.883, z: 0.674, v: 'c5' },
            { x: 0.903, z: 0.119, v: 'c3' },
            { x: 0.903, z: 0.618, v: 'c3' },
            { x: 0.895, z: 0.92, v: 'c3' },
            { x: 0.921, z: 0.992, v: 'c3' },
            { x: 0.938, z: 0.062, v: 'c3' },
            { x: 0.948, z: 0.252, v: 'c5' },
            { x: 0.941, z: 0.542, v: 'c3' },
            { x: 0.947, z: 0.595, v: 'c3' },
            { x: 0.947, z: 0.679, v: 'c5' },
            { x: 0.967, z: 0.939, v: 'c5' },
            { x: 0.991, z: 0.121, v: 'c3' },
            { x: 0.982, z: 0.194, v: 'c5' },
            { x: 0.995, z: 0.304, v: 'c3' }
          ],
          rocks: [],
          sticks: [
            { x: 0.513, z: 0.638, rotY: 4.5, flip: 1, scale: 0.5 },
            { x: 0.063, z: 0.938, rotY: 0.03, flip: 1, scale: 0.5 },
            { x: 0.038, z: 0.763, rotY: 4.92, flip: 0, scale: 0.5 },
            { x: 0.413, z: 0.038, rotY: 1.47, flip: 0, scale: 0.5 },
            { x: 0.038, z: 0.713, rotY: 0.6, flip: 1, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_2',
        seed: 301,
        terrain: {
          hills: [
            { shape: 'tri', x: 0, z: 0, wx: 0.7739566719159483, wz: 0.8765344885643571, dirX: 1, dirZ: 1, height: 0.43759338587988167 }
          ]
        },
        items: {
          trees: [
            { x: 0.068, z: 0.065, v: 'c3' },
            { x: 0.069, z: 0.118, v: 'c3' },
            { x: 0.069, z: 0.27, v: 'c5' },
            { x: 0.068, z: 0.351, v: 'c3' },
            { x: 0.063, z: 0.513, v: 'c3' },
            { x: 0.072, z: 0.59, v: 'c3' },
            { x: 0.096, z: 0.706, v: 'c3' },
            { x: 0.128, z: 0.488, v: 'c3' },
            { x: 0.134, z: 0.566, v: 'c3' },
            { x: 0.117, z: 0.627, v: 'c3' },
            { x: 0.156, z: 0.106, v: 'c5' },
            { x: 0.159, z: 0.65, v: 'c3' },
            { x: 0.151, z: 0.813, v: 'c5' },
            { x: 0.16, z: 0.883, v: 'c5' },
            { x: 0.188, z: 0.261, v: 'c5' },
            { x: 0.19, z: 0.517, v: 'c3' },
            { x: 0.179, z: 0.758, v: 'c3' },
            { x: 0.201, z: 0.079, v: 'c3' },
            { x: 0.204, z: 0.326, v: 'c5' },
            { x: 0.216, z: 0.932, v: 'c5' },
            { x: 0.238, z: 0.487, v: 'c3' },
            { x: 0.228, z: 0.763, v: 'c3' },
            { x: 0.245, z: 0.853, v: 'c3' },
            { x: 0.261, z: 0.132, v: 'c3' },
            { x: 0.267, z: 0.288, v: 'c3' },
            { x: 0.287, z: 0.354, v: 'c5' },
            { x: 0.293, z: 0.715, v: 'c3' },
            { x: 0.287, z: 0.819, v: 'c3' },
            { x: 0.292, z: 0.98, v: 'c5' },
            { x: 0.319, z: 0.427, v: 'c3' },
            { x: 0.329, z: 0.494, v: 'c3' },
            { x: 0.319, z: 0.763, v: 'c3' },
            { x: 0.352, z: 0.126, v: 'c7' },
            { x: 0.346, z: 0.182, v: 'c5' },
            { x: 0.35, z: 0.377, v: 'c5' },
            { x: 0.35, z: 0.651, v: 'c3' },
            { x: 0.345, z: 0.716, v: 'c3' },
            { x: 0.342, z: 0.925, v: 'c3' },
            { x: 0.355, z: 0.979, v: 'c3' },
            { x: 0.382, z: 0.433, v: 'c3' },
            { x: 0.398, z: 0.12, v: 'c3' },
            { x: 0.412, z: 0.593, v: 'c3' },
            { x: 0.407, z: 0.689, v: 'c3' },
            { x: 0.397, z: 0.869, v: 'c3' },
            { x: 0.431, z: 0.186, v: 'c3' },
            { x: 0.428, z: 0.932, v: 'c5' },
            { x: 0.463, z: 0.127, v: 'c3' },
            { x: 0.45, z: 0.522, v: 'c3' },
            { x: 0.455, z: 0.65, v: 'c3' },
            { x: 0.46, z: 0.819, v: 'c3' },
            { x: 0.451, z: 0.87, v: 'c3' },
            { x: 0.485, z: 0.184, v: 'c3' },
            { x: 0.489, z: 0.486, v: 'c3' },
            { x: 0.506, z: 0.09, v: 'c3' },
            { x: 0.514, z: 0.549, v: 'c3' },
            { x: 0.52, z: 0.768, v: 'c5' },
            { x: 0.546, z: 0.146, v: 'c3' },
            { x: 0.54, z: 0.213, v: 'c3' },
            { x: 0.544, z: 0.487, v: 'c3' },
            { x: 0.534, z: 0.847, v: 'c3' },
            { x: 0.56, z: 0.075, v: 'c5' },
            { x: 0.573, z: 0.738, v: 'c3' },
            { x: 0.599, z: 0.187, v: 'c3' },
            { x: 0.598, z: 0.263, v: 'c3' },
            { x: 0.589, z: 0.326, v: 'c3' },
            { x: 0.601, z: 0.522, v: 'c5' },
            { x: 0.617, z: 0.075, v: 'c3' },
            { x: 0.624, z: 0.729, v: 'c3' },
            { x: 0.621, z: 0.783, v: 'c3' },
            { x: 0.618, z: 0.847, v: 'c3' },
            { x: 0.662, z: 0.217, v: 'c5' },
            { x: 0.646, z: 0.284, v: 'c3' },
            { x: 0.654, z: 0.367, v: 'c5' },
            { x: 0.678, z: 0.734, v: 'c3' },
            { x: 0.688, z: 0.881, v: 'c3' },
            { x: 0.713, z: 0.269, v: 'c3' },
            { x: 0.718, z: 0.398, v: 'c3' },
            { x: 0.715, z: 0.783, v: 'c3' },
            { x: 0.737, z: 0.352, v: 'c5' },
            { x: 0.73, z: 0.842, v: 'c3' },
            { x: 0.76, z: 0.237, v: 'c5' },
            { x: 0.756, z: 0.288, v: 'c3' },
            { x: 0.768, z: 0.455, v: 'c5' },
            { x: 0.768, z: 0.52, v: 'c5' },
            { x: 0.767, z: 0.715, v: 'c5' },
            { x: 0.77, z: 0.791, v: 'c3' },
            { x: 0.788, z: 0.105, v: 'c5' },
            { x: 0.785, z: 0.171, v: 'c5' },
            { x: 0.825, z: 0.483, v: 'c3' },
            { x: 0.813, z: 0.679, v: 'c3' },
            { x: 0.813, z: 0.745, v: 'c3' },
            { x: 0.85, z: 0.54, v: 'c3' },
            { x: 0.855, z: 0.792, v: 'c3' },
            { x: 0.882, z: 0.505, v: 'c3' },
            { x: 0.87, z: 0.672, v: 'c5' },
            { x: 0.898, z: 0.258, v: 'c7' },
            { x: 0.91, z: 0.744, v: 'c5' },
            { x: 0.909, z: 0.822, v: 'c5' },
            { x: 0.908, z: 0.926, v: 'c3' },
            { x: 0.912, z: 0.992, v: 'c3' },
            { x: 0.927, z: 0.206, v: 'c5' },
            { x: 0.93, z: 0.466, v: 'c7' },
            { x: 0.933, z: 0.52, v: 'c3' },
            { x: 0.961, z: 0.262, v: 'c3' },
            { x: 0.962, z: 0.327, v: 'c5' },
            { x: 0.965, z: 0.686, v: 'c3' },
            { x: 0.964, z: 0.963, v: 'c5' },
            { x: 0.984, z: 0.484, v: 'c3' },
            { x: 0.985, z: 0.74, v: 'c3' },
            { x: 0.98, z: 0.82, v: 'c5' }
          ],
          rocks: [],
          sticks: [
            { x: 0.488, z: 0.338, rotY: 5.36, flip: 0, scale: 0.5 },
            { x: 0.813, z: 0.913, rotY: 3.2, flip: 0, scale: 0.5 },
            { x: 0.613, z: 0.963, rotY: 2.61, flip: 0, scale: 0.5 },
            { x: 0.688, z: 0.613, rotY: 4.4, flip: 0, scale: 0.5 },
            { x: 0.588, z: 0.638, rotY: 2.96, flip: 1, scale: 0.5 },
            { x: 0.038, z: 0.888, rotY: 5.6, flip: 1, scale: 0.5 },
            { x: 0.563, z: 0.963, rotY: 0.73, flip: 1, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_3',
        seed: 401,
        terrain: {
          hills: [
            { shape: 'rect', x: 0.5, z: 1, wx: 0.576577125187032, wz: 0.36936311239842323, height: 0.40818128562532363 }
          ]
        },
        items: {
          trees: [
            { x: 0.064, z: 0.337, v: 'c3' },
            { x: 0.069, z: 0.958, v: 'c5' },
            { x: 0.099, z: 0.194, v: 'c5' },
            { x: 0.099, z: 0.831, v: 'c3' },
            { x: 0.111, z: 0.413, v: 'c3' },
            { x: 0.115, z: 0.639, v: 'c5' },
            { x: 0.119, z: 0.715, v: 'c5' },
            { x: 0.146, z: 0.836, v: 'c3' },
            { x: 0.146, z: 0.938, v: 'c3' },
            { x: 0.167, z: 0.439, v: 'c3' },
            { x: 0.17, z: 0.493, v: 'c3' },
            { x: 0.164, z: 0.674, v: 'c3' },
            { x: 0.197, z: 0.201, v: 'c5' },
            { x: 0.191, z: 0.9, v: 'c5' },
            { x: 0.228, z: 0.519, v: 'c3' },
            { x: 0.221, z: 0.751, v: 'c3' },
            { x: 0.227, z: 0.808, v: 'c3' },
            { x: 0.252, z: 0.143, v: 'c3' },
            { x: 0.253, z: 0.247, v: 'c3' },
            { x: 0.245, z: 0.857, v: 'c3' },
            { x: 0.282, z: 0.205, v: 'c3' },
            { x: 0.284, z: 0.824, v: 'c3' },
            { x: 0.304, z: 0.154, v: 'c3' },
            { x: 0.329, z: 0.197, v: 'c3' },
            { x: 0.358, z: 0.145, v: 'c3' },
            { x: 0.36, z: 0.429, v: 'c5' },
            { x: 0.354, z: 0.488, v: 'c3' },
            { x: 0.354, z: 0.59, v: 'c7' },
            { x: 0.379, z: 0.09, v: 'c5' },
            { x: 0.39, z: 0.624, v: 'c3' },
            { x: 0.416, z: 0.468, v: 'c3' },
            { x: 0.41, z: 0.572, v: 'c3' },
            { x: 0.404, z: 0.703, v: 'c5' },
            { x: 0.417, z: 0.917, v: 'c5' },
            { x: 0.434, z: 0.415, v: 'c3' },
            { x: 0.442, z: 0.768, v: 'c5' },
            { x: 0.432, z: 0.969, v: 'c3' },
            { x: 0.462, z: 0.229, v: 'c5' },
            { x: 0.457, z: 0.336, v: 'c5' },
            { x: 0.493, z: 0.18, v: 'c5' },
            { x: 0.49, z: 0.277, v: 'c3' },
            { x: 0.491, z: 0.887, v: 'c7' },
            { x: 0.518, z: 0.484, v: 'c3' },
            { x: 0.536, z: 0.326, v: 'c5' },
            { x: 0.532, z: 0.407, v: 'c3' },
            { x: 0.533, z: 0.889, v: 'c3' },
            { x: 0.561, z: 0.12, v: 'c3' },
            { x: 0.57, z: 0.199, v: 'c5' },
            { x: 0.595, z: 0.083, v: 'c3' },
            { x: 0.587, z: 0.495, v: 'c5' },
            { x: 0.59, z: 0.616, v: 'c5' },
            { x: 0.59, z: 0.699, v: 'c5' },
            { x: 0.585, z: 0.856, v: 'c5' },
            { x: 0.598, z: 0.908, v: 'c3' },
            { x: 0.644, z: 0.117, v: 'c3' },
            { x: 0.638, z: 0.439, v: 'c5' },
            { x: 0.644, z: 0.586, v: 'c5' },
            { x: 0.654, z: 0.951, v: 'c3' },
            { x: 0.672, z: 0.906, v: 'c3' },
            { x: 0.693, z: 0.126, v: 'c3' },
            { x: 0.704, z: 0.285, v: 'c3' },
            { x: 0.7, z: 0.386, v: 'c3' },
            { x: 0.704, z: 0.838, v: 'c3' },
            { x: 0.733, z: 0.942, v: 'c3' },
            { x: 0.742, z: 0.223, v: 'c3' },
            { x: 0.778, z: 0.804, v: 'c3' },
            { x: 0.772, z: 0.884, v: 'c3' },
            { x: 0.802, z: 0.072, v: 'c3' },
            { x: 0.809, z: 0.678, v: 'c7' },
            { x: 0.831, z: 0.113, v: 'c3' },
            { x: 0.836, z: 0.691, v: 'c3' },
            { x: 0.836, z: 0.85, v: 'c3' },
            { x: 0.836, z: 0.903, v: 'c3' },
            { x: 0.852, z: 0.218, v: 'c3' },
            { x: 0.861, z: 0.596, v: 'c3' },
            { x: 0.888, z: 0.27, v: 'c5' },
            { x: 0.879, z: 0.664, v: 'c3' },
            { x: 0.885, z: 0.719, v: 'c3' },
            { x: 0.886, z: 0.909, v: 'c3' },
            { x: 0.912, z: 0.327, v: 'c3' },
            { x: 0.903, z: 0.428, v: 'c5' },
            { x: 0.912, z: 0.508, v: 'c5' },
            { x: 0.906, z: 0.622, v: 'c3' },
            { x: 0.902, z: 0.862, v: 'c3' },
            { x: 0.929, z: 0.231, v: 'c3' },
            { x: 0.943, z: 0.388, v: 'c5' },
            { x: 0.939, z: 0.665, v: 'c3' },
            { x: 0.928, z: 0.748, v: 'c3' },
            { x: 0.963, z: 0.464, v: 'c5' },
            { x: 0.979, z: 0.611, v: 'c5' }
          ],
          rocks: [],
          sticks: [
            { x: 0.038, z: 0.538, rotY: 0.35, flip: 1, scale: 0.5 },
            { x: 0.113, z: 0.063, rotY: 5.64, flip: 0, scale: 0.5 },
            { x: 0.913, z: 0.038, rotY: 3.21, flip: 0, scale: 0.5 },
            { x: 0.163, z: 0.063, rotY: 1.12, flip: 0, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_4',
        seed: 501,
        terrain: {
          hills: [
            { shape: 'rect', x: 0, z: 0.5, wx: 0.4380111616221256, wz: 0.5928061764221639, height: 0.4732540229801088 }
          ]
        },
        items: {
          trees: [
            { x: 0.066, z: 0.063, v: 'c3' },
            { x: 0.062, z: 0.141, v: 'c3' },
            { x: 0.066, z: 0.192, v: 'c3' },
            { x: 0.066, z: 0.241, v: 'c3' },
            { x: 0.071, z: 0.312, v: 'c3' },
            { x: 0.061, z: 0.46, v: 'c3' },
            { x: 0.056, z: 0.578, v: 'c3' },
            { x: 0.066, z: 0.857, v: 'c5' },
            { x: 0.069, z: 0.931, v: 'c5' },
            { x: 0.086, z: 0.389, v: 'c5' },
            { x: 0.109, z: 0.094, v: 'c3' },
            { x: 0.121, z: 0.293, v: 'c5' },
            { x: 0.115, z: 0.434, v: 'c3' },
            { x: 0.121, z: 0.481, v: 'c3' },
            { x: 0.135, z: 0.16, v: 'c3' },
            { x: 0.13, z: 0.22, v: 'c3' },
            { x: 0.137, z: 0.958, v: 'c3' },
            { x: 0.159, z: 0.386, v: 'c3' },
            { x: 0.168, z: 0.481, v: 'c3' },
            { x: 0.186, z: 0.06, v: 'c3' },
            { x: 0.186, z: 0.166, v: 'c3' },
            { x: 0.193, z: 0.231, v: 'c5' },
            { x: 0.212, z: 0.69, v: 'c7' },
            { x: 0.243, z: 0.066, v: 'c3' },
            { x: 0.244, z: 0.682, v: 'c3' },
            { x: 0.23, z: 0.84, v: 'c7' },
            { x: 0.267, z: 0.807, v: 'c3' },
            { x: 0.255, z: 0.881, v: 'c5' },
            { x: 0.258, z: 0.965, v: 'c3' },
            { x: 0.284, z: 0.758, v: 'c3' },
            { x: 0.307, z: 0.394, v: 'c3' },
            { x: 0.304, z: 0.691, v: 'c3' },
            { x: 0.322, z: 0.858, v: 'c3' },
            { x: 0.346, z: 0.343, v: 'c7' },
            { x: 0.346, z: 0.437, v: 'c3' },
            { x: 0.339, z: 0.779, v: 'c3' },
            { x: 0.343, z: 0.946, v: 'c5' },
            { x: 0.38, z: 0.065, v: 'c5' },
            { x: 0.394, z: 0.189, v: 'c5' },
            { x: 0.381, z: 0.356, v: 'c3' },
            { x: 0.389, z: 0.419, v: 'c3' },
            { x: 0.415, z: 0.117, v: 'c3' },
            { x: 0.411, z: 0.313, v: 'c5' },
            { x: 0.42, z: 0.966, v: 'c5' },
            { x: 0.438, z: 0.372, v: 'c3' },
            { x: 0.46, z: 0.063, v: 'c3' },
            { x: 0.456, z: 0.142, v: 'c3' },
            { x: 0.491, z: 0.341, v: 'c3' },
            { x: 0.486, z: 0.414, v: 'c3' },
            { x: 0.516, z: 0.089, v: 'c3' },
            { x: 0.533, z: 0.313, v: 'c3' },
            { x: 0.537, z: 0.396, v: 'c5' },
            { x: 0.594, z: 0.859, v: 'c7' },
            { x: 0.582, z: 0.916, v: 'c5' },
            { x: 0.647, z: 0.807, v: 'c7' },
            { x: 0.631, z: 0.872, v: 'c3' },
            { x: 0.663, z: 0.712, v: 'c7' },
            { x: 0.666, z: 0.837, v: 'c3' },
            { x: 0.656, z: 0.93, v: 'c3' },
            { x: 0.692, z: 0.465, v: 'c7' },
            { x: 0.695, z: 0.661, v: 'c3' },
            { x: 0.68, z: 0.77, v: 'c3' },
            { x: 0.72, z: 0.085, v: 'c5' },
            { x: 0.722, z: 0.41, v: 'c5' },
            { x: 0.717, z: 0.482, v: 'c3' },
            { x: 0.713, z: 0.714, v: 'c3' },
            { x: 0.715, z: 0.888, v: 'c5' },
            { x: 0.717, z: 0.962, v: 'c5' },
            { x: 0.743, z: 0.167, v: 'c5' },
            { x: 0.745, z: 0.77, v: 'c5' },
            { x: 0.755, z: 0.681, v: 'c5' },
            { x: 0.764, z: 0.865, v: 'c3' },
            { x: 0.79, z: 0.19, v: 'c3' },
            { x: 0.79, z: 0.397, v: 'c3' },
            { x: 0.781, z: 0.49, v: 'c5' },
            { x: 0.812, z: 0.104, v: 'c5' },
            { x: 0.818, z: 0.662, v: 'c5' },
            { x: 0.804, z: 0.719, v: 'c3' },
            { x: 0.816, z: 0.781, v: 'c3' },
            { x: 0.808, z: 0.835, v: 'c3' },
            { x: 0.818, z: 0.888, v: 'c3' },
            { x: 0.836, z: 0.309, v: 'c3' },
            { x: 0.832, z: 0.358, v: 'c3' },
            { x: 0.842, z: 0.42, v: 'c3' },
            { x: 0.846, z: 0.496, v: 'c3' },
            { x: 0.857, z: 0.169, v: 'c3' },
            { x: 0.856, z: 0.816, v: 'c3' },
            { x: 0.888, z: 0.466, v: 'c5' },
            { x: 0.887, z: 0.742, v: 'c5' },
            { x: 0.921, z: 0.129, v: 'c5' },
            { x: 0.915, z: 0.412, v: 'c5' },
            { x: 0.906, z: 0.792, v: 'c3' },
            { x: 0.961, z: 0.618, v: 'c3' },
            { x: 0.966, z: 0.768, v: 'c5' },
            { x: 0.99, z: 0.662, v: 'c3' }
          ],
          rocks: [],
          sticks: [
            { x: 0.488, z: 0.638, rotY: 6.13, flip: 0, scale: 0.5 },
            { x: 0.913, z: 0.938, rotY: 0.94, flip: 0, scale: 0.5 },
            { x: 0.538, z: 0.213, rotY: 0.77, flip: 0, scale: 0.5 },
            { x: 0.638, z: 0.263, rotY: 2.74, flip: 0, scale: 0.5 },
            { x: 0.438, z: 0.663, rotY: 4.98, flip: 1, scale: 0.5 },
            { x: 0.613, z: 0.138, rotY: 5.98, flip: 0, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_5',
        seed: 601,
        terrain: {
          hills: [
            { shape: 'tri', x: 1, z: 1, wx: 0.8679570728912949, wz: 0.8939679773058742, dirX: -1, dirZ: -1, height: 0.49597899115178734 }
          ]
        },
        items: {
          trees: [
            { x: 0.058, z: 0.837, v: 'c3' },
            { x: 0.066, z: 0.938, v: 'c5' },
            { x: 0.087, z: 0.13, v: 'c5' },
            { x: 0.078, z: 0.224, v: 'c5' },
            { x: 0.106, z: 0.306, v: 'c3' },
            { x: 0.111, z: 0.376, v: 'c3' },
            { x: 0.109, z: 0.896, v: 'c5' },
            { x: 0.137, z: 0.465, v: 'c5' },
            { x: 0.163, z: 0.206, v: 'c3' },
            { x: 0.158, z: 0.266, v: 'c5' },
            { x: 0.164, z: 0.349, v: 'c5' },
            { x: 0.182, z: 0.434, v: 'c3' },
            { x: 0.184, z: 0.678, v: 'c5' },
            { x: 0.211, z: 0.491, v: 'c3' },
            { x: 0.205, z: 0.896, v: 'c7' },
            { x: 0.217, z: 0.225, v: 'c3' },
            { x: 0.228, z: 0.346, v: 'c3' },
            { x: 0.227, z: 0.563, v: 'c3' },
            { x: 0.233, z: 0.629, v: 'c3' },
            { x: 0.255, z: 0.512, v: 'c3' },
            { x: 0.246, z: 0.734, v: 'c5' },
            { x: 0.253, z: 0.874, v: 'c5' },
            { x: 0.28, z: 0.271, v: 'c5' },
            { x: 0.266, z: 0.434, v: 'c5' },
            { x: 0.279, z: 0.601, v: 'c3' },
            { x: 0.306, z: 0.486, v: 'c3' },
            { x: 0.306, z: 0.867, v: 'c3' },
            { x: 0.322, z: 0.388, v: 'c5' },
            { x: 0.326, z: 0.541, v: 'c3' },
            { x: 0.322, z: 0.648, v: 'c5' },
            { x: 0.325, z: 0.915, v: 'c3' },
            { x: 0.336, z: 0.242, v: 'c3' },
            { x: 0.351, z: 0.456, v: 'c3' },
            { x: 0.345, z: 0.592, v: 'c3' },
            { x: 0.339, z: 0.966, v: 'c3' },
            { x: 0.399, z: 0.447, v: 'c3' },
            { x: 0.387, z: 0.494, v: 'c3' },
            { x: 0.395, z: 0.609, v: 'c3' },
            { x: 0.39, z: 0.913, v: 'c3' },
            { x: 0.45, z: 0.538, v: 'c3' },
            { x: 0.461, z: 0.09, v: 'c5' },
            { x: 0.531, z: 0.053, v: 'c3' },
            { x: 0.536, z: 0.917, v: 'c5' },
            { x: 0.557, z: 0.112, v: 'c5' },
            { x: 0.59, z: 0.483, v: 'c3' },
            { x: 0.581, z: 0.983, v: 'c5' },
            { x: 0.614, z: 0.871, v: 'c5' },
            { x: 0.628, z: 0.091, v: 'c5' },
            { x: 0.634, z: 0.448, v: 'c5' },
            { x: 0.636, z: 0.506, v: 'c3' },
            { x: 0.639, z: 0.59, v: 'c5' },
            { x: 0.622, z: 0.933, v: 'c3' },
            { x: 0.68, z: 0.411, v: 'c3' },
            { x: 0.676, z: 0.483, v: 'c3' },
            { x: 0.686, z: 0.553, v: 'c5' },
            { x: 0.681, z: 0.657, v: 'c5' },
            { x: 0.686, z: 0.846, v: 'c5' },
            { x: 0.67, z: 0.92, v: 'c3' },
            { x: 0.727, z: 0.327, v: 'c7' },
            { x: 0.735, z: 0.443, v: 'c3' },
            { x: 0.721, z: 0.508, v: 'c3' },
            { x: 0.729, z: 0.588, v: 'c3' },
            { x: 0.729, z: 0.9, v: 'c5' },
            { x: 0.746, z: 0.374, v: 'c3' },
            { x: 0.768, z: 0.324, v: 'c3' },
            { x: 0.78, z: 0.482, v: 'c3' },
            { x: 0.774, z: 0.674, v: 'c3' },
            { x: 0.807, z: 0.386, v: 'c3' },
            { x: 0.795, z: 0.433, v: 'c3' },
            { x: 0.801, z: 0.557, v: 'c5' },
            { x: 0.802, z: 0.626, v: 'c3' },
            { x: 0.798, z: 0.923, v: 'c3' },
            { x: 0.827, z: 0.99, v: 'c5' },
            { x: 0.85, z: 0.63, v: 'c3' },
            { x: 0.877, z: 0.798, v: 'c7' },
            { x: 0.874, z: 0.878, v: 'c3' },
            { x: 0.875, z: 0.96, v: 'c5' },
            { x: 0.887, z: 0.587, v: 'c5' },
            { x: 0.913, z: 0.155, v: 'c5' },
            { x: 0.943, z: 0.758, v: 'c3' },
            { x: 0.944, z: 0.968, v: 'c3' },
            { x: 0.972, z: 0.086, v: 'c5' },
            { x: 0.962, z: 0.711, v: 'c3' },
            { x: 0.993, z: 0.171, v: 'c3' },
            { x: 0.985, z: 0.613, v: 'c3' }
          ],
          rocks: [],
          sticks: [
            { x: 0.463, z: 0.713, rotY: 4.09, flip: 1, scale: 0.5 },
            { x: 0.188, z: 0.038, rotY: 0.76, flip: 0, scale: 0.5 },
            { x: 0.388, z: 0.788, rotY: 4.9, flip: 0, scale: 0.5 },
            { x: 0.438, z: 0.763, rotY: 5.75, flip: 0, scale: 0.5 },
            { x: 0.538, z: 0.288, rotY: 5.69, flip: 0, scale: 0.5 },
            { x: 0.438, z: 0.213, rotY: 1.44, flip: 0, scale: 0.5 },
            { x: 0.863, z: 0.038, rotY: 4.27, flip: 1, scale: 0.5 },
            { x: 0.063, z: 0.638, rotY: 0.37, flip: 0, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_6',
        seed: 701,
        terrain: {
          hills: [
            { shape: 'rect', x: 1, z: 0.5, wx: 0.39362145682098343, wz: 0.57721676225774, height: 0.3910405420232564 }
          ]
        },
        items: {
          trees: [
            { x: 0.054, z: 0.395, v: 'c3' },
            { x: 0.052, z: 0.533, v: 'c3' },
            { x: 0.063, z: 0.64, v: 'c3' },
            { x: 0.073, z: 0.33, v: 'c5' },
            { x: 0.083, z: 0.471, v: 'c5' },
            { x: 0.088, z: 0.701, v: 'c5' },
            { x: 0.082, z: 0.884, v: 'c5' },
            { x: 0.1, z: 0.56, v: 'c3' },
            { x: 0.128, z: 0.641, v: 'c5' },
            { x: 0.123, z: 0.757, v: 'c3' },
            { x: 0.128, z: 0.847, v: 'c5' },
            { x: 0.152, z: 0.717, v: 'c3' },
            { x: 0.178, z: 0.618, v: 'c3' },
            { x: 0.199, z: 0.086, v: 'c3' },
            { x: 0.201, z: 0.161, v: 'c5' },
            { x: 0.192, z: 0.76, v: 'c3' },
            { x: 0.184, z: 0.811, v: 'c3' },
            { x: 0.208, z: 0.246, v: 'c5' },
            { x: 0.222, z: 0.652, v: 'c3' },
            { x: 0.218, z: 0.877, v: 'c3' },
            { x: 0.246, z: 0.053, v: 'c3' },
            { x: 0.243, z: 0.286, v: 'c3' },
            { x: 0.247, z: 0.695, v: 'c3' },
            { x: 0.246, z: 0.765, v: 'c3' },
            { x: 0.261, z: 0.165, v: 'c3' },
            { x: 0.288, z: 0.101, v: 'c5' },
            { x: 0.28, z: 0.236, v: 'c5' },
            { x: 0.288, z: 0.422, v: 'c7' },
            { x: 0.276, z: 0.808, v: 'c3' },
            { x: 0.286, z: 0.874, v: 'c5' },
            { x: 0.311, z: 0.162, v: 'c3' },
            { x: 0.301, z: 0.473, v: 'c3' },
            { x: 0.316, z: 0.69, v: 'c3' },
            { x: 0.3, z: 0.736, v: 'c3' },
            { x: 0.331, z: 0.217, v: 'c3' },
            { x: 0.339, z: 0.42, v: 'c3' },
            { x: 0.322, z: 0.793, v: 'c3' },
            { x: 0.337, z: 0.858, v: 'c3' },
            { x: 0.348, z: 0.105, v: 'c3' },
            { x: 0.359, z: 0.471, v: 'c3' },
            { x: 0.377, z: 0.193, v: 'c5' },
            { x: 0.38, z: 0.663, v: 'c3' },
            { x: 0.378, z: 0.741, v: 'c5' },
            { x: 0.381, z: 0.801, v: 'c3' },
            { x: 0.406, z: 0.102, v: 'c3' },
            { x: 0.397, z: 0.395, v: 'c5' },
            { x: 0.415, z: 0.46, v: 'c5' },
            { x: 0.427, z: 0.767, v: 'c3' },
            { x: 0.445, z: 0.133, v: 'c3' },
            { x: 0.436, z: 0.695, v: 'c3' },
            { x: 0.443, z: 0.813, v: 'c3' },
            { x: 0.463, z: 0.194, v: 'c3' },
            { x: 0.473, z: 0.418, v: 'c3' },
            { x: 0.493, z: 0.692, v: 'c3' },
            { x: 0.488, z: 0.757, v: 'c5' },
            { x: 0.496, z: 0.809, v: 'c3' },
            { x: 0.517, z: 0.647, v: 'c5' },
            { x: 0.552, z: 0.687, v: 'c3' },
            { x: 0.565, z: 0.757, v: 'c5' },
            { x: 0.572, z: 0.595, v: 'c7' },
            { x: 0.57, z: 0.643, v: 'c3' },
            { x: 0.611, z: 0.597, v: 'c3' },
            { x: 0.623, z: 0.537, v: 'c5' },
            { x: 0.622, z: 0.654, v: 'c3' },
            { x: 0.633, z: 0.717, v: 'c5' },
            { x: 0.633, z: 0.786, v: 'c3' },
            { x: 0.649, z: 0.143, v: 'c7' },
            { x: 0.677, z: 0.153, v: 'c3' },
            { x: 0.668, z: 0.235, v: 'c3' },
            { x: 0.662, z: 0.313, v: 'c7' },
            { x: 0.667, z: 0.36, v: 'c3' },
            { x: 0.669, z: 0.416, v: 'c3' },
            { x: 0.674, z: 0.482, v: 'c3' },
            { x: 0.67, z: 0.571, v: 'c3' },
            { x: 0.669, z: 0.618, v: 'c3' },
            { x: 0.698, z: 0.525, v: 'c3' },
            { x: 0.689, z: 0.688, v: 'c5' },
            { x: 0.694, z: 0.742, v: 'c3' },
            { x: 0.72, z: 0.08, v: 'c5' },
            { x: 0.719, z: 0.212, v: 'c5' },
            { x: 0.717, z: 0.333, v: 'c5' },
            { x: 0.716, z: 0.946, v: 'c5' },
            { x: 0.74, z: 0.429, v: 'c5' },
            { x: 0.747, z: 0.508, v: 'c3' },
            { x: 0.731, z: 0.593, v: 'c5' },
            { x: 0.76, z: 0.17, v: 'c5' },
            { x: 0.765, z: 0.278, v: 'c3' },
            { x: 0.768, z: 0.629, v: 'c3' },
            { x: 0.785, z: 0.086, v: 'c3' },
            { x: 0.787, z: 0.235, v: 'c3' },
            { x: 0.793, z: 0.329, v: 'c3' },
            { x: 0.788, z: 0.402, v: 'c3' },
            { x: 0.784, z: 0.537, v: 'c3' },
            { x: 0.791, z: 0.688, v: 'c5' },
            { x: 0.781, z: 0.925, v: 'c3' },
            { x: 0.816, z: 0.148, v: 'c5' },
            { x: 0.812, z: 0.28, v: 'c3' },
            { x: 0.803, z: 0.468, v: 'c3' },
            { x: 0.836, z: 0.212, v: 'c5' },
            { x: 0.836, z: 0.349, v: 'c3' },
            { x: 0.833, z: 0.429, v: 'c3' },
            { x: 0.836, z: 0.981, v: 'c3' },
            { x: 0.853, z: 0.904, v: 'c3' },
            { x: 0.879, z: 0.169, v: 'c3' },
            { x: 0.869, z: 0.282, v: 'c5' },
            { x: 0.881, z: 0.394, v: 'c3' },
            { x: 0.884, z: 0.668, v: 'c5' },
            { x: 0.9, z: 0.929, v: 'c3' },
            { x: 0.924, z: 0.714, v: 'c3' },
            { x: 0.911, z: 0.859, v: 'c7' },
            { x: 0.947, z: 0.645, v: 'c3' },
            { x: 0.94, z: 0.768, v: 'c3' },
            { x: 0.935, z: 0.966, v: 'c3' },
            { x: 0.97, z: 0.81, v: 'c3' },
            { x: 0.982, z: 0.603, v: 'c5' },
            { x: 0.986, z: 0.674, v: 'c3' },
            { x: 0.986, z: 0.74, v: 'c5' }
          ],
          rocks: [],
          sticks: [
            { x: 0.613, z: 0.888, rotY: 0.26, flip: 0, scale: 0.5 },
            { x: 0.438, z: 0.938, rotY: 3.01, flip: 0, scale: 0.5 },
            { x: 0.513, z: 0.913, rotY: 1.96, flip: 1, scale: 0.5 },
            { x: 0.088, z: 0.163, rotY: 5.36, flip: 1, scale: 0.5 },
            { x: 0.038, z: 0.163, rotY: 0.54, flip: 1, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_7',
        seed: 801,
        terrain: {
          hills: [
            { shape: 'rect', x: 0, z: 0.5, wx: 0.4705308713717386, wz: 0.5727201594272628, height: 0.3645907001220621 }
          ]
        },
        items: {
          trees: [
            { x: 0.055, z: 0.953, v: 'c3' },
            { x: 0.064, z: 0.731, v: 'c5' },
            { x: 0.069, z: 0.797, v: 'c5' },
            { x: 0.105, z: 0.462, v: 'c3' },
            { x: 0.1, z: 0.531, v: 'c3' },
            { x: 0.108, z: 0.902, v: 'c3' },
            { x: 0.197, z: 0.15, v: 'c3' },
            { x: 0.221, z: 0.906, v: 'c5' },
            { x: 0.246, z: 0.215, v: 'c5' },
            { x: 0.233, z: 0.281, v: 'c5' },
            { x: 0.248, z: 0.365, v: 'c5' },
            { x: 0.246, z: 0.649, v: 'c3' },
            { x: 0.279, z: 0.725, v: 'c3' },
            { x: 0.275, z: 0.808, v: 'c3' },
            { x: 0.279, z: 0.863, v: 'c3' },
            { x: 0.31, z: 0.207, v: 'c3' },
            { x: 0.297, z: 0.293, v: 'c3' },
            { x: 0.304, z: 0.386, v: 'c3' },
            { x: 0.305, z: 0.609, v: 'c7' },
            { x: 0.308, z: 0.674, v: 'c5' },
            { x: 0.325, z: 0.752, v: 'c3' },
            { x: 0.332, z: 0.923, v: 'c3' },
            { x: 0.351, z: 0.325, v: 'c5' },
            { x: 0.351, z: 0.553, v: 'c7' },
            { x: 0.353, z: 0.615, v: 'c3' },
            { x: 0.36, z: 0.784, v: 'c3' },
            { x: 0.394, z: 0.671, v: 'c3' },
            { x: 0.391, z: 0.924, v: 'c5' },
            { x: 0.425, z: 0.081, v: 'c3' },
            { x: 0.417, z: 0.593, v: 'c3' },
            { x: 0.41, z: 0.718, v: 'c3' },
            { x: 0.41, z: 0.977, v: 'c3' },
            { x: 0.445, z: 0.482, v: 'c5' },
            { x: 0.471, z: 0.105, v: 'c3' },
            { x: 0.477, z: 0.911, v: 'c5' },
            { x: 0.499, z: 0.454, v: 'c3' },
            { x: 0.53, z: 0.073, v: 'c3' },
            { x: 0.538, z: 0.397, v: 'c5' },
            { x: 0.519, z: 0.709, v: 'c7' },
            { x: 0.559, z: 0.666, v: 'c5' },
            { x: 0.565, z: 0.734, v: 'c5' },
            { x: 0.597, z: 0.33, v: 'c3' },
            { x: 0.579, z: 0.455, v: 'c5' },
            { x: 0.62, z: 0.128, v: 'c3' },
            { x: 0.619, z: 0.421, v: 'c3' },
            { x: 0.625, z: 0.719, v: 'c5' },
            { x: 0.606, z: 0.98, v: 'c5' },
            { x: 0.655, z: 0.252, v: 'c5' },
            { x: 0.644, z: 0.347, v: 'c3' },
            { x: 0.637, z: 0.786, v: 'c5' },
            { x: 0.674, z: 0.159, v: 'c3' },
            { x: 0.706, z: 0.073, v: 'c3' },
            { x: 0.694, z: 0.31, v: 'c5' },
            { x: 0.699, z: 0.612, v: 'c5' },
            { x: 0.691, z: 0.779, v: 'c3' },
            { x: 0.706, z: 0.982, v: 'c5' },
            { x: 0.733, z: 0.182, v: 'c3' },
            { x: 0.74, z: 0.265, v: 'c5' },
            { x: 0.751, z: 0.106, v: 'c3' },
            { x: 0.764, z: 0.309, v: 'c3' },
            { x: 0.768, z: 0.934, v: 'c5' },
            { x: 0.765, z: 0.991, v: 'c3' },
            { x: 0.796, z: 0.216, v: 'c3' },
            { x: 0.783, z: 0.469, v: 'c5' },
            { x: 0.789, z: 0.524, v: 'c3' },
            { x: 0.822, z: 0.317, v: 'c3' },
            { x: 0.821, z: 0.588, v: 'c3' },
            { x: 0.847, z: 0.495, v: 'c5' },
            { x: 0.845, z: 0.643, v: 'c3' },
            { x: 0.844, z: 0.89, v: 'c7' },
            { x: 0.867, z: 0.592, v: 'c3' },
            { x: 0.868, z: 0.929, v: 'c3' },
            { x: 0.896, z: 0.969, v: 'c3' },
            { x: 0.924, z: 0.587, v: 'c3' },
            { x: 0.957, z: 0.163, v: 'c7' },
            { x: 0.955, z: 0.925, v: 'c5' },
            { x: 0.99, z: 0.118, v: 'c3' }
          ],
          rocks: [],
          sticks: [
            { x: 0.138, z: 0.038, rotY: 3.84, flip: 1, scale: 0.5 },
            { x: 0.113, z: 0.338, rotY: 3.17, flip: 1, scale: 0.5 },
            { x: 0.288, z: 0.038, rotY: 5.15, flip: 1, scale: 0.5 },
            { x: 0.938, z: 0.413, rotY: 3.7, flip: 0, scale: 0.5 },
            { x: 0.113, z: 0.238, rotY: 2.35, flip: 1, scale: 0.5 },
            { x: 0.063, z: 0.138, rotY: 3.32, flip: 0, scale: 0.5 },
            { x: 0.113, z: 0.288, rotY: 4.43, flip: 1, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_8',
        seed: 901,
        terrain: {
          hills: [
            { shape: 'rect', x: 0, z: 0.5, wx: 0.3686763452133164, wz: 0.6026175942504779, height: 0.4296634374768473 }
          ]
        },
        items: {
          trees: [
            { x: 0.078, z: 0.094, v: 'c5' },
            { x: 0.069, z: 0.479, v: 'c5' },
            { x: 0.068, z: 0.911, v: 'c5' },
            { x: 0.07, z: 0.988, v: 'c3' },
            { x: 0.13, z: 0.148, v: 'c3' },
            { x: 0.129, z: 0.338, v: 'c3' },
            { x: 0.131, z: 0.554, v: 'c3' },
            { x: 0.126, z: 0.967, v: 'c5' },
            { x: 0.147, z: 0.103, v: 'c3' },
            { x: 0.147, z: 0.382, v: 'c3' },
            { x: 0.15, z: 0.467, v: 'c3' },
            { x: 0.181, z: 0.651, v: 'c3' },
            { x: 0.187, z: 0.697, v: 'c3' },
            { x: 0.202, z: 0.073, v: 'c3' },
            { x: 0.214, z: 0.313, v: 'c3' },
            { x: 0.209, z: 0.376, v: 'c3' },
            { x: 0.209, z: 0.429, v: 'c3' },
            { x: 0.2, z: 0.51, v: 'c3' },
            { x: 0.221, z: 0.268, v: 'c7' },
            { x: 0.234, z: 0.571, v: 'c3' },
            { x: 0.241, z: 0.636, v: 'c5' },
            { x: 0.232, z: 0.717, v: 'c3' },
            { x: 0.257, z: 0.279, v: 'c3' },
            { x: 0.251, z: 0.77, v: 'c3' },
            { x: 0.267, z: 0.833, v: 'c3' },
            { x: 0.284, z: 0.143, v: 'c5' },
            { x: 0.293, z: 0.364, v: 'c3' },
            { x: 0.292, z: 0.687, v: 'c5' },
            { x: 0.304, z: 0.301, v: 'c3' },
            { x: 0.317, z: 0.426, v: 'c3' },
            { x: 0.316, z: 0.971, v: 'c7' },
            { x: 0.34, z: 0.381, v: 'c3' },
            { x: 0.342, z: 0.739, v: 'c5' },
            { x: 0.374, z: 0.07, v: 'c3' },
            { x: 0.368, z: 0.644, v: 'c7' },
            { x: 0.399, z: 0.425, v: 'c5' },
            { x: 0.403, z: 0.561, v: 'c3' },
            { x: 0.429, z: 0.118, v: 'c3' },
            { x: 0.424, z: 0.505, v: 'c5' },
            { x: 0.425, z: 0.603, v: 'c3' },
            { x: 0.428, z: 0.658, v: 'c3' },
            { x: 0.419, z: 0.981, v: 'c5' },
            { x: 0.447, z: 0.068, v: 'c3' },
            { x: 0.485, z: 0.63, v: 'c5' },
            { x: 0.499, z: 0.525, v: 'c3' },
            { x: 0.531, z: 0.318, v: 'c7' },
            { x: 0.537, z: 0.619, v: 'c3' },
            { x: 0.56, z: 0.112, v: 'c5' },
            { x: 0.555, z: 0.359, v: 'c3' },
            { x: 0.553, z: 0.687, v: 'c3' },
            { x: 0.575, z: 0.3, v: 'c3' },
            { x: 0.586, z: 0.603, v: 'c3' },
            { x: 0.591, z: 0.854, v: 'c5' },
            { x: 0.604, z: 0.25, v: 'c3' },
            { x: 0.619, z: 0.456, v: 'c3' },
            { x: 0.614, z: 0.7, v: 'c5' },
            { x: 0.623, z: 0.371, v: 'c5' },
            { x: 0.645, z: 0.563, v: 'c3' },
            { x: 0.628, z: 0.773, v: 'c5' },
            { x: 0.64, z: 0.833, v: 'c3' },
            { x: 0.634, z: 0.899, v: 'c3' },
            { x: 0.647, z: 0.951, v: 'c3' },
            { x: 0.674, z: 0.436, v: 'c5' },
            { x: 0.681, z: 0.52, v: 'c5' },
            { x: 0.697, z: 0.788, v: 'c5' },
            { x: 0.697, z: 0.843, v: 'c3' },
            { x: 0.695, z: 0.912, v: 'c5' },
            { x: 0.75, z: 0.841, v: 'c3' },
            { x: 0.772, z: 0.051, v: 'c3' },
            { x: 0.779, z: 0.259, v: 'c7' },
            { x: 0.778, z: 0.554, v: 'c5' },
            { x: 0.768, z: 0.886, v: 'c3' },
            { x: 0.808, z: 0.211, v: 'c5' },
            { x: 0.809, z: 0.916, v: 'c3' },
            { x: 0.833, z: 0.062, v: 'c3' },
            { x: 0.826, z: 0.276, v: 'c5' },
            { x: 0.827, z: 0.597, v: 'c3' },
            { x: 0.822, z: 0.646, v: 'c3' },
            { x: 0.814, z: 0.855, v: 'c3' },
            { x: 0.86, z: 0.121, v: 'c3' },
            { x: 0.849, z: 0.475, v: 'c3' },
            { x: 0.875, z: 0.203, v: 'c5' },
            { x: 0.869, z: 0.538, v: 'c5' },
            { x: 0.884, z: 0.899, v: 'c5' },
            { x: 0.91, z: 0.072, v: 'c5' },
            { x: 0.916, z: 0.477, v: 'c3' },
            { x: 0.936, z: 0.148, v: 'c3' },
            { x: 0.942, z: 0.213, v: 'c3' },
            { x: 0.969, z: 0.094, v: 'c3' },
            { x: 0.95, z: 0.395, v: 'c5' },
            { x: 0.981, z: 0.454, v: 'c3' }
          ],
          rocks: [],
          sticks: [
            { x: 0.088, z: 0.763, rotY: 4.82, flip: 1, scale: 0.5 },
            { x: 0.038, z: 0.663, rotY: 3.98, flip: 0, scale: 0.5 },
            { x: 0.938, z: 0.688, rotY: 0.96, flip: 1, scale: 0.5 },
            { x: 0.888, z: 0.738, rotY: 3.19, flip: 0, scale: 0.5 }
          ],
          minables: []
        }
      },
      {
        id: 'forest_9',
        seed: 1001,
        terrain: {
          hills: [
            { shape: 'tri', x: 1, z: 0, wx: 0.8098362922202795, wz: 0.8015215554274618, dirX: -1, dirZ: 1, height: 0.3606961178942583 }
          ]
        },
        items: {
          trees: [
            { x: 0.068, z: 0.118, v: 'c3' },
            { x: 0.066, z: 0.192, v: 'c3' },
            { x: 0.07, z: 0.27, v: 'c3' },
            { x: 0.06, z: 0.58, v: 'c3' },
            { x: 0.072, z: 0.634, v: 'c3' },
            { x: 0.086, z: 0.324, v: 'c3' },
            { x: 0.094, z: 0.834, v: 'c3' },
            { x: 0.12, z: 0.249, v: 'c3' },
            { x: 0.139, z: 0.196, v: 'c5' },
            { x: 0.135, z: 0.528, v: 'c7' },
            { x: 0.14, z: 0.764, v: 'c7' },
            { x: 0.147, z: 0.885, v: 'c3' },
            { x: 0.166, z: 0.474, v: 'c3' },
            { x: 0.16, z: 0.827, v: 'c3' },
            { x: 0.196, z: 0.762, v: 'c3' },
            { x: 0.199, z: 0.853, v: 'c3' },
            { x: 0.217, z: 0.454, v: 'c3' },
            { x: 0.218, z: 0.526, v: 'c3' },
            { x: 0.218, z: 0.912, v: 'c5' },
            { x: 0.242, z: 0.784, v: 'c3' },
            { x: 0.272, z: 0.213, v: 'c3' },
            { x: 0.299, z: 0.749, v: 'c5' },
            { x: 0.297, z: 0.891, v: 'c5' },
            { x: 0.298, z: 0.954, v: 'c3' },
            { x: 0.322, z: 0.172, v: 'c5' },
            { x: 0.316, z: 0.267, v: 'c5' },
            { x: 0.318, z: 0.68, v: 'c5' },
            { x: 0.349, z: 0.455, v: 'c5' },
            { x: 0.347, z: 0.724, v: 'c3' },
            { x: 0.351, z: 0.955, v: 'c3' },
            { x: 0.366, z: 0.115, v: 'c5' },
            { x: 0.377, z: 0.172, v: 'c3' },
            { x: 0.374, z: 0.242, v: 'c3' },
            { x: 0.371, z: 0.317, v: 'c5' },
            { x: 0.4, z: 0.401, v: 'c5' },
            { x: 0.39, z: 0.675, v: 'c5' },
            { x: 0.393, z: 0.762, v: 'c3' },
            { x: 0.421, z: 0.093, v: 'c5' },
            { x: 0.446, z: 0.198, v: 'c5' },
            { x: 0.454, z: 0.398, v: 'c3' },
            { x: 0.478, z: 0.059, v: 'c3' },
            { x: 0.478, z: 0.148, v: 'c5' },
            { x: 0.471, z: 0.733, v: 'c5' },
            { x: 0.472, z: 0.859, v: 'c3' },
            { x: 0.504, z: 0.373, v: 'c3' },
            { x: 0.501, z: 0.426, v: 'c3' },
            { x: 0.505, z: 0.815, v: 'c5' },
            { x: 0.529, z: 0.064, v: 'c3' },
            { x: 0.533, z: 0.174, v: 'c3' },
            { x: 0.519, z: 0.888, v: 'c3' },
            { x: 0.552, z: 0.117, v: 'c3' },
            { x: 0.559, z: 0.276, v: 'c5' },
            { x: 0.547, z: 0.426, v: 'c3' },
            { x: 0.577, z: 0.195, v: 'c3' },
            { x: 0.575, z: 0.326, v: 'c3' },
            { x: 0.575, z: 0.657, v: 'c3' },
            { x: 0.6, z: 0.733, v: 'c5' },
            { x: 0.632, z: 0.243, v: 'c5' },
            { x: 0.633, z: 0.656, v: 'c3' },
            { x: 0.66, z: 0.322, v: 'c3' },
            { x: 0.661, z: 0.724, v: 'c5' },
            { x: 0.66, z: 0.934, v: 'c3' },
            { x: 0.681, z: 0.881, v: 'c5' },
            { x: 0.705, z: 0.218, v: 'c7' },
            { x: 0.712, z: 0.27, v: 'c5' },
            { x: 0.707, z: 0.353, v: 'c3' },
            { x: 0.71, z: 0.762, v: 'c3' },
            { x: 0.702, z: 0.809, v: 'c3' },
            { x: 0.736, z: 0.884, v: 'c3' },
            { x: 0.725, z: 0.954, v: 'c3' },
            { x: 0.762, z: 0.226, v: 'c3' },
            { x: 0.811, z: 0.808, v: 'c5' },
            { x: 0.838, z: 0.196, v: 'c5' },
            { x: 0.828, z: 0.403, v: 'c7' },
            { x: 0.865, z: 0.452, v: 'c3' },
            { x: 0.855, z: 0.557, v: 'c7' },
            { x: 0.892, z: 0.186, v: 'c3' },
            { x: 0.887, z: 0.604, v: 'c5' },
            { x: 0.916, z: 0.349, v: 'c7' },
            { x: 0.905, z: 0.395, v: 'c3' },
            { x: 0.918, z: 0.99, v: 'c3' },
            { x: 0.931, z: 0.145, v: 'c7' },
            { x: 0.936, z: 0.222, v: 'c3' },
            { x: 0.934, z: 0.475, v: 'c5' },
            { x: 0.963, z: 0.546, v: 'c5' },
            { x: 0.959, z: 0.931, v: 'c7' },
            { x: 0.985, z: 0.171, v: 'c3' },
            { x: 0.982, z: 0.76, v: 'c7' },
            { x: 0.989, z: 0.956, v: 'c3' }
          ],
          rocks: [],
          sticks: [
            { x: 0.063, z: 0.963, rotY: 4.59, flip: 1, scale: 0.5 },
            { x: 0.238, z: 0.063, rotY: 4.89, flip: 0, scale: 0.5 },
            { x: 0.488, z: 0.538, rotY: 3.38, flip: 0, scale: 0.5 },
            { x: 0.588, z: 0.538, rotY: 4.99, flip: 0, scale: 0.5 },
            { x: 0.663, z: 0.563, rotY: 2.91, flip: 1, scale: 0.5 },
            { x: 0.188, z: 0.338, rotY: 2.62, flip: 0, scale: 0.5 }
          ],
          minables: []
        }
      }
    ],
  },
  desert: {
    name: 'Desert Biome',
    borderMargin: 0.03, // UV margin on edges adjacent to a different biome
    generationRules: {
      hills: null, // deserts are flat â€” no hills
      trees: {
        totalRange: { min: 14, max: 22 },
        variantWeights: { sg: 0.40, br: 0.25, pp: 0.20, db: 0.15 },
        minSpacing: 0.06,
      },
      rocks: { count: { min: 4, max: 8 }, scale: { min: 0.50, max: 0.85 } },
      minables: null, // no desert-specific minable material yet
    },
    treeVariants: ['cactus_saguaro', 'cactus_barrel', 'cactus_prickly', 'dead_bush'],
    configs: [
      {
        id: 'desert_1',
        seed: 301,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.347, z: 0.352, v: 'pp' },
            { x: 0.764, z: 0.214, v: 'br' },
            { x: 0.151, z: 0.967, v: 'db' },
            { x: 0.534, z: 0.384, v: 'br' },
            { x: 0.082, z: 0.51, v: 'pp' },
            { x: 0.617, z: 0.025, v: 'sg' },
            { x: 0.89, z: 0.348, v: 'br' },
            { x: 0.204, z: 0.078, v: 'db' },
            { x: 0.386, z: 0.038, v: 'pp' },
            { x: 0.979, z: 0.59, v: 'db' },
            { x: 0.862, z: 0.849, v: 'sg' },
            { x: 0.783, z: 0.734, v: 'br' },
            { x: 0.663, z: 0.782, v: 'pp' },
            { x: 0.819, z: 0.349, v: 'db' },
            { x: 0.523, z: 0.522, v: 'pp' },
            { x: 0.921, z: 0.262, v: 'br' },
            { x: 0.532, z: 0.837, v: 'br' },
            { x: 0.159, z: 0.656, v: 'pp' },
            { x: 0.173, z: 0.451, v: 'pp' },
            { x: 0.663, z: 0.375, v: 'pp' }
          ],
          rocks: [
            { x: 0.637, z: 0.481, rotY: 3.9, scale: 0.62 },
            { x: 0.54, z: 0.828, rotY: 2.4, scale: 0.55 },
            { x: 0.471, z: 0.871, rotY: 2.5, scale: 0.7 },
            { x: 0.693, z: 0.192, rotY: 1.5, scale: 0.53 },
            { x: 0.922, z: 0.509, rotY: 2.4, scale: 0.71 },
            { x: 0.429, z: 0.535, rotY: 4.1, scale: 0.7 },
            { x: 0.254, z: 0.615, rotY: 0.4, scale: 0.77 },
            { x: 0.547, z: 0.371, rotY: 1.9, scale: 0.71 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_2',
        seed: 401,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.679, z: 0.91, v: 'pp' },
            { x: 0.754, z: 0.699, v: 'db' },
            { x: 0.673, z: 0.227, v: 'pp' },
            { x: 0.888, z: 0.096, v: 'sg' },
            { x: 0.914, z: 0.171, v: 'sg' },
            { x: 0.623, z: 0.14, v: 'sg' },
            { x: 0.125, z: 0.054, v: 'sg' },
            { x: 0.815, z: 0.07, v: 'sg' },
            { x: 0.062, z: 0.068, v: 'pp' },
            { x: 0.748, z: 0.765, v: 'pp' },
            { x: 0.446, z: 0.261, v: 'br' },
            { x: 0.789, z: 0.312, v: 'pp' },
            { x: 0.959, z: 0.213, v: 'br' },
            { x: 0.759, z: 0.394, v: 'br' },
            { x: 0.517, z: 0.3, v: 'sg' },
            { x: 0.954, z: 0.446, v: 'sg' },
            { x: 0.927, z: 0.049, v: 'db' },
            { x: 0.456, z: 0.123, v: 'sg' },
            { x: 0.246, z: 0.525, v: 'db' },
            { x: 0.317, z: 0.688, v: 'pp' },
            { x: 0.014, z: 0.62, v: 'br' }
          ],
          rocks: [
            { x: 0.053, z: 0.132, rotY: 5.3, scale: 0.73 },
            { x: 0.904, z: 0.303, rotY: 5.9, scale: 0.58 },
            { x: 0.342, z: 0.187, rotY: 1.8, scale: 0.82 },
            { x: 0.039, z: 0.947, rotY: 0.5, scale: 0.54 },
            { x: 0.708, z: 0.213, rotY: 3.1, scale: 0.61 },
            { x: 0.649, z: 0.269, rotY: 4.1, scale: 0.75 },
            { x: 0.772, z: 0.953, rotY: 1.9, scale: 0.79 },
            { x: 0.616, z: 0.968, rotY: 5.7, scale: 0.69 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_3',
        seed: 501,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.01, z: 0.467, v: 'pp' },
            { x: 0.745, z: 0.184, v: 'sg' },
            { x: 0.195, z: 0.487, v: 'pp' },
            { x: 0.242, z: 0.807, v: 'db' },
            { x: 0.745, z: 0.832, v: 'sg' },
            { x: 0.63, z: 0.255, v: 'br' },
            { x: 0.279, z: 0.644, v: 'br' },
            { x: 0.046, z: 0.029, v: 'sg' },
            { x: 0.851, z: 0.955, v: 'br' },
            { x: 0.651, z: 0.549, v: 'br' },
            { x: 0.263, z: 0.287, v: 'br' },
            { x: 0.227, z: 0.588, v: 'br' },
            { x: 0.833, z: 0.748, v: 'db' },
            { x: 0.073, z: 0.174, v: 'db' },
            { x: 0.054, z: 0.101, v: 'db' },
            { x: 0.846, z: 0.891, v: 'br' },
            { x: 0.359, z: 0.132, v: 'sg' },
            { x: 0.86, z: 0.149, v: 'sg' },
            { x: 0.885, z: 0.461, v: 'br' },
            { x: 0.564, z: 0.623, v: 'pp' },
            { x: 0.665, z: 0.902, v: 'br' }
          ],
          rocks: [
            { x: 0.505, z: 0.07, rotY: 3.4, scale: 0.72 },
            { x: 0.625, z: 0.56, rotY: 0.6, scale: 0.79 },
            { x: 0.058, z: 0.515, rotY: 3.9, scale: 0.81 },
            { x: 0.681, z: 0.032, rotY: 5.7, scale: 0.56 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_4',
        seed: 601,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.341, z: 0.025, v: 'pp' },
            { x: 0.735, z: 0.668, v: 'br' },
            { x: 0.718, z: 0.748, v: 'pp' },
            { x: 0.596, z: 0.519, v: 'br' },
            { x: 0.636, z: 0.371, v: 'pp' },
            { x: 0.474, z: 0.292, v: 'br' },
            { x: 0.584, z: 0.914, v: 'sg' },
            { x: 0.487, z: 0.029, v: 'db' },
            { x: 0.464, z: 0.506, v: 'sg' },
            { x: 0.918, z: 0.731, v: 'db' },
            { x: 0.699, z: 0.086, v: 'br' },
            { x: 0.319, z: 0.891, v: 'db' },
            { x: 0.035, z: 0.116, v: 'db' },
            { x: 0.959, z: 0.87, v: 'db' },
            { x: 0.537, z: 0.589, v: 'db' },
            { x: 0.844, z: 0.873, v: 'db' },
            { x: 0.083, z: 0.279, v: 'sg' },
            { x: 0.008, z: 0.322, v: 'sg' },
            { x: 0.249, z: 0.473, v: 'pp' },
            { x: 0.293, z: 0.608, v: 'sg' },
            { x: 0.333, z: 0.978, v: 'br' }
          ],
          rocks: [
            { x: 0.518, z: 0.16, rotY: 3.7, scale: 0.52 },
            { x: 0.688, z: 0.724, rotY: 3.4, scale: 0.52 },
            { x: 0.317, z: 0.98, rotY: 4, scale: 0.76 },
            { x: 0.047, z: 0.529, rotY: 4, scale: 0.52 },
            { x: 0.648, z: 0.198, rotY: 5.4, scale: 0.81 },
            { x: 0.774, z: 0.779, rotY: 0.5, scale: 0.64 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_5',
        seed: 701,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.672, z: 0.582, v: 'br' },
            { x: 0.725, z: 0.153, v: 'db' },
            { x: 0.24, z: 0.008, v: 'pp' },
            { x: 0.95, z: 0.231, v: 'sg' },
            { x: 0.407, z: 0.153, v: 'sg' },
            { x: 0.643, z: 0.486, v: 'pp' },
            { x: 0.668, z: 0.94, v: 'br' },
            { x: 0.888, z: 0.98, v: 'sg' },
            { x: 0.316, z: 0.873, v: 'sg' },
            { x: 0.324, z: 0.509, v: 'sg' },
            { x: 0.664, z: 0.724, v: 'pp' },
            { x: 0.584, z: 0.681, v: 'sg' },
            { x: 0.073, z: 0.068, v: 'db' },
            { x: 0.16, z: 0.946, v: 'sg' },
            { x: 0.56, z: 0.608, v: 'pp' },
            { x: 0.548, z: 0.848, v: 'br' },
            { x: 0.828, z: 0.66, v: 'sg' },
            { x: 0.802, z: 0.285, v: 'sg' },
            { x: 0.78, z: 0.622, v: 'sg' },
            { x: 0.501, z: 0.655, v: 'br' },
            { x: 0.854, z: 0.139, v: 'br' },
            { x: 0.867, z: 0.4, v: 'sg' }
          ],
          rocks: [
            { x: 0.395, z: 0.273, rotY: 2.8, scale: 0.71 },
            { x: 0.395, z: 0.571, rotY: 1.8, scale: 0.62 },
            { x: 0.928, z: 0.282, rotY: 2.6, scale: 0.52 },
            { x: 0.985, z: 0.848, rotY: 6, scale: 0.79 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_6',
        seed: 801,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.715, z: 0.638, v: 'sg' },
            { x: 0.762, z: 0.268, v: 'br' },
            { x: 0.304, z: 0.942, v: 'db' },
            { x: 0.238, z: 0.814, v: 'sg' },
            { x: 0.649, z: 0.601, v: 'db' },
            { x: 0.863, z: 0.588, v: 'br' },
            { x: 0.81, z: 0.955, v: 'br' },
            { x: 0.049, z: 0.832, v: 'db' },
            { x: 0.16, z: 0.989, v: 'br' },
            { x: 0.894, z: 0.369, v: 'sg' },
            { x: 0.087, z: 0.698, v: 'db' },
            { x: 0.953, z: 0.91, v: 'br' },
            { x: 0.849, z: 0.471, v: 'sg' },
            { x: 0.111, z: 0.02, v: 'sg' },
            { x: 0.16, z: 0.346, v: 'sg' },
            { x: 0.891, z: 0.697, v: 'br' },
            { x: 0.76, z: 0.697, v: 'pp' },
            { x: 0.888, z: 0.121, v: 'pp' },
            { x: 0.919, z: 0.032, v: 'sg' },
            { x: 0.7, z: 0.956, v: 'pp' },
            { x: 0.485, z: 0.326, v: 'sg' },
            { x: 0.759, z: 0.182, v: 'sg' }
          ],
          rocks: [
            { x: 0.902, z: 0.15, rotY: 1.2, scale: 0.69 },
            { x: 0.415, z: 0.802, rotY: 2.7, scale: 0.84 },
            { x: 0.106, z: 0.918, rotY: 2.2, scale: 0.55 },
            { x: 0.92, z: 0.547, rotY: 0.1, scale: 0.56 },
            { x: 0.35, z: 0.914, rotY: 5, scale: 0.84 },
            { x: 0.746, z: 0.512, rotY: 5.6, scale: 0.5 },
            { x: 0.785, z: 0.841, rotY: 5.4, scale: 0.62 },
            { x: 0.625, z: 0.496, rotY: 1.4, scale: 0.57 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_7',
        seed: 901,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.334, z: 0.697, v: 'br' },
            { x: 0.706, z: 0.123, v: 'br' },
            { x: 0.285, z: 0.528, v: 'br' },
            { x: 0.658, z: 0.654, v: 'br' },
            { x: 0.069, z: 0.474, v: 'br' },
            { x: 0.656, z: 0.717, v: 'sg' },
            { x: 0.057, z: 0.236, v: 'br' },
            { x: 0.731, z: 0.931, v: 'br' },
            { x: 0.781, z: 0.791, v: 'pp' },
            { x: 0.066, z: 0.162, v: 'sg' },
            { x: 0.117, z: 0.296, v: 'pp' },
            { x: 0.172, z: 0.681, v: 'db' },
            { x: 0.58, z: 0.822, v: 'db' },
            { x: 0.149, z: 0.971, v: 'sg' },
            { x: 0.76, z: 0.084, v: 'sg' },
            { x: 0.411, z: 0.802, v: 'sg' },
            { x: 0.338, z: 0.409, v: 'pp' },
            { x: 0.492, z: 0.97, v: 'br' },
            { x: 0.157, z: 0.364, v: 'db' },
            { x: 0.523, z: 0.027, v: 'br' },
            { x: 0.797, z: 0.851, v: 'br' },
            { x: 0.864, z: 0.89, v: 'db' }
          ],
          rocks: [
            { x: 0.496, z: 0.761, rotY: 4, scale: 0.79 },
            { x: 0.874, z: 0.521, rotY: 0.5, scale: 0.61 },
            { x: 0.946, z: 0.288, rotY: 6.2, scale: 0.52 },
            { x: 0.507, z: 0.128, rotY: 2.2, scale: 0.63 },
            { x: 0.048, z: 0.604, rotY: 4.8, scale: 0.69 },
            { x: 0.22, z: 0.723, rotY: 3.8, scale: 0.73 },
            { x: 0.758, z: 0.723, rotY: 6.1, scale: 0.78 },
            { x: 0.751, z: 0.079, rotY: 0.7, scale: 0.81 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_8',
        seed: 1001,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.665, z: 0.255, v: 'br' },
            { x: 0.696, z: 0.607, v: 'db' },
            { x: 0.807, z: 0.788, v: 'br' },
            { x: 0.012, z: 0.366, v: 'sg' },
            { x: 0.9, z: 0.135, v: 'db' },
            { x: 0.662, z: 0.832, v: 'sg' },
            { x: 0.252, z: 0.884, v: 'sg' },
            { x: 0.652, z: 0.906, v: 'pp' },
            { x: 0.514, z: 0.749, v: 'pp' },
            { x: 0.832, z: 0.949, v: 'sg' },
            { x: 0.267, z: 0.381, v: 'db' },
            { x: 0.339, z: 0.223, v: 'sg' },
            { x: 0.257, z: 0.665, v: 'db' },
            { x: 0.206, z: 0.734, v: 'br' }
          ],
          rocks: [
            { x: 0.051, z: 0.185, rotY: 5.8, scale: 0.57 },
            { x: 0.376, z: 0.63, rotY: 1.4, scale: 0.51 },
            { x: 0.36, z: 0.822, rotY: 3.6, scale: 0.78 },
            { x: 0.396, z: 0.942, rotY: 5.5, scale: 0.75 },
            { x: 0.544, z: 0.676, rotY: 4.9, scale: 0.68 }
          ],
          sticks: [],
          minables: []
        }
      },
      {
        id: 'desert_9',
        seed: 1101,
        terrain: {
          hills: []
        },
        items: {
          trees: [
            { x: 0.686, z: 0.092, v: 'sg' },
            { x: 0.329, z: 0.048, v: 'br' },
            { x: 0.732, z: 0.796, v: 'sg' },
            { x: 0.669, z: 0.948, v: 'br' },
            { x: 0.446, z: 0.532, v: 'sg' },
            { x: 0.573, z: 0.882, v: 'pp' },
            { x: 0.246, z: 0.708, v: 'br' },
            { x: 0.668, z: 0.428, v: 'br' },
            { x: 0.467, z: 0.599, v: 'pp' },
            { x: 0.562, z: 0.15, v: 'pp' },
            { x: 0.342, z: 0.648, v: 'db' },
            { x: 0.833, z: 0.646, v: 'db' },
            { x: 0.645, z: 0.841, v: 'sg' },
            { x: 0.225, z: 0.874, v: 'br' }
          ],
          rocks: [
            { x: 0.054, z: 0.176, rotY: 3.5, scale: 0.84 },
            { x: 0.506, z: 0.923, rotY: 0.6, scale: 0.59 },
            { x: 0.634, z: 0.933, rotY: 1.3, scale: 0.59 },
            { x: 0.62, z: 0.765, rotY: 1, scale: 0.56 },
            { x: 0.772, z: 0.237, rotY: 3.3, scale: 0.64 },
            { x: 0.339, z: 0.106, rotY: 6, scale: 0.82 },
            { x: 0.544, z: 0.624, rotY: 1.8, scale: 0.75 }
          ],
          sticks: [],
          minables: []
        }
      }
    ],
  },
};

// Active biome reference (used for tree texture loading)
let activeBiome = BIOMES.rock;

// Compute height contribution from a single hill at position (u, v).
// Supports shape types: 'circle' (default), 'rect', 'tri'.
// Uses Lp-norm distance for rounded corners on rect/tri shapes.
// Hills are extended beyond their natural extents by HILL_REACH_MULT
// to create gradual cross-boundary falloff. Inside the original extent,
// the original cosine profile is used; the extended zone tapers gently to 0.

// Get hills for a grid position (clamped to bounds)
const GRID_SIZE = 3;
const GRID_HALF = Math.floor(GRID_SIZE / 2);

function getHillsForRegion(gx, gz) {
  const cgx = Math.max(-GRID_HALF, Math.min(GRID_HALF, gx));
  const cgz = Math.max(-GRID_HALF, Math.min(GRID_HALF, gz));
  const assignment = getRegionAssignment(cgx, cgz);
  const biome = BIOMES[assignment.biome];
  const config = biome.configs[assignment.configIdx];
  return config.terrain.hills || [];
}

// Global height computation: at any UV point within a region, gather hills
// from the region and all 8 neighbors and sum contributions. Hills are
// extended beyond their natural radius via HILL_REACH_MULT so they fade
// out much more gradually across region boundaries.
//
// HILL_REACH_MULT: multiplier on hill extents. 1.0 = original shape.
// Slightly > 1 softens hill edges via the Lp-norm rounded profiles.
// Cross-boundary smoothing is handled by the BLEED_UV system in
// getBlendedHeight(), not by extending hill reach.
const HILL_REACH_MULT = 1.3;

// Extended hill contribution: evaluates the hill with stretched extents
// so it fades out more gradually. Single smooth cosine profile over
// the full extended range. The Lp-norm distance metric gives rounded
// corners for rect and tri shapes.
function hillContributionExt(hill, u, v, offsetX, offsetZ) {
  const hu = hill.x + (offsetX || 0);
  const hv = hill.z + (offsetZ || 0);
  const du = u - hu;
  const dv = v - hv;
  let t; // 0 = edge of extended hill, 1 = center
  if (hill.shape === 'rect') {
    const nx = Math.abs(du) / (hill.wx * HILL_REACH_MULT);
    const nz = Math.abs(dv) / (hill.wz * HILL_REACH_MULT);
    const p = 3.0;
    const nxp = Math.pow(Math.max(nx, 0.0001), p);
    const nzp = Math.pow(Math.max(nz, 0.0001), p);
    const d = Math.pow(nxp + nzp, 1 / p);
    t = Math.max(0, 1 - d);
  } else if (hill.shape === 'tri') {
    const sx = du * (hill.dirX || 1);
    const sz = dv * (hill.dirZ || 1);
    if (sx < 0 || sz < 0) return 0;
    const nx = sx / (hill.wx * HILL_REACH_MULT);
    const nz = sz / (hill.wz * HILL_REACH_MULT);
    const p = 2.5;
    const nxp = Math.pow(Math.max(nx, 0.0001), p);
    const nzp = Math.pow(Math.max(nz, 0.0001), p);
    const d = Math.pow(nxp + nzp, 1 / p);
    t = Math.max(0, 1 - d);
  } else {
    const dist = Math.sqrt(du * du + dv * dv);
    t = Math.max(0, 1 - dist / (hill.radius * HILL_REACH_MULT));
  }
  if (t <= 0) return 0;
  return hill.height * (0.5 + 0.5 * Math.cos(Math.PI * (1 - t)));
}

// Height at a point considering only hills within a single region (with
// its own 3x3 neighbor sampling for natural hill overlap).
function getRegionHeight(regionGx, regionGz, u, v) {
  const hills = getHillsForRegion(regionGx, regionGz);
  let h = 0;
  for (let dz = -1; dz <= 1; dz++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nHills = (dx === 0 && dz === 0) ? hills :
        getHillsForRegion(regionGx + dx, regionGz + dz);
      for (const hill of nHills) {
        h += hillContributionExt(hill, u, v, dx, dz);
      }
    }
  }
  return h;
}

// Cross-boundary height blending.
// After computing the base hill height (which uses extended reach for
// natural overlap), we add a bleed pass: near each region edge, sample
// the neighbor's height at the boundary and fade it into this region
// if the neighbor is taller. This handles the case where a tall hill
// sits right at a boundary and its shape doesn't naturally extend far
// enough into the neighbor.
//
// BLEED_UV: how far into a region the neighbor's boundary height can
// bleed. 0.30 = 30% of region width = 3 world units of gradual fade.
const BLEED_UV = 0.30;

function getBlendedHeight(hills, u, v, regionGx, regionGz) {
  if (window._debugFlatTerrain) return 0; // DEBUG: flat terrain
  // Base height from natural hill contributions (own + neighbors via 3x3)
  let h = 0;
  for (let dz = -1; dz <= 1; dz++) {
    for (let dx = -1; dx <= 1; dx++) {
      const neighborHills = (dx === 0 && dz === 0) ? hills :
        (regionGx !== undefined ? getHillsForRegion(regionGx + dx, regionGz + dz) : hills);
      for (const hill of neighborHills) {
        h += hillContributionExt(hill, u, v, dx, dz);
      }
    }
  }

  if (regionGx === undefined) return h;

  // Bleed pass: for each cardinal direction, check if the neighbor has
  // higher terrain at our shared boundary. If so, smoothly fade that
  // extra height into this region.
  //
  // We sample the neighbor at multiple points along the boundary edge
  // (not just one point) so the bleed captures the neighbor's height
  // profile, not just a single spot.
  const cardinals = [
    { dx: -1, dz:  0, dist: u,     bU: 0.0, bV: v,   nU: 1.0, nV: v   }, // left
    { dx:  1, dz:  0, dist: 1 - u, bU: 1.0, bV: v,   nU: 0.0, nV: v   }, // right
    { dx:  0, dz: -1, dist: v,     bU: u,   bV: 0.0, nU: u,   nV: 1.0 }, // top
    { dx:  0, dz:  1, dist: 1 - v, bU: u,   bV: 1.0, nU: u,   nV: 0.0 }, // bottom
  ];

  for (const c of cardinals) {
    if (c.dist >= BLEED_UV) continue;
    const ngx = regionGx + c.dx, ngz = regionGz + c.dz;
    if (ngx < -GRID_HALF || ngx > GRID_HALF || ngz < -GRID_HALF || ngz > GRID_HALF) continue;

    // Height at the boundary from the neighbor's perspective
    const neighborBorderH = getRegionHeight(ngx, ngz, c.nU, c.nV);
    // Height at the boundary from our perspective
    const ourBorderH = getRegionHeight(regionGx, regionGz, c.bU, c.bV);
    // Use the max of both views at the boundary â€” this is the "true" seam height
    const seamH = Math.max(neighborBorderH, ourBorderH);

    if (seamH <= h) continue;

    // Fade from boundary inward: 1 at edge, 0 at BLEED_UV distance
    let fade = 1 - c.dist / BLEED_UV;
    fade = fade * fade * (3 - 2 * fade); // smoothstep

    // Lerp toward the seam height
    h = h + (seamH - h) * fade;
  }

  // Diagonal bleed for corners
  const diagonals = [
    { dx: -1, dz: -1, dU: u,     dV: v     }, // top-left
    { dx:  1, dz: -1, dU: 1 - u, dV: v     }, // top-right
    { dx: -1, dz:  1, dU: u,     dV: 1 - v }, // bottom-left
    { dx:  1, dz:  1, dU: 1 - u, dV: 1 - v }, // bottom-right
  ];

  for (const d of diagonals) {
    if (d.dU >= BLEED_UV || d.dV >= BLEED_UV) continue;
    const ngx = regionGx + d.dx, ngz = regionGz + d.dz;
    if (ngx < -GRID_HALF || ngx > GRID_HALF || ngz < -GRID_HALF || ngz > GRID_HALF) continue;

    // Corner point UVs: our corner and neighbor's corresponding corner
    const ourCU = d.dx < 0 ? 0 : 1;
    const ourCV = d.dz < 0 ? 0 : 1;
    const nCU = d.dx < 0 ? 1 : 0;
    const nCV = d.dz < 0 ? 1 : 0;

    const neighborCornerH = getRegionHeight(ngx, ngz, nCU, nCV);
    const ourCornerH = getRegionHeight(regionGx, regionGz, ourCU, ourCV);
    const seamH = Math.max(neighborCornerH, ourCornerH);

    if (seamH <= h) continue;

    let fadeU = 1 - d.dU / BLEED_UV;
    let fadeV = 1 - d.dV / BLEED_UV;
    fadeU = fadeU * fadeU * (3 - 2 * fadeU);
    fadeV = fadeV * fadeV * (3 - 2 * fadeV);
    const fade = fadeU * fadeV;

    h = h + (seamH - h) * fade;
  }

  return h;
}

// --- Adaptive Ground Mesh Builder ---
const S = 5.0;
const REGION_SIZE = S * 2; // 10 world units per region
const BASE_RES = 6;
const FINE_RES = 4;
const EDGE_OVERLAP = 0.15; // 15% overlap into neighbor regions

function buildTerrainMesh(hills, regionGx, regionGz) {
  // Adaptive subdivision: 2 levels only â€” flat (1 quad) or hilly (FINE_RES^2 quads).
  // Threshold chosen so any visible slope gets the finer level.
  function cellSubdivLevel(ci, cj) {
    const u0 = ci / BASE_RES, u1 = (ci + 1) / BASE_RES;
    const v0 = cj / BASE_RES, v1 = (cj + 1) / BASE_RES;
    const h00 = getBlendedHeight(hills, u0, v0, regionGx, regionGz);
    const h10 = getBlendedHeight(hills, u1, v0, regionGx, regionGz);
    const h01 = getBlendedHeight(hills, u0, v1, regionGx, regionGz);
    const h11 = getBlendedHeight(hills, u1, v1, regionGx, regionGz);
    const variance = Math.max(h00, h10, h01, h11) - Math.min(h00, h10, h01, h11);
    return variance < 0.01 ? 1 : FINE_RES;
  }

  // Precompute subdivision levels for all cells
  const subdiv = new Uint8Array(BASE_RES * BASE_RES);
  for (let cj = 0; cj < BASE_RES; cj++) {
    for (let ci = 0; ci < BASE_RES; ci++) {
      subdiv[cj * BASE_RES + ci] = cellSubdivLevel(ci, cj);
    }
  }
  // Propagate: each cell's effective level = max of itself and its 4 neighbors.
  // This ensures shared edges always have matching resolution (no T-junctions).
  const effectiveSub = new Uint8Array(subdiv);
  for (let cj = 0; cj < BASE_RES; cj++) {
    for (let ci = 0; ci < BASE_RES; ci++) {
      let s = subdiv[cj * BASE_RES + ci];
      if (ci > 0) s = Math.max(s, subdiv[cj * BASE_RES + ci - 1]);
      if (ci < BASE_RES - 1) s = Math.max(s, subdiv[cj * BASE_RES + ci + 1]);
      if (cj > 0) s = Math.max(s, subdiv[(cj - 1) * BASE_RES + ci]);
      if (cj < BASE_RES - 1) s = Math.max(s, subdiv[(cj + 1) * BASE_RES + ci]);
      effectiveSub[cj * BASE_RES + ci] = s;
    }
  }

  const verts = [];
  const idx = [];
  const vMap = new Map();
  let vi = 0;

  function addV(u, v) {
    const key = u.toFixed(6) + ',' + v.toFixed(6);
    if (vMap.has(key)) return vMap.get(key);
    const x = -S + u * 2 * S;
    const z = -S + v * 2 * S;
    const y = getBlendedHeight(hills, u, v, regionGx, regionGz);
    verts.push(x, y, z, u, v);
    const i = vi++;
    vMap.set(key, i);
    return i;
  }

  function addQ(u0, v0, u1, v1) {
    const tl = addV(u0, v0), tr = addV(u1, v0);
    const bl = addV(u0, v1), br = addV(u1, v1);
    idx.push(tl, bl, tr, tr, bl, br);
  }

  for (let cj = 0; cj < BASE_RES; cj++) {
    for (let ci = 0; ci < BASE_RES; ci++) {
      const u0 = ci / BASE_RES, u1 = (ci + 1) / BASE_RES;
      const v0 = cj / BASE_RES, v1 = (cj + 1) / BASE_RES;
      const sub = effectiveSub[cj * BASE_RES + ci];
      if (sub > 1) {
        for (let sj = 0; sj < sub; sj++) {
          for (let si = 0; si < sub; si++) {
            addQ(
              u0 + (si / sub) * (u1 - u0), v0 + (sj / sub) * (v1 - v0),
              u0 + ((si+1) / sub) * (u1 - u0), v0 + ((sj+1) / sub) * (v1 - v0)
            );
          }
        }
      } else {
        addQ(u0, v0, u1, v1);
      }
    }
  }

  // Mark end of core mesh indices (before overlap strips)
  const coreIdxEnd = idx.length;

  // Add overlap border strips extending past 0-1 UV range
  // Subdivide for smooth height blending at region boundaries.
  // The V-axis (for left/right borders) or U-axis (for top/bottom) resolution
  // matches the adjacent edge cell's effective subdivision to prevent T-junctions.
  const OV = EDGE_OVERLAP;
  const OV_DEPTH = 2; // subdivision depth into the overlap (narrow direction)
  function addBorderStrip(u0, v0, u1, v1, edgeSub) {
    // edgeSub = subdivision along the edge (matching the base mesh cell)
    // OV_DEPTH = subdivision perpendicular to the edge
    for (let sj = 0; sj < edgeSub; sj++) {
      for (let si = 0; si < OV_DEPTH; si++) {
        addQ(
          u0 + (si / OV_DEPTH) * (u1 - u0), v0 + (sj / edgeSub) * (v1 - v0),
          u0 + ((si+1) / OV_DEPTH) * (u1 - u0), v0 + ((sj+1) / edgeSub) * (v1 - v0)
        );
      }
    }
  }
  // Left border (u: -OV to 0) â€” V-axis matches left edge cells (ci=0)
  for (let cj = 0; cj < BASE_RES; cj++) {
    const v0 = cj / BASE_RES, v1 = (cj + 1) / BASE_RES;
    const edgeSub = effectiveSub[cj * BASE_RES + 0];
    addBorderStrip(-OV, v0, 0, v1, edgeSub);
  }
  // Right border (u: 1 to 1+OV) â€” V-axis matches right edge cells (ci=BASE_RES-1)
  for (let cj = 0; cj < BASE_RES; cj++) {
    const v0 = cj / BASE_RES, v1 = (cj + 1) / BASE_RES;
    const edgeSub = effectiveSub[cj * BASE_RES + (BASE_RES - 1)];
    addBorderStrip(1, v0, 1 + OV, v1, edgeSub);
  }
  // Top border (v: -OV to 0) â€” U-axis matches top edge cells (cj=0)
  for (let ci = 0; ci < BASE_RES; ci++) {
    const u0 = ci / BASE_RES, u1 = (ci + 1) / BASE_RES;
    const edgeSub = effectiveSub[0 * BASE_RES + ci];
    for (let si = 0; si < edgeSub; si++) {
      for (let sj = 0; sj < OV_DEPTH; sj++) {
        addQ(
          u0 + (si / edgeSub) * (u1 - u0), -OV + (sj / OV_DEPTH) * OV,
          u0 + ((si+1) / edgeSub) * (u1 - u0), -OV + ((sj+1) / OV_DEPTH) * OV
        );
      }
    }
  }
  // Bottom border (v: 1 to 1+OV) â€” U-axis matches bottom edge cells (cj=BASE_RES-1)
  for (let ci = 0; ci < BASE_RES; ci++) {
    const u0 = ci / BASE_RES, u1 = (ci + 1) / BASE_RES;
    const edgeSub = effectiveSub[(BASE_RES - 1) * BASE_RES + ci];
    for (let si = 0; si < edgeSub; si++) {
      for (let sj = 0; sj < OV_DEPTH; sj++) {
        addQ(
          u0 + (si / edgeSub) * (u1 - u0), 1 + (sj / OV_DEPTH) * OV,
          u0 + ((si+1) / edgeSub) * (u1 - u0), 1 + ((sj+1) / OV_DEPTH) * OV
        );
      }
    }
  }
  // Four corner overlap quads
  const cTL = Math.max(effectiveSub[0], OV_DEPTH);
  const cTR = Math.max(effectiveSub[BASE_RES - 1], OV_DEPTH);
  const cBL = Math.max(effectiveSub[(BASE_RES - 1) * BASE_RES], OV_DEPTH);
  const cBR = Math.max(effectiveSub[(BASE_RES - 1) * BASE_RES + (BASE_RES - 1)], OV_DEPTH);
  function addCorner(u0, v0, u1, v1, res) {
    for (let sj = 0; sj < res; sj++) {
      for (let si = 0; si < res; si++) {
        addQ(
          u0 + (si / res) * (u1 - u0), v0 + (sj / res) * (v1 - v0),
          u0 + ((si+1) / res) * (u1 - u0), v0 + ((sj+1) / res) * (v1 - v0)
        );
      }
    }
  }
  addCorner(-OV, -OV, 0, 0, cTL);
  addCorner(1, -OV, 1 + OV, 0, cTR);
  addCorner(-OV, 1, 0, 1 + OV, cBL);
  addCorner(1, 1, 1 + OV, 1 + OV, cBR);

  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), gl.STATIC_DRAW);
  return { vbo, ibo, idxCount: idx.length, coreIdxCount: coreIdxEnd };
}

// Vertex stride: 3 floats pos + 2 floats UV
const stride = 5 * 4;

// --- Tree Billboard Shader ---
const treeVS = `
  attribute vec3 aPos;
  attribute vec2 aUV;
  uniform mat4 uProj;
  uniform mat4 uView;
  uniform vec3 uTreePos;
  uniform float uTreeScale;
  uniform vec2 uTreeSize; // (width, height) in world units
  varying vec2 vUV;
  varying vec3 vTreeWorldPos;
  void main() {
    vec3 camRight = vec3(uView[0][0], uView[1][0], uView[2][0]);
    vec3 camUp = vec3(uView[0][1], uView[1][1], uView[2][1]);
    float w = uTreeSize.x * uTreeScale;
    float h = uTreeSize.y * uTreeScale;
    vec3 worldPos = uTreePos + camRight * aPos.x * w + camUp * aPos.y * h;
    vUV = aUV;
    vTreeWorldPos = uTreePos;
    gl_Position = uProj * uView * vec4(worldPos, 1.0);
  }
`;

const treeFS = `
  precision mediump float;
  varying vec2 vUV;
  varying vec3 vTreeWorldPos;
  uniform sampler2D uTreeTex;
  uniform vec3 uTreePlayerPos;
  void main() {
    vec4 c = texture2D(uTreeTex, vUV);
    if (c.a < 0.5) discard;
    float dx = vTreeWorldPos.x - uTreePlayerPos.x;
    float dz = vTreeWorldPos.z - uTreePlayerPos.z;
    float dist = sqrt(dx * dx + dz * dz);
    float darken = smoothstep(3.0, 12.0, dist);
    c.rgb *= mix(1.0, 0.55, darken);
    gl_FragColor = c;
  }
`;

const treeVShader = createShader(gl.VERTEX_SHADER, treeVS);
const treeFShader = createShader(gl.FRAGMENT_SHADER, treeFS);
const treeProg = gl.createProgram();
gl.attachShader(treeProg, treeVShader);
gl.attachShader(treeProg, treeFShader);
gl.linkProgram(treeProg);

const tAPos = gl.getAttribLocation(treeProg, 'aPos');
const tAUV = gl.getAttribLocation(treeProg, 'aUV');
const tUProj = gl.getUniformLocation(treeProg, 'uProj');
const tUView = gl.getUniformLocation(treeProg, 'uView');
const tUTreePos = gl.getUniformLocation(treeProg, 'uTreePos');
const tUTreeScale = gl.getUniformLocation(treeProg, 'uTreeScale');
const tUTreeSize = gl.getUniformLocation(treeProg, 'uTreeSize');
const tUTreeTex = gl.getUniformLocation(treeProg, 'uTreeTex');
const tUTreePlayerPos = gl.getUniformLocation(treeProg, 'uTreePlayerPos');

// Tree billboard quad: centered horizontally, bottom at y=0
const treeQuadVerts = new Float32Array([
  // x, y, z, u, v
  -0.5, 0, 0,  0, 1,
   0.5, 0, 0,  1, 1,
   0.5, 1, 0,  1, 0,
  -0.5, 1, 0,  0, 0,
]);
const treeQuadIdx = new Uint16Array([0,1,2, 0,2,3]);

const treeVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, treeVBO);
gl.bufferData(gl.ARRAY_BUFFER, treeQuadVerts, gl.STATIC_DRAW);

const treeIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, treeIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, treeQuadIdx, gl.STATIC_DRAW);

// --- All embedded image assets (data URIs) ---
const IMAGE_ASSETS = {
  trees: {
    dry: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABzElEQVR4nO2WvUoDQRSFv1XB1SKEKBYSYhQD2gS0EkvL9GnENxAsU/gAKVIKvoDYpfcBLMRCDNhYKCYGSaUhpIhrIWsRZl2TyfzsJojggYVlfu49c+6dOxf+8ctwVJOFYtZfzS2zkoTnDpyWr5Trx0pAOAcCAqAnYUtaOhl2LgjAN4n6Qwsxv5lxuW96Q+OmpKdkg2HnwvGg882MC0Cv6wUEw/vEeh2MFFBBOB+EjIBMCakCUTGfcK33jI1AqXTl9LreZAmIuMtwdLDtv9xNiEDt+gkgyHYZ0nmXdH5CIdjaWQv+p5se0woipZJdsZqxWQzwqQgDQKWy6wMBSd16qQIX1YZTf2ghDKlOLGrE4HdyfuuEnY8qRtoQfGbckacYZbR2/cThcV8JHZTxOjrY9gEeP9pcVBtOoZj1YbhS6qAqxcocuGm1SC70Ty+ch2EaZxWMMrZQzPrrsymgr4aNArrX0PgWPH60Aei8eZAzO71J/2B8ZwdDoFPBtHmx7nB0iWjbNUVqsfb3NnyAbHrpx3j57NLa3lif4yiwLsUyLKZSkffGUqDTfY+zPT6BZGLudwlAfBViE4irQqwk7HTfSSbmeG23I9v4+zkQF1/Jlq84lfYzVQAAAABJRU5ErkJggg==",
    sparse: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABe0lEQVR4nO2VoU7DQBzGv3YTxTAyCKJZllU0QaIrKpB4DKIvUIe8B6jG7AUQ0zzBBGLPsGRiZFkmCFlWDBPAIZZrbuPa6921KWKf613/9/3+//S+Akcd9Z8Vk4DGJKB1eth5G7d3g8xYB6IsvBAgJgH1fDd7bi22SuYq8O2izc7PzjjtO0JI/nmYTCx+Pau1/9byEk6AFedJ1FVep7KzhBNg1KntYD5bFRrxnfJ7qe2gtdjiWzA9KQAbJxOJQnod9Wny9JKt853xY2bAnu9KzQHAkr5xAJL2voQA89kKnu9imEwsEoUUAHjgSgDub67o5nxnzN8SXp1lu5SxFgAPAgCD3uXe+uvyDQAwGk9Ln1t4DVWlYlwpwEW3q12bG8VltPn4NCk3Bzg7PWkWADCfgjGA6RRq+QZIFFIWRjIZ3YLD7lUSUAmg7MEsiFSk/C/gjVgSshx4eHyuN4h0OpRJ6SMcjaeWTtxWBlCHGgeo5Gf0vl5r1zY+gcYBfgEeCJEIXnU+OQAAAABJRU5ErkJggg==",
    bare: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAA8ElEQVR4nO2VMQrCQBBFf8TGRiSIlYWlp0jhMVLkIDmAB7HIMSw8haWFlUgIaVKuhQxoCMnszsAo7K8z+1/+zs4AUVFRv6qyyJw1A8oicxog4jNCQTh1Ceeg/LB3ALDbbgAAx9NltI5Mp74DgDkHoDpfkzcIRv+GjG/3B+dYAMwE+uonQiJjAuaIlQBXPsaqAOs0Da6dSYybtpOUywFWy4UtADCcgs/MEPfAZwo+718FoGm7LwAfY9J/9IDWUhoS6woo2pBRqwJA4hr7NKPKLqBJ+KxrcI1Jqrsg5GrMl5F4EkplDqByBdR8ITJPwBzgBcb6XFbN+90rAAAAAElFTkSuQmCC",
    scraggly: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAtklEQVR4nGNgGAWjYBSMAjwgu8rqf3aV1f+B0s/AwMDAUBVnR5EBVXlGFDogz+h/VZzdf3IcQqnjsRpIjKGkOJiFFAc8ePKKoMUMDAwMbYsOMRJrJtEKkUGUk8Z/BgYGBgUZMRRxmAOX7btBtLkkhQAhQIrFVHWAiJAQ2XqZKLH4w6fvlGin3AECfJwD6wAGBspDgWIHUBoKo2mA4igYdcCoA0YdQCmgSm345t07svUOeAgMuAMA80c5beNYnwAAAAAASUVORK5CYII=",
    fir_cluster_3: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACYAAAA2CAYAAACr6+s1AAAI/klEQVR4nO2ZSY9cR3aFv5jelMOrgWQRLZLulgwYkA0vDC/7/6/6D/TSUssaSBZzemMM14tIFlnKqmqqqwwDhu4ikcDLd+PEjRvnnIiE3+P3OI2Lry/lqXLpp0q0eNUKWtE+EbgnA5ZCYh485aJ4knzqKZK0X19K+2JJdz0wdRNYzeG/Pjwq95NUrKgdH37YYlzGUlT20TkfnwHorju01gy7mcV5jdKPX4gnAVatK6zWdNuRw/VACPHROR89tRf/9lK0UnSbkbJxKK3wYyDGyP67zT+c/9EV2709YIxBRDBFRfSR6CMhPq5qj25+AdaXDetnC1KIpJAQhGZd/t8CW57X7N732NIy7CZQCgS6zfi/C+ybP//xXiZfvGqlKDOh+ilQVBYF2MJSFJbq5eredy+/eVghHgTWvmll8987Lr65uDOJQjHtR1aXDQhMQ8DVDshL/FBeicLq1frenz3Y/NoaEHCVu/N5uSwgCeN+QmmFKwzRR7SGkARXWu5a0GpVYa0mbNL9Y9/34MW3L6R9vsCUBgVc/vPdpS8bhy0Mri4IIdLvRuYxYJ2hbE4ntH7dSpgiU++pKsf6dXtn3nsrNu4nnDFYZzGFJqXT2Q3bAeeWKKORFLGFZXFRE8bIsBs4XPcn7yitWJzXhCkw7iaK+m4Id1bs1X++EucMMSaG3Ui/GQHF2Z9u95o2hv37HusMoNBWc3jb4UfP+vniNO9//EGK0tG965gOE+urJckL51+f9vCdwHa/7LGlxU+Bel1hnCaFiPoVjwcfAJj6mXnwWGeRJIQpsP25Q5nb6ecp5B50Bkkw7CfqtsJP4csqhoDSGonC1E00bU30ifSZBp59cyll5Vi0Gbg2GlI6LlVD3dZUlWP1+uymGn4IrJ4vKGqHUlAtC8btiLanMO4EVi1LfD+jrEYS7H85sL5aUi4/sXmKieATwUe0MayeL+h3I0prUkyQEn7OmvkxjFH0mxE/ejCK/dsOVzvOrpZfBkxphXYGVxpsadDOcHjbIfKpFabes7qomQdP96Hnww9bXOVQRtHvJorG0rQNH19Zv24leSHOkTBHkk8oYBo8h196rr59cbt/fw2qfdPKfJixTmOdwRSWcuEwpcVoc4sU99fDjSmUJLkSApISm58ODLsBYw0A9bokidCcVWirWT1viEmomoJiUZz02QkwbQ3LZwts5eg3I1rDsB2RmJi7maat8rI4w7N/OmMeA+3LFUprmrZGaagWBSJQfjZgDEK5KBi7measot9OKEBbRVllYn4YmFYc3neE0QOZz8qmoFpXKPVJnLVW7N52lLVj+9OeGCKCMA+esZtZnteEKeKKXLHxMBGngCssc+9xhUVrRfSJ3ftTvjsB5qdws0tEhKIpCDHRfRjAKIw5+vra4gePLgzVsqSoHMN2xFhDva7otyMxRNA5V1k7JAnjYaJoHPMwIwKusmilWF7e5r0Th9m+aUUrjVIKEaE5b0g+4hpLnBPddmDyCS1grEaSUC4L+u2IUookksGrXI2isthCQxSUgqIpkJiYeo+knH/cDohA86zmb3/5QZ0Ae/Yvz6RelMQ54ueIKw3jfqZaFnm3bUYESCkRU35ZyB9NWzENgTB5tFakJBhn0FohMVKUFomCMoq6rZEkTN2MxIQkQQRCjOy+3yr4lVaOh5k0ZQeqlcIDtjIooxi2E9WyAKXotgNF5VhcNGx+3CIC/XZEG40xGm01zuYq+RCx1hB8QitFUTmij/jRY6zB+wgKylWJC5HdXT32qX/yoUJEkEQu83mNLW3moCQkEd59tyEGOVZRMFZjSoukzHM+RLTSSErH5YWpm5mONmnuPc1FjbaGuZv5jCZvA1NKYQqD1poQEtYZtNUM25HuuqffDJmpXyzxg6dZFyiVOUobRYqJFIUYI/W6JPoEWqG0wpYWBKpVSXNeUy1KXOOIPqGNAskb405gtjC40tKcZ66ae4/vj/cRCmxps6zsRmIUtDnuwM1IikJKEH0gRaHfjLjS5p4zGokJpXK75B2fCKNnOkxEHxEh6+1du3L9uhWtNQqoVyUhRMIYKRYFtjRIFPzkERHe/vXd7Y3TGKkKyzgH3vXx5tkf/v2ljJ3HFQZ37K/oI8Zqgk/4KeDKbJuM1XT7kf33W3Xi0taXTfZh2wlbGqpVbnitFPtNj6vtCUs/FIcPA2Xl8EPADwGlYXHZIElwlSJMgTgnbGkIPt5U6gbY2Z/OxaAYB0+aI8oolFIMuyn3ntM3V0xlXdC+aWX73fbvnrSN06QkNxNKQdj/0iFkW163FZKEuZtv2Z+bb0oyl8jHBg4JW1pc7bCVIfp8/6WNYuo8tviyQ/zFV23uMRHqVUm1dJy/WmOcJvrI+HHiRR7joxbfZNelxaBwpcWrgNKKfjOgjra1XBbEEBl2E81Zzf66uwXgXR8V/ekSb37aU9YFw34ijJFy4dj8sMc4jZ8jRe0Y9xPaKuq2Ikn8VcVU5qJuO1IuC+bec/G6RRBEcqnnIbC8bPCjP7HZ98aRfF1pwCi0NRQLl6XLasIY0E6TgoAIh+vhNrDpMJOi0F4t2b/PfHX9/RbjDEpl41guCrrrgWpdPnig/TymIUuUHwIS8i4MPmUtToKy+dRkS4OtLB9nfAPMOItSsPv5gLGaefCYwuQDhVYkH4+aJgzbiRS/DJpxBlNZlNVUqypXSEGcI7YwJJ8YDhNhiux+PlCvytvARASJQrUqSTHbXhEoK4t1GmU1zVl1M6A9+qyHYv3mTJpViRLJl8ejJ4kQQnYAi8vmeJrP49uj0F99eyUaYPnVWrRSxCTEEHG1Zfl8kR3AFBCgfbnKQu0MyiqMsyy/uv/uATKTF41D0tEihYS2OkuVwP5dz3iYc/+p7M0A+t3wqWK2yJdvfggYbRj3E7Yy+N4TpsDmxz3RJxbnFc4awhhu/Px94afAhx/3uONNY0yJFLI0JRG0VtjKsr/OPd1tRmJIqKP6cPWvV+LnRJoDKWVDlz0VR+mICLA6r+m3Y94QRjF1E/u/7X7zdeZ98vV5PJj0SxL8I/EleZ/sn5Gnjt+B/dZ4kj8gfmvcp6u/x//L+B+xrOwSeKEf6wAAAABJRU5ErkJggg==",
    fir_cluster_5: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC4AAAA6CAYAAADP/mu6AAAMiUlEQVR4nO2ZyW9kR3LGf7m+rTYuYo/UWjySYVgewAZswEf//0cfbcxhLMuSZtQku1hVb8vVh6wuqcWm1NUtYGBDcSKKLyO+l7F9EQ9+k9/kN/n/JR98+Sz/Ne3Ldzn0/F+e5+ATi0837w3+4ovrd9LxTsB3dyNCgVTvdPwk9rrLlx+v6D5enw3+bMubL64yMaOkxI/hnYy+kmZV8/DnA34KZ589G/i4n7GNZtxPVLUmhnS2USgX0LQGNwY2z1ZUzxZnXcDZwJtlxbifEULi5sDqujtXBQApZeYpknPicN+jjTrr/NnAY0y065qqM0gtefj+cK4KAFJICFHCBcA0+qzzZwF//q+f5DhH5t6jK81i06K04vrLm7Pc3D5fZ6kUOWXG3cz6gwVEqG7ePlzOAn7/9RYhBO26JoXM/r5nedGwux3OUUPOmegCyigWly37+x4pBQAf//PHbwX+LOC2sXSbhrl39C8HlFbvVBIXmwahBDlndi8OxJAxtWZ52RJdpPnd8hfBn2U1pcz+fsDPAVNrBDDt57MTdH/Xk2Nm3E0IAcvLlnnwQOawHVlc1L+o40ngm88uHr119AGlS6jY2lAtKoSWjPvpLODVoqJZVUglyRmkkQgBxEzVGvwQ6D5a/eytizf9uPxknaWQoAQPf7oXAM3zde6WNTFE5t6V5646lJbMvSNLwf1/fv9Gfa+BvllkYzVCCIQURB/RVtFtapSSBBdQRpNS4tt///ZJfW+sQYvLFj94xiNAgHphySnhBs+zL64YHyb6lyPdRYtQghjiL2EGQCpBu24IPjAfHLbWeB95+P6AMYqcM7a1DLuf9+KjUFl9us5SCppNg9aSz//t9xlg3I6klGnXFYe7nn47IZVkd3sozeMX77qIkIJhO+AHz/Kqxc0BKcrhnDPKaGylEb+g7xHw4BNhjuy+P7D5cMXd1w/FoJK4wSOkYniYyWSCL7c8Dx43vB3fiCEhlSSlzHhw1MuKlBPdpmFx1WKsZNiOSCn58J8+fDLOH4XK8nrBuB1p1zUvv92h6/JIvaywSlIvDdNeYmpNmCO2Lf/3/u0K1OK6g5BJh5lmYTncDwiRCXPAj54UE0IIpBTsXvRP6nnN2uL5KrtjiZp7R3fZYIzi2R+e5TAEDtuJ7/9ry8VHS1LMeBcILiGV4vKj1Vt1vulhIkwepGB3N2AqTYyZ6CMpJmxXAdCua+rOvB3wlDLtpmF53aGtor8fWT9bsr8fSLGwQG0Ud18/MA+O5VWHGz2H+4H7bx6wzQ+Grn5/+eglqptFJkEIiRQSUsA8BepFASuVxI8e21rG/cz8M3T3NeBSS2JM7G973OhRSnD39Uvqzh5rbkZIgZDl2P6uxx5DKceMGz0A60/XWdeaZ394ncPklKmXFVJKllctMWaWFzWbm9LAqkVFTgkpBd1Fw8XN8sl6/hrwHDPDbqLqKtpVTQiZ4CIxJJpVTdUYYojklAq5+uwCNwXWHy4RUtBuSsfLGZKPuOn1Emkagxs87aZmeJhL5ZCC3YsB21qm/YxUElMr9rc9+9uenN8cfSfgv/vHD7PWis3NAj84ht1Es7DUiwolJTEG3BQwViOVRKqSPFWjefhuTwyJDCw/XuVu3ZBSRsTM6pMfJqRXzWbuHdoqpBT027G8QM5oq0AI3BgQQmCq0qh+FvjuxYF2XTPuZ2IutxN8REhBSvkE2NQaU2uqxuBHj6o09cJia824ndC2hM7ygwXKSFYf/IjH5Mw8OKrO4idfPBMS0+BRRhF9xFQaN3pSyujq6eHiVA7XNwum3UyKCW3Kz0IIgouklDnc97TrhnHnQBSD2kim3Uy1sPi5JJLUkmk/Mw+eZmFxP0owIQXNusYNnkxpOM2yYnnZcf/tA0opxv2MUoJmWZHi00XqBDz4VGJ5YZl6h1IGoQQpZoxVpCyZ9p52XTEePIh0Co9xN9NtGrQRCARUhpwSfg6EOXLzDzd5/3JESYnrHfWiQhqJHwIpZdzgkEoSfKTb1OSUUUocR7tfiHFyBgFujoAgplIl6s5iW4upNW4O7O9HtFWYSrP+cHU8mum3I6vrjvFhKjxk8Gij6K5apv3M+N1eOBdRVhNTwvUeqQTKSFLMLC5qxNGT0UfCsbYL+eYYF1DYYNVYlJboSnO461k9W5JCOrlOWc3hvgcpUUoilGQ6OIQoIZBTplkY6sYyH+ZSWn1CVwrbGV58s0MpdTKqjMI2CmLGzwHbGPwUTjestMLUGikF+5cDh292r72BhNLO/eQZDw4/OJplzf77A/vbnnphcaNn7h2LyxYhBDmVztquSuOol/YEftxNXH22QejizPDq5XWZMW1jqJYVptEMDxN+jifQQknadU3OEENkPMwEHzH14w4qAZSS2NYiyFTLCjcFbGdpVhX9/cDVpxtSiOzvBlLKcKw08mhofJhZX7cYW2707qtt8YoEUoaQqWwZFl41KSht3dS6eMYqUkzMQ0AICmPMxTPKPOZBkmNyhdGjjC4M8FhXlVbYxrD9bs/yqqNeVZBzWS1IgXfhFHD7ux5yCRsEuMGhjIJcPBpDwi4qdKWZe4+fIm4MRBdOidxtmsLHG0PKsLhomA4OPz5u/RrAtho/BNplxeG+L67yAoTAWIW2mt1tj240/TcP4rpVubaaaddzO0QBcPW3V1lIQXfZ4gaHmwIiJqQuk46Ugu0fX7wWpx98eZOlEPgpIEUpBvJVvqzK4mlx1RBT5uGrl49vPGeBVJJhO9CsarTV2NaQY8LNkRASUpdS9pSE47oh+li6rZZILZFS4EZPd9m+4VQBW3WWFBN1Zwku4OfA3DuuPlnT3w7sbx/TW3n99x9kJQVIQbWoygIyZ8a9I7hYYjIlcsx06+bJ1UHVWUiZnDN+KnGcE2yer4khcbh7bNwNgXZTk4FqYenvB2xjjsmZuP1qS0xldfEIOMB0mIkuMO5mYkxIJWgW5RaUKjeWc2YePaZ6rOTi88u8uGyZB0cKieATyRc9t396SU4ZISQXn/9AdS/+7jqTM8PDzNw7xp1DWo2bAtoobF0oRr2oMMaw/MkuXg4PE7azVJ3FdiU8TG0wtaFqLaubjnxMFCnLFH47RPE/21m8im+hRElqVVbP4ViPg4+knBECtJGkHw3U7uCoFlXhJ7VBSk41vOoMfi5dNZMRZLqf7FqksZrkE3PvUEqircYNjt1tjx892z8fyFA4S4ilUvxEjFEMLyeq1pyMSymQ/NBsYkivMb2cy94QIUgxkjPkmCDDeHAIIcpE1JhC/NzrFFmaxiCkoF5W9NuJefR4F1FKoNsSb+2yYjwUKvqmeAshIY08bmAF9bout3UEGubC+lL6wds5g5Bgal3qeWOIIRFTQleamDIpZaa9I2c4bF9fV+hpX9YMTFC1hmZds/vLnnZdM+wL85t6x+qmw4+BcTc+Au4nj5aKIARCgFICqcrfpileKG7/kZesQhtFmAMvv9sjj9RBFdqIFKAagzKSPOZH2w9pKgMZmkVhZbu/7DGNYTw4ciyrisuP18z7ubA4KVn9ZD3XrhuQgugKKZoO7tT1YojEORJdRP1oQepDwk2hMNJlhbaaFEtETwd3InkhlJz7aSkT67+5zDnlE7kXQqC0ZDw4ltct48OElPLUJbVRpJTY/fdWQNkMGF3i/pUOXRu0lphGE1wqu8WYsZ1lnj33f7x7I+U7NbZjAXjTM6cbD66MU8lHpCi7vHkoHWzcTsSQUFaitKRqTCFZP3p9eaz/QpSy2a5r/OCZj4ntBkeOmWpVlQ76nl/qTnabVSlJMWZCSMSUyQIQgpgLkZr7MkrZzuJdOC2JKI+RUzryG04JKOVxq9sYdKWILjLvZ4w975PJU6Jv/+PxhvUpl+2/3j7WcPQSsvCa6BP5+MKv+LU2ivaipr8f4YmJ5mzg76ugXdVEX5hevbD024m6s6fpxViFd4ntN3uQgnCYn9R1O0TB8HZb3/cGPvYOJSVVZ+kuGlLMxHDshkowbCdSzscpShHD+R9j3yTvnSnRR5qFpV1X3H+zYz44coJqaRkeJjhuwKSSkEu5+zXkvW9cCBi2E2LHaU2XYuJwOyCNQhvJHCLeRbpNg7KK3a8A/L1ev/tolZWS1K1BqPJJperKjCqEoFpaoouEsdBXZSXbPx+IMT0afs+V9woV25kyR04BpSXtRcM8eNpVjdKSxaYp/EUJ+pcj48OMrswbqfG58l4awhToVg3SSOaDw1Qa22rmyTMPnhdfbYFS56GslKUUqJ9Zrb2t/DqZ8hM5p3W/q/w6/fevIP9ngf8vBcgWH/4Qq/YAAAAASUVORK5CYII=",
    fir_cluster_7: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABQCAYAAAC6aDOxAAASMElEQVR4nO2cSZccx3WFvxhzrKEnECRIybIkU/TGC/3/n+CFV17YPpYpyhzQ6KmqcoiMwYvILgIkQKK7CoB9jLvCwQGiI2+8eMN9Lxo+4iM+4iM+4v8Pnv7Ts/Sh93BMiGMutvi70+QHj9CS7pubo679oSCPupjJnJhSH3PZD4qjEWTPm+Q7T3NSUbcF9qI9ylUrny4/6JU9GkHVuiL4xPaq5/rbDbY2B69ZP1slYxTVs9UHI+loBA2bkWpRUK8LTKGIPh685tR7JhdoT6oj7PBxOBpBcYpoK0kJwhTwUzhoveXfn6XVRYPSgu1lhz1vPogVHYWg0y8v0smnS0JIJB9JwPK0ZvHbk8d/VEp4H4khUTSWorHH2OqDcRSCtpcdqlD0twMJIMHuZiD4x1tRDBFTGqQSRB8Zt+4YW30wjnbF/DBhS40UAm0VUgr89Dg/tPzdabKVwdaGxVnDNHqUUdgnx4mMD8FRCGrOalISjL3POZAQe0t6DGxlEEIy7Rybyx1CChZnDbY6PDI+FAcT1P72JPne4zqHsQrvA1JAiomyKag+XTyYprsftnS3PVJJbG0JPrK77iC9fz99MEFVY9FWYSqD94HudsQNHm0URW1Q9tWsun2LnEZZhVKCGBP9ZkRbRUoJIY+a+L8VDv6JISSEFqQY0VZz8umC5qQmxsj2qkObH3/E6ZcXqVqWnPzh7I0k2Ys2Lc9a/JQIPqC0IMWEUJJp8O893B9M0PZyh9YaBEgt2TzfMQ0Ty4sGgN3VsP+3RWVIKRF+yXmnxPa6oyg1rptICbTVlG2BlAIh328NfBSbHTuH6zzGalJM+NFz+/0WqQTF4sf8pd+MjFvHNPpfXC/6SNFapJaYQhOcp7/tWT9dEP0vG9DFn54c1cIO90HrEmUkUklSjAglaE5qqlWF0j+WHOUnbZIin77Wiurp65338qJl+UlL8BFtFdoqYko0JzV3P2wQ6s0W1H6xTtPg+fTPnx+NpIN0CXvWJCKoQlGtKq7+epM/KCZIicl5pBRUny1TvSxQMhMmjUJ6Sf+aNe+ebzFWE1NCKrm/jv1mxFQWU4N7vn3tfpTO/z4cWOa8jIMsqDmrcP3E9qrj+m+32MoglaS/67GVpl5VpJRDfnczMG4HdGmYhomieUNOk8AUmmZdU9Zmn/tUiwK3c2+M9NXTRQouIJWgv+opjpRUHkTQ7kWPncWxFBOuz041hsTNd1v6uwGlJcuLBmMVymqiD2irkUmw/v2r0cyeNUlbhTSS3XXH7nZkGiaadcXmqkNZTX87cPLlxWs/PiWwtUUI9vs6FAcRdPrbNW7wrJ4uEEpQr0uEhLKxpARFa5nGwO5Fx+K8QUiJkAI/evrNgOtfra9sY2jOGxACpSVKCxDQ3fZZG06JsrH0d8PP9pJSwlhFURnqdYV3x7lmBxF093xHURluv9sQpkhK4PqJYedoTyr84DFzktffjsQpzKdsQAjCTyLSNAb6m56ytdjGkGIixXy9dKEJIeUC9jUJo7aKGCLDdqS/7VmcN4d82h4HEeT7CWkVZVtgy2z+SiuqVUl32xN8BCkoFwVCSWKMuM6hjSKGRLMuf7JizpFuvt3QzpGwqA39ZqSoLZDYXXf4n6QJJ/9wnhYnDSnB2E3EBIRE89nhcu1BBCkjGTcjQuXTB5icZ9iMCCkyQUB/NzL1DiFzbTXuHEVjfiZhtGcNzUlNvarYXvfZInaOorHUqwJiQhuF1K9ue9yM+CmQUkIqgSk0w3bk9DfrQz4POIAge94kkiDERHczUq9LpFEwRy0/RZRRTIPDWgUidzvC6LG1xbtA2RasXnLUmx+2dDcd43YkhcS4HRFCUDaGF1/fkAA/hZxGvISisYzbEVsZUgIzpxqb57vHMzPj0QTp0rD+bMWc+yGcJ8WIUgJlFEVj0UqSgBjBFIZxO+J9pL8bchJoVHbEM4q2IAHBB2LIBFeLAjcGQsikaKt+tpexc/sIFkPE+8jyojlK8f9oglJKvPj6huATp582IKCqNarQpJQYO4f3IVsPMA0T5bICQXa4PieTYfwx2sQYSRHKZUFKs9PejPS3A/W6BCGyKPeTK5YiOdpdd7QnFaY0bC47pnF67Oft8WiCfO+pljnn6K57lFGkmIghEXykWpb4KVIuSoSAelWiraBZlUzDRJgCu9uByWWHay/aFMaIVALXefw4Ua1y2gCwveoxhWJ3O2K0ov58nQAWX6zS8qwhhpx5724Gxi77tqIwtL85QBc/hCBi3lBZSqRWlIsSYzUyBWLImbMpNMNmICEYu4ntZYd3ASEEpjQ0qxJTmP16947dDR5pNLvrHlsZirZAKkFwkdMnTV5j3nmCWXGsKRYWIQXrpwuak4pqWR5sRY8maLrpxPW/PRf1qoSQuHu+zbqNFCx3He75Ruy+uRbeR6rW7nOf5SctCBi2WVjzswUJLbMVJrKsIcAUijBFhs0IQkAKjNsRbX70W/d1X383oJSElBjuRrrbgbvnW+4L5PdO0D3GeVihqHMdtjh7NUFrT2uklgghiCHy4r9ukFKwetJg61fbOfdFpi40YzcxDQE3eGJMxCnuM3RjFW6bLUMIQb8ZqZZlTkaBu8sdQoBSgmJZHPR9BxUsn//5WSprw4uvb/EhUq1KYkiUXz2Ff/4bxZM29bcDKYI2Em013nliyA5YSogucv7VJ+nyX7/fH/V9dnReq1RazeA87qwlzTqR6xxlrZiuIIWINJrgQ1YgBQQliCHltOLAkuMgC9pe7rj+2x0wh+iYSCkXrQCriwZjNUoJysYSfaA5qVmc1YzbEdd7qlVBeot4HFOWXYfNmFtApeH8TxdJSglKEFygaG2WgNP9jYxEnzj94/mjHfVhV0yIuT7SlKuCYTsS/Y96TAj5z0Vr6TYOWxukkUyjp2gLwhToN45x9+tNwad/OMNYRXtakUJkGj27m4F2XeFHz9h7whRRcwpQrSpiiDnKvqa4fVs8mqD1705T3VrasxqhJG7nkFox9Z40JRafL9M05IZf8hFSYvmkZfPDlmnwjNuRsi0ILrzVJMj3//4C21i2Vz1xthBlFN1moGwsSgnCFJBaobREynx4yqiDdOxHExQmn5uF29wP664Hysbsr4ucN6WUIJG7rd11j5Rinwh2dwOI3Fr+/M8/H9277IL45mYU42mD0Zq7H7YUrd2T3axLqmVFtxlJKROmjcRPAddPGKuwtTlojO7xtVhpGLYjwQX8FJFGEqac41TrihgTtjQIlf9++UmLG3O/7L4al0pgK02aPP1Vz+KL1/fMykWBELnmWpw3KKPobwaGu4EYIu1JTbMqSSnnRMZqptHjp9zTP6TkeHQUCyFiCo0pdc5TEvg5f1FaoJRke91R1hYEuMHjuimfslJom/3DNHiadYUtDTff3b3+Z40ekmDqJpSWlIuCceeYXBbeIId7Qa7VpJH7w5jmKv+xeLQFKaOy9Yye5rRGKIEfA0LlvCQrfJrJBYracvvdJn9siHS3PX7KGbMgQgTXTZRNwZN//HnbZnKBclEQY+L2uy13z3e4bqKdc656WaGUJISU9zRMLJ80xBgxRu2v+2PwKIJWv1ml6ALNWY0bPNvLXe5lNZYUE0or2pOa1ScNzL5Gzc6zau0+9FfLfC3GbY5wRVtka3wJ7bNlOnm6JIa4r/Tvs+PuqscWuU1dLYo89CBF7sL2E4LczLSFYfXIWaVHXTFlFGLepBSCorWMW8fYOZp1ye56QFlFf5nH8lzvKRrLNHhiBJTA9x43eqyV6EKxvdyRYu5ovAwp84TZ+rMF486hC43SinHnUFbhBsf2Zm4gJV66Tll2cf1EErD75vZRZvQoC6pXJc26nEdTyA1DkTd4L2bdV/DD1lG2lmEzIiVzzSSQSrG6qJFC7sOwbQxFbVm+7KxF1rBv/nuDEGJOMB3SSMwsfZRtkX2QFKREzuh92LeMlFSUb2hUvhOCdjc9uxd9Pm0hcgdBCmxtCD5m6VPLHK0E9BuXfc92ojmpcEOYRbGUJzl01qjdbiL6+MrQZkr5WpXLAqkF9aokIXJRuhlzBj9/uhDZgoY5crk5WgqRlYfH4NFXTApJmB302DnGbqJssx5TtpYwyxrbl0z7vFapGEeS81x2QQiRUruqmEZP2Vp0aVBacvXt7f5nSZk1ZikFUku2VzmXKpoSSHSbkXEINOuSYeOyhoSguxsojcqBQ0qKRtG9L4Jc71FCIIRg2DlSTFSLIrda5hO3tfnVATNTZLUx+kDSku2LHVLkcZd7pJhyxX47YGrD6tNF7tJ2WfhPIc5tpYEQEnLIk25SgnfZUqUSDHePm3F8FEEpRopVxbh1+NHTntboUvHim1uiC6hC0ywKLr++fuMaF19dpNAHxp2bVcQJQR6aatc17VmTvv2Xb0W9Khl2Dl0Z3G5i6qYsv8L+avff3gmYq/9BY2YLfYzF/BQPvpjnX54nW5j9yQop2F113H23RaSUW88+sLncUdQFF1+9vk08ddPekZNgcZF17fsQ7XaO5Rer5MeAIA+J6lJTLAr6rdv7mnpRsvzN+p0NVT2YoHHnUEbiXc5Qo4+YSucRPBcpF7kzEUPCVK8a6H1tddkFsThvqFYlw2akvWgIIZJi7mslwA1Trtsau9eZ8lUZ0VYjtMwyrI+cPlsciY6f48EElYsCPwRSSBRzeHWdRxtJfVoxdI5mVaGNYnFaE98wTdZvRmLMFnf3/Ra3c9TLEqkEUuXBKWUVu5uesXO5Op8iQoIfJ3aXPTEkxp1j8/wYl+n1eDBBrptgDqd+nGhOSprzirGfICbK2uKG3J9//pdr/BvebAw7h1Ay5z6z7BFjJPqIHz3lnFh+8vuzfd9faYlQkqLJIr4QAikEbsgC3csWehgtP+LBBMUQEfJ+kkOyuerxQ8ia8GakvxuIMeswtjZvHGbSRjF1bl/wqkJn7dknmpOKfjOilOD62w3R50RUW4k2Ctc5bGPRhUJZuc/q3wUeTNB9/8u7gJzFeoD+diD6iDJyryoKIWjWP3+ps/xilRanNUJmIT+FSJin0SBHp6K2LJ4s0HPGnJ1/JPiYa7ato6hNbgbEd+ajHx7m7yOXMop+k1XBcedIIV+lGEGqfAXHnfuZowby/9mOTFNk6j2qyD1910+5ag+RYesYOocxer/22E2kCLuxQxlJdzuwfLogxMjrh/IOx4MsqH22TNncBa6fEELkLqkP6Lnu0VbhXcAUGj8FpJC0z14dQ/HOYxtLtShQNvfx030dJ9h3Rr0LBBcwtZ3LF4Uu9f6AdGnobwZIvFq/HREPIiglOHm2yhufcpbqXcCWhuBCDs/9hLYKoSXMKf9P6yAhBd31gJ8HHoQAIfPwwbjN8mmzLpFS5Cz5bkBqSQyRqZ9oz7PMApnMGNJrhxqOgQcRVK9KXvz1lqKxxDlRbM/r3ItfFBRtPmnvAr6bgES1KJl+4qhXTxp0oXC9RyqZlUadhX9bW6rW0t+OubW9LKgWBdHHuUsh2F0PiPlKFm2eGzrmZOvLOIr7f7nB9zYh9uKri5R8nimMIfe7xu2Y34bN1hBColpZdldDllg3I+WqpJu1n3pVIoTYv2x0/cTNX66PHs7e+/vt8z+epdDPLebW7h+oaCMJPjINU9aHpkh0kXKRrx3kSKmkJInZYYc8RXKfWrwLvHeCvI/7Ed3tVY82khjS/gP1nA8BudY6yYWpLDRFbdi+6FBS4EPczzoKJbO2/Q7w3gkq2wIlJf1mpD2vsz+BXKiSW8gpJRLQnlQMg+N6vjrntUrL+SpfHzFb/iW89wdYw92AlCBIWUMOEaHvay+JqXSeH7IqT3h0h0+JHYKjWNBlFwTd20WRGNNeSOuue5RVSCXxg8fWhqnPskaYwvw45t2E77fFe7cgIUUefdF5EjWGlB/dCfJM9bIgxcj6s+Vc0vzy06l3jffug5SWxJTF+vWnC374zyuEtBRtkRPCufC8+voGyO3pezzEUo+F9/p8b/H5MpVNQXRhbzG2skgtkMDmesDMLw2VFCgriRFSilz9x9UH+XU77/WK5adQHl0ZUoSitnS3PXFKbK56mpMy+6BC40PEjQFt1a++UHyXeK8E+fkXBCTyQ2DI84bdXR4j3r7o97OFQuTNpZRyN/YD4f0SNM0TIYUhTJH+dmCaZwhjTHmqNeQhdFMaYkr7Ou1D4X/Fr9F6aC33PvHhjub/CD4S9Cv4SNCv4CNBH/ER7xT/A9LsJSTSqO4uAAAAAElFTkSuQmCC",
    cactus_saguaro: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAYCAYAAADzoH0MAAABDklEQVR4nN2Tv0oDQRCHfzOzXCskEGu7YCVpkkexFl/LlxAfQ7S0EkEsbIJECIrszljlvL39x6V0qoXZ/eab2V3g/8fy8sxqea4lF+uZhW/D6vq8CEkArYpNwM/e92tVhapOAxBRv3bOgYhgVpaqzkBVEUIA89+2cYsJIKc8NPBfcd4lSsxYrGd2qO6ciwDjAonB8+0rhRAgIui6Dt77KD+cUdYAALb3OwKA083cRCQ6NB5oFjDUNTMQES6ulsbM+Hj/rLeQ0zUzMDNUFS93b1EPVQMz6y0eb54ot6dpML6FSQAzw+FGjga0ogoQEYhI9UM1Z6Cq0V+YBPDe9++gWKSUmK9OkgFsH3Zl0rHxC+dKfQ/BEnmAAAAAAElFTkSuQmCC",
    cactus_barrel: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAqElEQVR4nMWQPQ4BARCFv5ntRLZgqUREISqRVWytEWcQtxPu4BAIjXAGcYLdfSq/q9hC4lWTmfdl3gz8Tesk0WY8VmmgM2l9NdtnI4prAgibVcKogiT2y9PD56/mxqguADMjTVPu9XDeVwGI4prMngvdHXcnz3MABrOe3oDL9mr3YZZlSEIS7o6ZcVidrRDpsr2aJIIgAEASZsZucSzcWlB32i7/0p/qBrOxNoNZKgw2AAAAAElFTkSuQmCC",
    cactus_prickly: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAA7klEQVR4nLWSPU4DMRCF34y3QIkAyeySJuJHgARUsAlXQIQjALfj5wwcggQafhoaSlg4gTWPAsXaDc52eZU9nk/znm1gEdo52+C8M0kVi8EaVRVdvwTfW0UIAU93b8neqO3TfpxSnzg7XeubvPR0zuHoYp8A8H7/IVMHAHB8ecB/4Powp8ifG1WN8NS2qoJkhCP4+VAJAIgISMZMX+NvIYkQAlQVj7ev6ax751tMrXdHm42MSbp3UtDMsFJ0sew7cM5hfP3c6NVZKC89zaxRI4ny6nD+rQJANfkREYGIwMyQZRlIYnLz0v6OdbX9nF+RHFL2krYk9AAAAABJRU5ErkJggg==",
    dead_bush: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAeElEQVR4nGNgoAVwM5L5jy7mba6IKuZqKI2hyN1YFkUMQxMuCS8zBTgfm+0owNNUHq4AZiOymKep/H+4S9yMZP57mMjBBTxM5P4ji8PYyE5nRLfRUkPi/58/fxj+/0e4jJGRkeH0nTcYanECczUxnP5iItoUamkEALr5LPnzRn3hAAAAAElFTkSuQmCC",
  },
};

// ============================================================
// TREE BILLBOARD GENERATION NOTES
// ============================================================
// Tree cluster billboards are generated programmatically via Python/Pillow.
// Generation script: draw_clusters15.py (or latest version)
//
// CANVAS SIZES:
//   cluster_3: 38x54px   cluster_5: 46x58px   cluster_7: 60x66px
//   Original cluster1/2: 32x48px   cluster3: 32x48px
//
// TREE SHAPE:
//   - Smooth fir/conifer silhouette â€” sqrt taper from wide base to rounded tip
//   - max_half_w = tree_h // 4 (wider base than classic pointy)
//   - Taper uses sqrt(progress) instead of linear for softer crown
//   - Very subtle waviness via (y%5) modulation, NOT hard tier steps
//   - Tip: 1px for top 3% of foliage, then sqrt curve widens smoothly
//   - Foliage drawn as filled scanlines per Y row
//
// TRUNK:
//   - 3px wide (trunk_w=1 means cx-1 to cx+1)
//   - Center pixel: (36,24,12), edge pixels: (28,16,6)
//   - Height: tree_h / 6
//
// COLORS (v24 â€” v21 base + desaturate 45% + green vibrance boost):
//   - Base foliage: (12, 36, 12) â€” deep green
//   - Scattered highlights: hash-driven across whole face, top-biased
//     ~70% of pixels get highlight (hash > 0.30), boost = (hash-0.30)*top_bias*32
//   - Extra bright pops: ~25% of highlighted pixels (hash > 0.75) get extra boost
//   - Branch highlights: ~8% of pixels get +7r,+16g,+4b
//   - Edge shadow: |rel_x| > 0.8, dim (|rel_x|-0.8)*22
//   - Bottom shadow: progress > 0.75, dim (progress-0.75)*12
//   - POST-PROCESS per pixel:
//     1. Desaturate 45% toward luminance (lum = 0.299r + 0.587g + 0.114b)
//     2. Green vibrance boost: push g away from lum scaled by green_dominance*0.6
//        Pull r,b slightly down to keep rich, not pale
//
// HASH FUNCTION (for pixel noise/breakup):
//   Uses integer bit-mixing: multiply by large primes, XOR, shift.
//   v = (x + seed*137) * 374761393
//   v = (v ^ (y * 668265263)) & 0xFFFFFFFF
//   v = ((v ^ (v>>13)) * 1274126177) & 0xFFFFFFFF
//   v = (v ^ (v>>16)) & 0xFFFFFFFF
//   return v / 4294967296.0
//   Different seeds per tree (i*3571) to avoid repeated patterns.
//   Key: hash operates per-pixel (not per-block) for organic look.
//
// CLUSTER LAYOUTS (cx, tree_h, trunk_bot_y, darken):
//   cluster_3 (38x54): triangle â€” 1 back-center, 2 front spread wide
//     (19,35,38,6), (30,36,50,0), (8,37,51,0)
//   cluster_5 (46x58): asymmetric â€” 2 back, 1 mid-right, 1 mid-left, 1 front
//     (14,34,39,7), (32,33,39,7), (36,35,48,3), (6,36,52,3), (22,37,60,0)
//   cluster_7 (72x80): 2 back, 2 mid, 2 front-mid, 1 front
//     (20,33,38,9), (40,32,40,9),
//     (28,35,52,5), (52,34,54,5),
//     (18,36,66,0), (44,35,68,0), (34,38,78,0)
//
// DEPTH CUEING:
//   - Back trees: darken 6-9 (stronger separation from front)
//   - Mid trees: darken 3-5
//   - Front trees: 0
//   - Applied as flat subtraction from r,g,b base
//   - Trunks at different Y positions â€” staggered so no foliage_bot aligns
//     with another tree's trunk_bot (within 2px)
//   - Back-to-front draw order (sorted by trunk_bot_y)
//
// BILLBOARD SIZES IN GAME (TREE_SIZES):
//   cluster_3: [0.65, 1.1]  cluster_5: [0.85, 1.2]  cluster_7: [1.32, 1.64]
//
// To regenerate: run the Python script, copy base64 output into IMAGE_ASSETS.trees
// ============================================================

// ============================================================
// TREE BILLBOARD GENERATION SCRIPT (Python/Pillow)
// ============================================================
// Save as draw_clusters24.py and run with: python draw_clusters24.py
// Requires: pip install Pillow
//
// [Python source: draw_clusters24.py]
// from PIL import Image
// import base64, io, json, math
// def make_cluster(tree_defs, canvas_w, canvas_h, name):
//     img = Image.new('RGBA', (canvas_w, canvas_h), (0, 0, 0, 0))
//     pixels = img.load()
//     def hash_px(x, y, seed=0):
//         v = (x + seed * 137) * 374761393
//         v = (v ^ (y * 668265263)) & 0xFFFFFFFF
//         v = ((v ^ (v >> 13)) * 1274126177) & 0xFFFFFFFF
//         v = (v ^ (v >> 16)) & 0xFFFFFFFF
//         return v / 4294967296.0
//     def draw_tree(cx, tree_h, trunk_bot_y, darken=0, seed=0):
//         trunk_h = max(3, tree_h // 6)
//         trunk_w = 1
//         for y in range(trunk_bot_y - trunk_h, trunk_bot_y):
//             for x in range(cx - trunk_w, cx + trunk_w + 1):
//                 if 0 <= x < canvas_w and 0 <= y < canvas_h:
//                     if x == cx: pixels[x, y] = (28, 16, 7, 255)
//                     else: pixels[x, y] = (20, 10, 3, 255)
//         foliage_h = tree_h - trunk_h
//         foliage_top = trunk_bot_y - tree_h
//         max_half_w = max(5, tree_h // 4)
//         for y in range(foliage_top, trunk_bot_y - trunk_h + 1):
//             if y < 0 or y >= canvas_h: continue
//             progress = (y - foliage_top) / max(1, foliage_h)
//             wave = 0.03 * ((y % 5) / 5.0 - 0.5)
//             shaped = math.sqrt(progress) if progress > 0 else 0
//             half_w = int(max_half_w * (shaped + wave) * 0.82)
//             if progress < 0.03: half_w = 0
//             for x in range(cx - half_w, cx + half_w + 1):
//                 if x < 0 or x >= canvas_w: continue
//                 dx = x - cx
//                 rel_x = dx / max(1, half_w) if half_w > 0 else 0
//                 rel_y = progress
//                 r = 12 - darken; g = 36 - darken; b = 12
//                 n = hash_px(x, y, seed)
//                 top_bias = 1.0 - progress * 0.4
//                 if n > 0.30:
//                     strength = (n - 0.30) * top_bias
//                     boost = int(strength * 32)
//                     r += boost // 2; g += boost; b += boost // 3
//                     if n > 0.75:
//                         extra = int((n - 0.75) * 20)
//                         r += extra // 2; g += extra; b += extra // 3
//                 bn = hash_px(x, y, seed + 8837)
//                 if bn > 0.92: r += 7; g += 16; b += 4
//                 if abs(rel_x) > 0.8:
//                     dim = int((abs(rel_x) - 0.8) * 22)
//                     r -= dim; g -= dim; b -= dim // 2
//                 if progress > 0.75:
//                     dim = int((progress - 0.75) * 12)
//                     r -= dim; g -= dim
//                 n2 = hash_px(x, y, seed + 5501)
//                 v = int((n2 - 0.5) * 5); r += v; g += v
//                 r = max(0,min(255,r)); g = max(0,min(255,g)); b = max(0,min(255,b))
//                 # POST-PROCESS: desaturate then green vibrance
//                 lum = r*0.299 + g*0.587 + b*0.114
//                 desat = 0.45
//                 r = r+(lum-r)*desat; g = g+(lum-g)*desat; b = b+(lum-b)*desat
//                 gd = (g-(r+b)/2)/max(1,g)
//                 if gd > 0:
//                     vib = gd * 0.6
//                     g = g+(g-lum)*vib; r = r-(g-lum)*vib*0.15; b = b-(g-lum)*vib*0.15
//                 pixels[x,y] = (max(0,min(255,int(r))),max(0,min(255,int(g))),max(0,min(255,int(b))),255)
//     for i, (cx, tree_h, trunk_bot_y, darken) in enumerate(sorted(tree_defs, key=lambda t: t[2])):
//         draw_tree(cx, tree_h, trunk_bot_y, darken, seed=i * 3571)
//     buf = io.BytesIO()
//     img.save(buf, format='PNG')
//     b64 = base64.b64encode(buf.getvalue()).decode()
//     img.save(f'{name}.png')
//     return f"data:image/png;base64,{b64}"
// c3 = make_cluster([
//     (19,35,38,6),(8,37,51,0),(30,36,50,0),
// ], 38, 54, 'fir_cluster_3')
// c5 = make_cluster([
//     (14,34,39,7),(32,33,39,7),(6,36,52,3),(36,35,48,3),(22,37,60,0),
// ], 46, 58, 'fir_cluster_5')
// c7 = make_cluster([
//     (20,33,38,9),(40,32,40,9),
//     (28,35,52,5),(52,34,54,5),
//     (18,36,66,0),(44,35,68,0),(34,38,78,0),
// ], 72, 80, 'fir_cluster_7')
// with open('cluster_b64.json', 'w') as f:
//     json.dump({'fir_cluster_3': c3, 'fir_cluster_5': c5, 'fir_cluster_7': c7}, f)
// print("Done!")
// [end Python source]
// ============================================================

// Load ALL tree textures from all biomes into a global map
const allTreeVariantNames = [];
for (const bKey in BIOMES) {
  for (const v of BIOMES[bKey].treeVariants) {
    if (!allTreeVariantNames.includes(v)) allTreeVariantNames.push(v);
  }
}
const treeTextures = {};
let treesLoaded = 0;
const treesToLoad = allTreeVariantNames.length;

// Upscale helper: nearest-neighbor to nearest power-of-two size
function upscaleImage(img, factor) {
  const c = document.createElement('canvas');
  c.width = img.width * factor;
  c.height = img.height * factor;
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(img, 0, 0, c.width, c.height);
  return c;
}

function isPOT(n) { return (n & (n - 1)) === 0; }

allTreeVariantNames.forEach(v => {
  const img = new Image();
  img.onload = () => {
    const upscaled = upscaleImage(img, 4);
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, upscaled);
    if (isPOT(upscaled.width) && isPOT(upscaled.height)) {
      gl.generateMipmap(gl.TEXTURE_2D);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    treeTextures[v] = tex;
    treesLoaded++;
  };
  img.src = IMAGE_ASSETS.trees[v];
});

const TREE_COLLISION_RADIUS = 0.055;
const STICK_PASSTHROUGH_RADIUS = 0.22; // stick collider radius at scale 0.5 â€” not blocking player yet, ready for future use
const STICK_COL_OFFSET_Z = 0.06;      // nudge collider toward camera so it centers on visual stick

// Per-variant tree properties: [billboard_width, billboard_height, collider_radius, collider_offset_dx, collider_offset_dz]
// Collider offsets project trunk base center-of-mass to ground plane along camera forward direction
const TREE_VARIANTS = {
  dry:           { size: [0.35, 0.7],   colR: 0.055, colOff: [0, 0] },
  sparse:        { size: [0.35, 0.7],   colR: 0.055, colOff: [0, 0] },
  bare:          { size: [0.35, 0.7],   colR: 0.055, colOff: [0, 0] },
  scraggly:      { size: [0.35, 0.7],   colR: 0.055, colOff: [0, 0] },
  fir_cluster_3: { size: [0.65, 1.1],   colR: 0.28,  colOff: [-0.24, -0.22] },
  fir_cluster_5: { size: [0.85, 1.2],   colR: 0.33,  colOff: [-0.22, -0.23],
                   colGroups: [
                     { colR: 0.33, colOff: [-0.22, -0.23] },
                     { colR: 0.33, colOff: [-0.31, -0.32] },
                   ] },
  fir_cluster_7: { size: [1.32, 1.64],   colR: 0.40,  colOff: [-0.48, -0.36],
                   colGroups: [
                     { colR: 0.40, colOff: [-0.48, -0.36] },
                     { colR: 0.40, colOff: [-0.82, -0.78] },
                   ] },
  cactus_saguaro: { size: [0.30, 0.55],  colR: 0.05,  colOff: [0, 0] },
  cactus_barrel:  { size: [0.22, 0.22], colR: 0.06,  colOff: [0, 0] },
  cactus_prickly: { size: [0.28, 0.24], colR: 0.07,  colOff: [0, 0] },
  dead_bush:      { size: [0.28, 0.20], colR: 0.04,  colOff: [0, 0] },
};
// Short variant aliases used in baked configs
const VARIANT_EXPAND = { c3: 'fir_cluster_3', c5: 'fir_cluster_5', c7: 'fir_cluster_7', sg: 'cactus_saguaro', br: 'cactus_barrel', pp: 'cactus_prickly', db: 'dead_bush' };
function expandVariant(v) { return VARIANT_EXPAND[v] || v; }
const ROCK_COLLISION_RADIUS_BASE = 0.15;


// --- Static Rock Configuration (terrain decoration, scattered, infrequent) ---
// (loaded from active biome config)

// --- Static Minable Material Configuration ---
// (loaded from active biome config)

// --- Rock/Crystal Shader (3D lit cubes) ---
const cubeVS = `
  attribute vec3 aPos;
  attribute vec3 aNormal;
  uniform mat4 uProj;
  uniform mat4 uView;
  uniform mat4 uModel;
  varying vec3 vNormal;
  varying vec3 vWorldPos;
  void main() {
    vec4 world = uModel * vec4(aPos, 1.0);
    vWorldPos = world.xyz;
    vNormal = mat3(uModel) * aNormal;
    gl_Position = uProj * uView * world;
  }
`;

const cubeFS = `
  precision mediump float;
  varying vec3 vNormal;
  varying vec3 vWorldPos;
  uniform vec3 uColor;
  uniform float uEmissive;
  uniform float uIsRock;
  uniform vec3 uPlayerWorldPos;
  uniform vec3 uCamPos;
  uniform float uShininess; // 0 = no specular, higher = more shiny
  void main() {
    vec3 n = normalize(vNormal);
    // Simple directional light from above-right (two-sided)
    vec3 lightDir = normalize(vec3(0.4, 0.8, 0.3));
    float diff = max(dot(n, lightDir), 0.0);
    // Add fill light from opposite side to prevent fully dark faces
    vec3 fillDir = normalize(vec3(-0.3, 0.4, -0.5));
    float fill = max(dot(n, fillDir), 0.0);
    float ambient = 0.3;
    vec3 col = uColor;
    // Rock flat highlights: vary color by face orientation
    if (uIsRock > 0.5) {
      float upFace = max(dot(n, vec3(0.0, 1.0, 0.0)), 0.0);
      float sideFace = abs(dot(n, vec3(1.0, 0.0, 0.0)));
      // Lighten upward faces, warm side faces slightly
      col += vec3(0.08, 0.07, 0.05) * upFace;
      col += vec3(0.03, 0.02, 0.0) * sideFace;
      // Subtle face variation from world position for natural look
      float faceVar = fract(abs(vWorldPos.x * 3.7 + vWorldPos.z * 5.3)) * 0.06 - 0.03;
      col += vec3(faceVar, faceVar * 0.8, faceVar * 0.6);
      ambient = 0.35;
    }
    vec3 lit = col * (ambient + diff * 0.7 + fill * 0.25);
    lit += uColor * uEmissive;
    // Specular highlight (crystal shininess from wave pulse)
    if (uShininess > 0.0) {
      vec3 viewDir = normalize(uCamPos - vWorldPos);
      vec3 halfDir = normalize(lightDir + viewDir);
      float spec = pow(max(dot(n, halfDir), 0.0), 32.0);
      lit += vec3(0.4, 0.55, 0.9) * spec * uShininess;
    }
    // Distance darkening
    float rdx = vWorldPos.x - uPlayerWorldPos.x;
    float rdz = vWorldPos.z - uPlayerWorldPos.z;
    float rdist = sqrt(rdx * rdx + rdz * rdz);
    float rshadow = smoothstep(3.0, 12.0, rdist);
    lit *= mix(1.0, 0.55, rshadow);
    gl_FragColor = vec4(lit, 1.0);
  }
`;

const cubeVShader = createShader(gl.VERTEX_SHADER, cubeVS);
const cubeFShader = createShader(gl.FRAGMENT_SHADER, cubeFS);
const cubeProg = gl.createProgram();
gl.attachShader(cubeProg, cubeVShader);
gl.attachShader(cubeProg, cubeFShader);
gl.linkProgram(cubeProg);

const cAPos = gl.getAttribLocation(cubeProg, 'aPos');
const cANormal = gl.getAttribLocation(cubeProg, 'aNormal');
const cUProj = gl.getUniformLocation(cubeProg, 'uProj');
const cUView = gl.getUniformLocation(cubeProg, 'uView');
const cUModel = gl.getUniformLocation(cubeProg, 'uModel');
const cUColor = gl.getUniformLocation(cubeProg, 'uColor');
const cUEmissive = gl.getUniformLocation(cubeProg, 'uEmissive');
const cUIsRock = gl.getUniformLocation(cubeProg, 'uIsRock');
const cUPlayerWorldPos = gl.getUniformLocation(cubeProg, 'uPlayerWorldPos');
const cUCamPos = gl.getUniformLocation(cubeProg, 'uCamPos');
const cUShininess = gl.getUniformLocation(cubeProg, 'uShininess');

// Unit cube geometry: vertices with normals (centered at origin, size 1)
const cubeVerts = new Float32Array([
  // front
  -0.5,-0.5, 0.5,  0, 0, 1,   0.5,-0.5, 0.5,  0, 0, 1,
   0.5, 0.5, 0.5,  0, 0, 1,  -0.5, 0.5, 0.5,  0, 0, 1,
  // back
   0.5,-0.5,-0.5,  0, 0,-1,  -0.5,-0.5,-0.5,  0, 0,-1,
  -0.5, 0.5,-0.5,  0, 0,-1,   0.5, 0.5,-0.5,  0, 0,-1,
  // top
  -0.5, 0.5, 0.5,  0, 1, 0,   0.5, 0.5, 0.5,  0, 1, 0,
   0.5, 0.5,-0.5,  0, 1, 0,  -0.5, 0.5,-0.5,  0, 1, 0,
  // bottom
  -0.5,-0.5,-0.5,  0,-1, 0,   0.5,-0.5,-0.5,  0,-1, 0,
   0.5,-0.5, 0.5,  0,-1, 0,  -0.5,-0.5, 0.5,  0,-1, 0,
  // right
   0.5,-0.5, 0.5,  1, 0, 0,   0.5,-0.5,-0.5,  1, 0, 0,
   0.5, 0.5,-0.5,  1, 0, 0,   0.5, 0.5, 0.5,  1, 0, 0,
  // left
  -0.5,-0.5,-0.5, -1, 0, 0,  -0.5,-0.5, 0.5, -1, 0, 0,
  -0.5, 0.5, 0.5, -1, 0, 0,  -0.5, 0.5,-0.5, -1, 0, 0,
]);
const cubeIdx = new Uint16Array([
  0,1,2,0,2,3, 4,5,6,4,6,7, 8,9,10,8,10,11,
  12,13,14,12,14,15, 16,17,18,16,18,19, 20,21,22,20,22,23
]);

const cubeVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
gl.bufferData(gl.ARRAY_BUFFER, cubeVerts, gl.STATIC_DRAW);

const cubeIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIdx, gl.STATIC_DRAW);

// --- 5 Low-poly rock mesh variants ---
// Each rock is a deformed icosphere-like shape, unique silhouette
function buildRockMesh(deformSeed) {
  // Start with a rough dodecahedron-ish set of vertices, then deform
  // Use a simple approach: take base vertices, jitter with seeded random
  let s = deformSeed;
  function srand() { s = (s * 16807) % 2147483647; return (s - 1) / 2147483646; }

  // Base: 8-corner box + 6 face centers + top peak, bottom flat
  const baseVerts = [
    // 8 corners of a slightly irregular box
    [-0.45, -0.5,  0.45], [ 0.45, -0.5,  0.45],
    [ 0.45, -0.5, -0.45], [-0.45, -0.5, -0.45],
    [-0.35,  0.25,  0.35], [ 0.35,  0.25,  0.35],
    [ 0.35,  0.25, -0.35], [-0.35,  0.25, -0.35],
    // Top peak
    [ 0.0,  0.5,  0.0],
    // Mid-edge vertices for more facets
    [ 0.0, -0.5,  0.5],  // 9: front bottom mid
    [ 0.5, -0.5,  0.0],  // 10: right bottom mid
    [ 0.0, -0.5, -0.5],  // 11: back bottom mid
    [-0.5, -0.5,  0.0],  // 12: left bottom mid
    [ 0.0,  0.35, 0.4],  // 13: front top mid
    [ 0.4,  0.35, 0.0],  // 14: right top mid
    [ 0.0,  0.35,-0.4],  // 15: back top mid
    [-0.4,  0.35, 0.0],  // 16: left top mid
  ];

  // Deform each vertex
  const verts = baseVerts.map(v => [
    v[0] * (0.7 + srand() * 0.6),
    v[1] * (0.8 + srand() * 0.4),
    v[2] * (0.7 + srand() * 0.6),
  ]);
  // Flatten bottom
  for (let i = 0; i < 5; i++) { if (verts[i]) verts[i][1] = Math.min(verts[i][1], -0.35); }
  verts[0][1] = verts[1][1] = verts[2][1] = verts[3][1] = -0.5;
  verts[9][1] = verts[10][1] = verts[11][1] = verts[12][1] = -0.5;

  // Triangles (manually defined for a rock shape)
  const tris = [
    // Front face
    [0, 9, 4], [9, 1, 5], [9, 5, 13], [4, 9, 13],
    // Right face
    [1, 10, 5], [10, 2, 6], [10, 6, 14], [5, 10, 14],
    // Back face
    [2, 11, 6], [11, 3, 7], [11, 7, 15], [6, 11, 15],
    // Left face
    [3, 12, 7], [12, 0, 4], [12, 4, 16], [7, 12, 16],
    // Top cap
    [4, 13, 8], [13, 5, 8], [5, 14, 8], [14, 6, 8],
    [6, 15, 8], [15, 7, 8], [7, 16, 8], [16, 4, 8],
    // Bottom cap
    [0, 1, 9], [1, 2, 10], [2, 3, 11], [3, 0, 12],
    [0, 3, 12], [1, 0, 9], [2, 1, 10], [3, 2, 11],
  ];

  // Build vertex + normal arrays (flat shading: unique verts per triangle)
  // Ensure consistent CCW winding (outward normals) for back-face culling
  const vertData = [];
  const idxData = [];
  let vi = 0;
  for (const tri of tris) {
    const a = verts[tri[0]], b = verts[tri[1]], c = verts[tri[2]];
    // Face normal via cross product
    const ux = b[0]-a[0], uy = b[1]-a[1], uz = b[2]-a[2];
    const vx = c[0]-a[0], vy = c[1]-a[1], vz = c[2]-a[2];
    let nx = uy*vz - uz*vy, ny = uz*vx - ux*vz, nz = ux*vy - uy*vx;
    const nl = Math.sqrt(nx*nx+ny*ny+nz*nz) || 1;
    nx /= nl; ny /= nl; nz /= nl;
    // Ensure normal points outward (away from mesh center)
    const cx = (a[0]+b[0]+c[0])/3, cy = (a[1]+b[1]+c[1])/3, cz = (a[2]+b[2]+c[2])/3;
    if (nx*cx + ny*cy + nz*cz < 0) {
      // Flip winding
      nx = -nx; ny = -ny; nz = -nz;
      vertData.push(a[0],a[1],a[2], nx,ny,nz);
      vertData.push(c[0],c[1],c[2], nx,ny,nz);
      vertData.push(b[0],b[1],b[2], nx,ny,nz);
    } else {
      vertData.push(a[0],a[1],a[2], nx,ny,nz);
      vertData.push(b[0],b[1],b[2], nx,ny,nz);
      vertData.push(c[0],c[1],c[2], nx,ny,nz);
    }
    idxData.push(vi, vi+1, vi+2);
    vi += 3;
  }

  return {
    verts: new Float32Array(vertData),
    idx: new Uint16Array(idxData),
    triCount: idxData.length,
  };
}

const ROCK_MESH_COUNT = 5;
const rockMeshes = [];
for (let i = 0; i < ROCK_MESH_COUNT; i++) {
  const mesh = buildRockMesh(7919 + i * 6271);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, mesh.verts, gl.STATIC_DRAW);
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.idx, gl.STATIC_DRAW);
  rockMeshes.push({ vbo, ibo, triCount: mesh.triCount });
}

// --- Forked Stick Mesh (flat 2D tris on ground plane) ---
function buildStickMesh() {
  const verts = []; // pos(3) + normal(3)
  const idx = [];
  const n = [0, 1, 0]; // all normals point up

  function addQuad(x0,z0, x1,z1, hw) {
    // Flat quad along line from (x0,z0) to (x1,z1) with half-width hw
    const dx = x1-x0, dz = z1-z0;
    const len = Math.sqrt(dx*dx+dz*dz) || 1;
    const px = -dz/len * hw, pz = dx/len * hw;
    const b = verts.length / 6;
    verts.push(x0+px, 0, z0+pz, ...n);
    verts.push(x0-px, 0, z0-pz, ...n);
    verts.push(x1-px, 0, z1-pz, ...n);
    verts.push(x1+px, 0, z1+pz, ...n);
    idx.push(b,b+1,b+2); idx.push(b,b+2,b+3);
  }

  const W = 0.035;
  addQuad(-0.38, 0.0,  0.10, 0.02,  W);           // main branch
  addQuad( 0.08, 0.02, 0.42, 0.17,  W*0.7);       // fork A (long)
  addQuad( 0.08, 0.02, 0.20,-0.07,  W*0.55);      // fork B (short)

  return {
    verts: new Float32Array(verts),
    idx: new Uint16Array(idx),
    triCount: idx.length,
  };
}

const stickMeshData = buildStickMesh();
const stickVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, stickVBO);
gl.bufferData(gl.ARRAY_BUFFER, stickMeshData.verts, gl.STATIC_DRAW);
const stickIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, stickIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, stickMeshData.idx, gl.STATIC_DRAW);
const stickTriCount = stickMeshData.triCount;

// --- Glow Billboard Shader (additive blended quad around minable materials) ---
const glowVS = `
  attribute vec3 aPos;
  uniform mat4 uProj;
  uniform mat4 uView;
  uniform vec3 uGlowPos;
  uniform float uGlowSize;
  varying vec2 vOffset;
  void main() {
    vec3 camRight = vec3(uView[0][0], uView[1][0], uView[2][0]);
    vec3 camUp = vec3(uView[0][1], uView[1][1], uView[2][1]);
    vec3 worldPos = uGlowPos + camRight * aPos.x * uGlowSize + camUp * aPos.y * uGlowSize;
    vOffset = aPos.xy;
    gl_Position = uProj * uView * vec4(worldPos, 1.0);
  }
`;

const glowFS = `
  precision mediump float;
  varying vec2 vOffset;
  uniform vec3 uGlowColor;
  uniform float uGlowAlpha;
  void main() {
    float d = length(vOffset);
    float glow = 1.0 - smoothstep(0.0, 1.0, d);
    glow = pow(glow, 1.5); // softer than quadratic, less hot center
    glow = min(glow, 0.7); // cap peak intensity to prevent white blowout
    gl_FragColor = vec4(uGlowColor, glow * uGlowAlpha);
  }
`;

const glowVShader = createShader(gl.VERTEX_SHADER, glowVS);
const glowFShader = createShader(gl.FRAGMENT_SHADER, glowFS);
const glowProg = gl.createProgram();
gl.attachShader(glowProg, glowVShader);
gl.attachShader(glowProg, glowFShader);
gl.linkProgram(glowProg);

const gAPos = gl.getAttribLocation(glowProg, 'aPos');
const gUProj = gl.getUniformLocation(glowProg, 'uProj');
const gUView = gl.getUniformLocation(glowProg, 'uView');
const gUGlowPos = gl.getUniformLocation(glowProg, 'uGlowPos');
const gUGlowSize = gl.getUniformLocation(glowProg, 'uGlowSize');
const gUGlowColor = gl.getUniformLocation(glowProg, 'uGlowColor');
const gUGlowAlpha = gl.getUniformLocation(glowProg, 'uGlowAlpha');

// Glow quad: centered, unit size
const glowQuadVerts = new Float32Array([
  -1, -1, 0,
   1, -1, 0,
   1,  1, 0,
  -1,  1, 0,
]);
const glowQuadIdx = new Uint16Array([0,1,2, 0,2,3]);

const glowVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, glowVBO);
gl.bufferData(gl.ARRAY_BUFFER, glowQuadVerts, gl.STATIC_DRAW);

const glowIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glowIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, glowQuadIdx, gl.STATIC_DRAW);

// --- Debug circle outline shader (drawn on top of everything) ---
const dbgCircleVS = `
  attribute vec3 aPos;
  uniform mat4 uProj;
  uniform mat4 uView;
  uniform vec3 uCenter;
  uniform float uRadius;
  void main() {
    vec3 worldPos = uCenter + vec3(aPos.x * uRadius, 0.0, aPos.z * uRadius);
    gl_Position = uProj * uView * vec4(worldPos, 1.0);
  }
`;
const dbgCircleFS = `
  precision mediump float;
  uniform vec3 uColor;
  void main() {
    gl_FragColor = vec4(uColor, 1.0);
  }
`;
const dbgVS = createShader(gl.VERTEX_SHADER, dbgCircleVS);
const dbgFS = createShader(gl.FRAGMENT_SHADER, dbgCircleFS);
const dbgProg = gl.createProgram();
gl.attachShader(dbgProg, dbgVS);
gl.attachShader(dbgProg, dbgFS);
gl.linkProgram(dbgProg);

const dbgAPos = gl.getAttribLocation(dbgProg, 'aPos');
const dbgUProj = gl.getUniformLocation(dbgProg, 'uProj');
const dbgUView = gl.getUniformLocation(dbgProg, 'uView');
const dbgUCenter = gl.getUniformLocation(dbgProg, 'uCenter');
const dbgURadius = gl.getUniformLocation(dbgProg, 'uRadius');
const dbgUColor = gl.getUniformLocation(dbgProg, 'uColor');

// --- Pass-through line shader (uses vertex positions as-is) ---
const lineVS = `
  attribute vec3 aPos;
  uniform mat4 uProj;
  uniform mat4 uView;
  void main() {
    gl_Position = uProj * uView * vec4(aPos, 1.0);
  }
`;
const lineFS = `
  precision mediump float;
  uniform vec3 uColor;
  void main() {
    gl_FragColor = vec4(uColor, 1.0);
  }
`;
const lineVSh = createShader(gl.VERTEX_SHADER, lineVS);
const lineFSh = createShader(gl.FRAGMENT_SHADER, lineFS);
const lineProg = gl.createProgram();
gl.attachShader(lineProg, lineVSh);
gl.attachShader(lineProg, lineFSh);
gl.linkProgram(lineProg);
const lineAPos = gl.getAttribLocation(lineProg, 'aPos');
const lineUProj = gl.getUniformLocation(lineProg, 'uProj');
const lineUView = gl.getUniformLocation(lineProg, 'uView');
const lineUColor = gl.getUniformLocation(lineProg, 'uColor');

// Circle ring vertices (unit circle on XZ plane)
const DBG_RING_SEGS = 12;
const dbgRingVerts = new Float32Array(DBG_RING_SEGS * 3);
for (let i = 0; i < DBG_RING_SEGS; i++) {
  const a = (i / DBG_RING_SEGS) * Math.PI * 2;
  dbgRingVerts[i * 3] = Math.cos(a);
  dbgRingVerts[i * 3 + 1] = 0;
  dbgRingVerts[i * 3 + 2] = Math.sin(a);
}
const dbgRingVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, dbgRingVBO);
gl.bufferData(gl.ARRAY_BUFFER, dbgRingVerts, gl.STATIC_DRAW);

// Dotted ring: gl.LINES with every other pair of ring points (dashed circle)
const DBG_DOTTED_SEGS = 6; // 6 dashes (skip 6 gaps from 12 points)
const dbgDottedVerts = new Float32Array(DBG_DOTTED_SEGS * 2 * 3);
for (let i = 0; i < DBG_DOTTED_SEGS; i++) {
  const a0 = ((i * 2) / DBG_RING_SEGS) * Math.PI * 2;
  const a1 = ((i * 2 + 1) / DBG_RING_SEGS) * Math.PI * 2;
  dbgDottedVerts[i * 6]     = Math.cos(a0);
  dbgDottedVerts[i * 6 + 1] = 0;
  dbgDottedVerts[i * 6 + 2] = Math.sin(a0);
  dbgDottedVerts[i * 6 + 3] = Math.cos(a1);
  dbgDottedVerts[i * 6 + 4] = 0;
  dbgDottedVerts[i * 6 + 5] = Math.sin(a1);
}
const dbgDottedVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, dbgDottedVBO);
gl.bufferData(gl.ARRAY_BUFFER, dbgDottedVerts, gl.STATIC_DRAW);

// ============================================================
// Bitmap Font Text Renderer
// 5x7 pixel font, ASCII 32-126. Renders textured quads in GL.
// Usage:
//   textBegin(proj, view)           â€” call once per frame before drawing text
//   textWorld(str, x, y, z, opts)   â€” draw string at world position (billboarded)
//   textScreen(str, ndcX, ndcY, opts) â€” draw string at screen NDC position
//   textEnd()                       â€” flush and draw all queued text
// opts: { scale, r, g, b, a, shadow }
// ============================================================

// --- 5x7 pixel font data (each char = 5 columns, 7 rows, stored as 5 bytes per char) ---
const FONT_FIRST = 32, FONT_LAST = 126, FONT_W = 5, FONT_H = 7;
const FONT_DATA = (function() {
  // Each character: 5 columns, each column is 7 bits (bit 0 = top row)
  const raw = {
    32:[0,0,0,0,0],33:[0,0,95,0,0],34:[0,7,0,7,0],35:[20,127,20,127,20],
    36:[36,42,127,42,18],37:[35,19,8,100,98],38:[54,73,86,32,80],39:[0,0,7,0,0],
    40:[0,28,34,65,0],41:[0,65,34,28,0],42:[42,28,127,28,42],43:[8,8,62,8,8],
    44:[0,128,96,0,0],45:[8,8,8,8,8],46:[0,96,96,0,0],47:[32,16,8,4,2],
    48:[62,81,73,69,62],49:[0,66,127,64,0],50:[98,81,73,73,70],51:[34,65,73,73,54],
    52:[24,20,18,127,16],53:[39,69,69,69,57],54:[60,74,73,73,48],55:[1,1,113,9,7],
    56:[54,73,73,73,54],57:[6,73,73,41,30],58:[0,54,54,0,0],59:[0,128,118,0,0],
    60:[8,20,34,65,0],61:[20,20,20,20,20],62:[0,65,34,20,8],63:[2,1,89,9,6],
    64:[62,65,93,89,78],65:[126,9,9,9,126],66:[127,73,73,73,54],67:[62,65,65,65,34],
    68:[127,65,65,65,62],69:[127,73,73,73,65],70:[127,9,9,9,1],71:[62,65,73,73,58],
    72:[127,8,8,8,127],73:[0,65,127,65,0],74:[32,64,65,63,1],75:[127,8,20,34,65],
    76:[127,64,64,64,64],77:[127,2,4,2,127],78:[127,2,4,8,127],79:[62,65,65,65,62],
    80:[127,9,9,9,6],81:[62,65,81,33,94],82:[127,9,25,41,70],83:[38,73,73,73,50],
    84:[1,1,127,1,1],85:[63,64,64,64,63],86:[31,32,64,32,31],87:[63,64,48,64,63],
    88:[99,20,8,20,99],89:[7,8,112,8,7],90:[97,81,73,69,67],91:[0,127,65,65,0],
    92:[2,4,8,16,32],93:[0,65,65,127,0],94:[4,2,1,2,4],95:[64,64,64,64,64],
    96:[0,1,2,0,0],97:[32,84,84,84,120],98:[127,68,68,68,56],99:[56,68,68,68,40],
    100:[56,68,68,68,127],101:[56,84,84,84,24],102:[8,126,9,9,2],103:[24,164,164,164,124],
    104:[127,4,4,4,120],105:[0,68,125,64,0],106:[32,64,64,61,0],107:[127,16,40,68,0],
    108:[0,65,127,64,0],109:[124,4,120,4,120],110:[124,4,4,4,120],111:[56,68,68,68,56],
    112:[252,36,36,36,24],113:[24,36,36,36,252],114:[124,8,4,4,8],115:[72,84,84,84,36],
    116:[4,63,68,68,32],117:[60,64,64,64,124],118:[28,32,64,32,28],119:[60,64,48,64,60],
    120:[68,40,16,40,68],121:[28,160,160,160,124],122:[68,100,84,76,68],123:[0,8,54,65,0],
    124:[0,0,119,0,0],125:[0,65,54,8,0],126:[8,4,8,16,8],
  };
  // Build atlas: 96 chars in a 16x6 grid, each cell = 6x8 px (5x7 + 1px padding)
  const CELL_W = 6, CELL_H = 8, COLS = 16, ROWS = 6;
  const W = COLS * CELL_W, H = ROWS * CELL_H;
  const atlas = new Uint8Array(W * H * 4); // RGBA
  for (let code = FONT_FIRST; code <= FONT_LAST; code++) {
    const cols = raw[code];
    if (!cols) continue;
    const idx = code - FONT_FIRST;
    const cellX = (idx % COLS) * CELL_W;
    const cellY = Math.floor(idx / COLS) * CELL_H;
    for (let col = 0; col < 5; col++) {
      for (let row = 0; row < 7; row++) {
        if (cols[col] & (1 << row)) {
          const px = cellX + col;
          const py = cellY + row;
          const off = (py * W + px) * 4;
          atlas[off] = atlas[off+1] = atlas[off+2] = atlas[off+3] = 255;
        }
      }
    }
  }
  return { atlas, W, H, CELL_W, CELL_H, COLS, ROWS };
})();

// Upload font atlas texture
const fontTex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, fontTex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, FONT_DATA.W, FONT_DATA.H, 0, gl.RGBA, gl.UNSIGNED_BYTE, FONT_DATA.atlas);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

// Text shader
const textVS = `
  attribute vec2 aPos;
  attribute vec2 aUV;
  attribute vec4 aColor;
  varying vec2 vUV;
  varying vec4 vColor;
  void main() {
    vUV = aUV;
    vColor = aColor;
    gl_Position = vec4(aPos, 0.0, 1.0);
  }
`;
const textFS = `
  precision mediump float;
  varying vec2 vUV;
  varying vec4 vColor;
  uniform sampler2D uFont;
  void main() {
    float a = texture2D(uFont, vUV).a;
    if (a < 0.5) discard;
    gl_FragColor = vec4(vColor.rgb, vColor.a * a);
  }
`;
const textProg = (function() {
  const vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vs, textVS); gl.compileShader(vs);
  const fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fs, textFS); gl.compileShader(fs);
  const p = gl.createProgram();
  gl.attachShader(p, vs); gl.attachShader(p, fs); gl.linkProgram(p);
  return p;
})();
const txtAPos = gl.getAttribLocation(textProg, 'aPos');
const txtAUV = gl.getAttribLocation(textProg, 'aUV');
const txtAColor = gl.getAttribLocation(textProg, 'aColor');
const txtUFont = gl.getUniformLocation(textProg, 'uFont');

// Dynamic VBO for text quads (pos2 + uv2 + color4 = 8 floats per vert, 4 verts per char)
const TXT_MAX_CHARS = 512;
const txtVerts = new Float32Array(TXT_MAX_CHARS * 4 * 8);
const txtIdx = new Uint16Array(TXT_MAX_CHARS * 6);
for (let i = 0; i < TXT_MAX_CHARS; i++) {
  const b = i * 4;
  txtIdx[i*6] = b; txtIdx[i*6+1] = b+1; txtIdx[i*6+2] = b+2;
  txtIdx[i*6+3] = b; txtIdx[i*6+4] = b+2; txtIdx[i*6+5] = b+3;
}
const txtVBO = gl.createBuffer();
const txtIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, txtIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, txtIdx, gl.STATIC_DRAW);

let _txtCharCount = 0;
let _txtProj = null, _txtView = null;

// Begin text batch for this frame
function textBegin(proj, view) {
  _txtCharCount = 0;
  _txtProj = proj;
  _txtView = view;
}

// Project world pos to NDC
function _worldToNDC(wx, wy, wz) {
  const v = _txtView, p = _txtProj;
  const vx = v[0]*wx + v[4]*wy + v[8]*wz + v[12];
  const vy = v[1]*wx + v[5]*wy + v[9]*wz + v[13];
  const vz = v[2]*wx + v[6]*wy + v[10]*wz + v[14];
  const vw = v[3]*wx + v[7]*wy + v[11]*wz + v[15];
  const cx = p[0]*vx + p[4]*vy + p[8]*vz + p[12]*vw;
  const cy = p[1]*vx + p[5]*vy + p[9]*vz + p[13]*vw;
  const cw = p[3]*vx + p[7]*vy + p[11]*vz + p[15]*vw;
  if (cw === 0) return null;
  return [cx / cw, cy / cw];
}

// Add a single glyph quad in NDC space
function _addGlyph(code, ndcX, ndcY, glyphW, glyphH, r, g, b, a) {
  if (_txtCharCount >= TXT_MAX_CHARS) return;
  const idx = code - FONT_FIRST;
  if (idx < 0 || idx > FONT_LAST - FONT_FIRST) return;
  const col = idx % FONT_DATA.COLS;
  const row = Math.floor(idx / FONT_DATA.COLS);
  const u0 = (col * FONT_DATA.CELL_W) / FONT_DATA.W;
  const v0 = (row * FONT_DATA.CELL_H) / FONT_DATA.H;
  const u1 = (col * FONT_DATA.CELL_W + FONT_W) / FONT_DATA.W;
  const v1 = (row * FONT_DATA.CELL_H + FONT_H) / FONT_DATA.H;

  const off = _txtCharCount * 4 * 8;
  // Bottom-left, bottom-right, top-right, top-left
  const x0 = ndcX, x1 = ndcX + glyphW, y0 = ndcY, y1 = ndcY + glyphH;
  // v0=top of glyph in texture, v1=bottom â€” flip Y since NDC Y is up
  txtVerts[off]    = x0; txtVerts[off+1]  = y0; txtVerts[off+2]  = u0; txtVerts[off+3]  = v1; txtVerts[off+4]  = r; txtVerts[off+5]  = g; txtVerts[off+6]  = b; txtVerts[off+7]  = a;
  txtVerts[off+8]  = x1; txtVerts[off+9]  = y0; txtVerts[off+10] = u1; txtVerts[off+11] = v1; txtVerts[off+12] = r; txtVerts[off+13] = g; txtVerts[off+14] = b; txtVerts[off+15] = a;
  txtVerts[off+16] = x1; txtVerts[off+17] = y1; txtVerts[off+18] = u1; txtVerts[off+19] = v0; txtVerts[off+20] = r; txtVerts[off+21] = g; txtVerts[off+22] = b; txtVerts[off+23] = a;
  txtVerts[off+24] = x0; txtVerts[off+25] = y1; txtVerts[off+26] = u0; txtVerts[off+27] = v0; txtVerts[off+28] = r; txtVerts[off+29] = g; txtVerts[off+30] = b; txtVerts[off+31] = a;
  _txtCharCount++;
}

// Draw text at a world position (billboarded â€” always faces camera)
// opts: { scale, r, g, b, a, shadow, center }
function textWorld(str, wx, wy, wz, opts) {
  const ndc = _worldToNDC(wx, wy, wz);
  if (!ndc) return;
  const o = opts || {};
  textScreen(str, ndc[0], ndc[1], o);
}

// Draw text at NDC position (-1 to 1)
// opts: { scale, r, g, b, a, shadow, center }
function textScreen(str, ndcX, ndcY, opts) {
  const o = opts || {};
  const pixH = (o.scale || 10) * 2 / canvas.height; // glyph height in NDC
  const pixW = pixH * (FONT_W / FONT_H) * (canvas.height / canvas.width); // aspect-corrected width
  const spacing = pixW * 1.2; // 1 pixel gap between chars
  const r = o.r !== undefined ? o.r : 1;
  const g = o.g !== undefined ? o.g : 1;
  const b = o.b !== undefined ? o.b : 1;
  const a = o.a !== undefined ? o.a : 1;

  // Center text horizontally if requested (default true)
  const center = o.center !== undefined ? o.center : true;
  let startX = ndcX;
  if (center) startX -= (str.length * spacing) * 0.5;

  // Shadow pass (1px offset down-right)
  if (o.shadow !== false) {
    const sd = pixH * 0.15;
    for (let i = 0; i < str.length; i++) {
      const code = str.charCodeAt(i);
      if (code === 32) continue;
      _addGlyph(code, startX + i * spacing + sd, ndcY - sd, pixW, pixH, 0, 0, 0, a * 0.6);
    }
  }

  // Main pass
  for (let i = 0; i < str.length; i++) {
    const code = str.charCodeAt(i);
    if (code === 32) continue;
    _addGlyph(code, startX + i * spacing, ndcY, pixW, pixH, r, g, b, a);
  }
}

// Flush all queued text quads
function textEnd() {
  if (_txtCharCount === 0) return;
  gl.useProgram(textProg);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.disable(gl.DEPTH_TEST);

  gl.bindBuffer(gl.ARRAY_BUFFER, txtVBO);
  gl.bufferData(gl.ARRAY_BUFFER, txtVerts.subarray(0, _txtCharCount * 4 * 8), gl.DYNAMIC_DRAW);

  const stride = 8 * 4;
  gl.enableVertexAttribArray(txtAPos);
  gl.vertexAttribPointer(txtAPos, 2, gl.FLOAT, false, stride, 0);
  gl.enableVertexAttribArray(txtAUV);
  gl.vertexAttribPointer(txtAUV, 2, gl.FLOAT, false, stride, 8);
  gl.enableVertexAttribArray(txtAColor);
  gl.vertexAttribPointer(txtAColor, 4, gl.FLOAT, false, stride, 16);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, fontTex);
  gl.uniform1i(txtUFont, 0);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, txtIBO);
  gl.drawElements(gl.TRIANGLES, _txtCharCount * 6, gl.UNSIGNED_SHORT, 0);

  gl.disableVertexAttribArray(txtAColor);
  gl.enable(gl.DEPTH_TEST);
  gl.disable(gl.BLEND);
  _txtCharCount = 0;
}

// Model matrix: TRS with per-axis scale
const _modelMat = new Float32Array(16);
function buildModelMatrix(tx, ty, tz, rotY, rotZ, sx, sy, sz) {
  if (sy === undefined) { sy = sx; sz = sx; }
  const cy = Math.cos(rotY), sy2 = Math.sin(rotY);
  const cz = Math.cos(rotZ), sz2 = Math.sin(rotZ);
  const m00 = cy * cz,   m01 = cy * sz2,   m02 = -sy2;
  const m10 = -sz2,       m11 = cz,          m12 = 0;
  const m20 = sy2 * cz,  m21 = sy2 * sz2,  m22 = cy;
  _modelMat[0]  = m00*sx; _modelMat[1]  = m10*sx; _modelMat[2]  = m20*sx; _modelMat[3]  = 0;
  _modelMat[4]  = m01*sy; _modelMat[5]  = m11*sy; _modelMat[6]  = m21*sy; _modelMat[7]  = 0;
  _modelMat[8]  = m02*sz; _modelMat[9]  = m12*sz; _modelMat[10] = m22*sz; _modelMat[11] = 0;
  _modelMat[12] = tx;     _modelMat[13] = ty;     _modelMat[14] = tz;     _modelMat[15] = 1;
  return _modelMat;
}

// Precompute rock world data â€” now per-region

// Per-region biome and config assignment â€” every region explicitly defined
const regionBiomeMap = new Map(); // gx*1000+gz -> { biome, configIdx }
// Row gz=-1 (top)
regionBiomeMap.set(-1 * 1000 + -1, { biome: 'rock', configIdx: 2 });
regionBiomeMap.set( 0 * 1000 + -1, { biome: 'forest', configIdx: 5 });
regionBiomeMap.set( 1 * 1000 + -1, { biome: 'desert', configIdx: 1 });
// Row gz=0 (middle)
regionBiomeMap.set(-1 * 1000 +  0, { biome: 'forest', configIdx: 1 });
regionBiomeMap.set( 0 * 1000 +  0, { biome: 'forest', configIdx: 3 });
regionBiomeMap.set( 1 * 1000 +  0, { biome: 'desert', configIdx: 4 });
// Row gz=1 (bottom)
regionBiomeMap.set(-1 * 1000 +  1, { biome: 'desert', configIdx: 1 });
regionBiomeMap.set( 0 * 1000 +  1, { biome: 'forest', configIdx: 4 });
regionBiomeMap.set( 1 * 1000 +  1, { biome: 'forest', configIdx: 4 });

function getRegionAssignment(gx, gz) {
  const key = gx * 1000 + gz;
  return regionBiomeMap.get(key) || null;
}


// Build all world data for a region at grid position (gx, gz)
function buildRegion(gx, gz) {
  const assignment = getRegionAssignment(gx, gz);
  const biome = BIOMES[assignment.biome];
  const configIdx = assignment.configIdx;
  const config = biome.configs[configIdx];
  const hills = config.terrain.hills || [];
  const ox = gx * REGION_SIZE; // world offset x
  const oz = gz * REGION_SIZE; // world offset z

  // Terrain mesh
  const terrain = buildTerrainMesh(hills, gx, gz);

  // Tree data
  let trees = config.items.trees;
  // Compute per-edge border margins: non-zero only where neighbor is a different biome.
  // borderMargin is a biome-level property (UV units). Objects near these edges are
  // filtered out to prevent visual overlap into a different biome's region.
  const biomeName = assignment.biome;
  const baseMargin = biome.borderMargin || 0.03;
  const nLeftA  = getRegionAssignment(gx - 1, gz);
  const nRightA = getRegionAssignment(gx + 1, gz);
  const nTopA   = getRegionAssignment(gx, gz - 1);
  const nBotA   = getRegionAssignment(gx, gz + 1);
  const nLeft  = nLeftA  ? nLeftA.biome  : null;
  const nRight = nRightA ? nRightA.biome : null;
  const nTop   = nTopA   ? nTopA.biome   : null;
  const nBot   = nBotA   ? nBotA.biome   : null;
  // null neighbor = world edge. Only zero margin at top-left (-X) and
  // top-right (-Z) world edges (they face away from camera, nothing beyond).
  // Bottom-left (+Z) and bottom-right (+X) edges keep normal margins.
  const isTopLeftEdge  = (gx === -GRID_HALF);  // left side is -X world edge
  const isTopRightEdge = (gz === -GRID_HALF);   // top side is -Z world edge
  const borderLeft  = nLeft  === biomeName || (nLeft  === null && isTopLeftEdge)  ? 0 : baseMargin;
  const borderRight = nRight === biomeName ? 0 : baseMargin;
  const borderTop   = nTop   === biomeName || (nTop   === null && isTopRightEdge) ? 0 : baseMargin;
  const borderBot   = nBot   === biomeName ? 0 : baseMargin;
  const hasBorder = borderLeft > 0 || borderRight > 0 || borderTop > 0 || borderBot > 0;
  const isForest = biomeName === 'forest';

  // Filter trees at border margins: if a tree's collider is >=55% inside
  // the margin, nudge it inward to fit. Otherwise remove it.
  // For multi-collider trees (fir clusters), the nudge is the worst-case
  // across all colliders so every collider ends up inside.
  {
    const RS = 2 * S;
    const nudgeThreshold = 0.55; // keep if this fraction of radius is inside
    trees = trees.filter(t => {
      const v = expandVariant(t.v);
      const tv = v ? TREE_VARIANTS[v] : null;
      if (!tv) return true;
      const groups = tv.colGroups || [{ colOff: tv.colOff, colR: tv.colR }];
      // Compute worst-case overlap per direction across all colliders
      let worstL = 0, worstR = 0, worstT = 0, worstB = 0;
      let minMaxOverlap = Infinity;
      for (const cg of groups) {
        const rUV = cg.colR / RS;
        minMaxOverlap = Math.min(minMaxOverlap, rUV * (1 - nudgeThreshold));
        const cx = t.x + cg.colOff[0] / RS;
        const cz = t.z + cg.colOff[1] / RS;
        const overL = borderLeft  - (cx - rUV);
        const overR = (cx + rUV) - (1 - borderRight);
        const overT = borderTop  - (cz - rUV);
        const overB = (cz + rUV) - (1 - borderBot);
        if (overL > 0) worstL = Math.max(worstL, overL);
        if (overR > 0) worstR = Math.max(worstR, overR);
        if (overT > 0) worstT = Math.max(worstT, overT);
        if (overB > 0) worstB = Math.max(worstB, overB);
      }
      // If any single overlap exceeds threshold, kill immediately
      if (worstL > minMaxOverlap || worstR > minMaxOverlap ||
          worstT > minMaxOverlap || worstB > minMaxOverlap) return false;
      // Apply nudge
      const nudgeX = worstL - worstR;
      const nudgeZ = worstT - worstB;
      if (nudgeX !== 0 || nudgeZ !== 0) {
        t.x += nudgeX;
        t.z += nudgeZ;
        // Verify all colliders are now inside after nudge
        for (const cg of groups) {
          const rUV = cg.colR / RS;
          const cx = t.x + cg.colOff[0] / RS;
          const cz = t.z + cg.colOff[1] / RS;
          if (cx - rUV < borderLeft  || cx + rUV > 1 - borderRight ||
              cz - rUV < borderTop   || cz + rUV > 1 - borderBot) {
            // Nudge couldn't fix all colliders (e.g. contradictory directions)
            t.x -= nudgeX;
            t.z -= nudgeZ;
            return false;
          }
        }
      }
      return true;
    });
  }
  // Forest edge attraction: pull trees near an active border toward the margin
  // so they fill gaps at biome boundaries. Process trees closest to edges first.
  // Don't move a tree if it would overlap another tree's collider.
  if (isForest && hasBorder) {
    const RS = 2 * S;
    const attractDist = 0.08;

    // Helper: get outermost collider extent for a tree
    function treeExtent(t) {
      const v = expandVariant(t.v);
      const tv = v ? TREE_VARIANTS[v] : null;
      if (!tv) return null;
      const groups = tv.colGroups || [{ colOff: tv.colOff, colR: tv.colR }];
      let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
      let maxR = 0;
      for (const cg of groups) {
        const cx = t.x + cg.colOff[0] / RS;
        const cz = t.z + cg.colOff[1] / RS;
        const rUV = cg.colR / RS;
        minX = Math.min(minX, cx - rUV);
        maxX = Math.max(maxX, cx + rUV);
        minZ = Math.min(minZ, cz - rUV);
        maxZ = Math.max(maxZ, cz + rUV);
        maxR = Math.max(maxR, rUV);
      }
      return { minX, maxX, minZ, maxZ, maxR, groups };
    }

    // Helper: check if moving tree t by (dx, dz) would collide with any other tree
    function wouldCollide(t, dx, dz, tIdx) {
      const v = expandVariant(t.v);
      const tv = v ? TREE_VARIANTS[v] : null;
      if (!tv) return false;
      const groups = tv.colGroups || [{ colOff: tv.colOff, colR: tv.colR }];
      for (let j = 0; j < trees.length; j++) {
        if (j === tIdx) continue;
        const ot = trees[j];
        const ov = expandVariant(ot.v);
        const otv = ov ? TREE_VARIANTS[ov] : null;
        if (!otv) continue;
        const oGroups = otv.colGroups || [{ colOff: otv.colOff, colR: otv.colR }];
        for (const cg of groups) {
          const cx = t.x + dx + cg.colOff[0] / RS;
          const cz = t.z + dz + cg.colOff[1] / RS;
          const rUV = cg.colR / RS;
          for (const ocg of oGroups) {
            const ocx = ot.x + ocg.colOff[0] / RS;
            const ocz = ot.z + ocg.colOff[1] / RS;
            const orUV = ocg.colR / RS;
            const ddx = cx - ocx, ddz = cz - ocz;
            const minDist = rUV + orUV;
            if (ddx * ddx + ddz * ddz < minDist * minDist) return true;
          }
        }
      }
      return false;
    }

    // Build list of trees with their distance to nearest active border
    const edgeCandidates = [];
    for (let i = 0; i < trees.length; i++) {
      const ext = treeExtent(trees[i]);
      if (!ext) continue;
      let bestDist = Infinity, bestAxis = null, bestShift = 0;
      if (borderLeft > 0) {
        const d = ext.minX - borderLeft;
        if (d > 0 && d < attractDist && d < bestDist) { bestDist = d; bestAxis = 'x'; bestShift = -d; }
      }
      if (borderRight > 0) {
        const d = (1 - borderRight) - ext.maxX;
        if (d > 0 && d < attractDist && d < bestDist) { bestDist = d; bestAxis = 'x'; bestShift = d; }
      }
      if (borderTop > 0) {
        const d = ext.minZ - borderTop;
        if (d > 0 && d < attractDist && d < bestDist) { bestDist = d; bestAxis = 'z'; bestShift = -d; }
      }
      if (borderBot > 0) {
        const d = (1 - borderBot) - ext.maxZ;
        if (d > 0 && d < attractDist && d < bestDist) { bestDist = d; bestAxis = 'z'; bestShift = d; }
      }
      if (bestAxis) edgeCandidates.push({ idx: i, dist: bestDist, axis: bestAxis, shift: bestShift });
    }

    // Process closest to edge first
    edgeCandidates.sort((a, b) => a.dist - b.dist);
    for (const c of edgeCandidates) {
      const t = trees[c.idx];
      const dx = c.axis === 'x' ? c.shift : 0;
      const dz = c.axis === 'z' ? c.shift : 0;
      if (wouldCollide(t, dx, dz, c.idx)) continue;
      // Verify all colliders stay inside all margins after move
      const ext = treeExtent(t);
      if (!ext) continue;
      const newMinX = ext.minX + dx, newMaxX = ext.maxX + dx;
      const newMinZ = ext.minZ + dz, newMaxZ = ext.maxZ + dz;
      if (newMinX < borderLeft || newMaxX > 1 - borderRight ||
          newMinZ < borderTop  || newMaxZ > 1 - borderBot) continue;
      t.x += dx;
      t.z += dz;
    }
  }
  // Clear spawn area in region 0,0 so player doesn't spawn inside trees.
  // Uses collider centers (not billboard anchor) since colliders define the
  // interactive/visual trunk position. clearR includes the tree's own colR
  // so the collider circle doesn't intrude into spawn.
  if (gx === 0 && gz === 0) {
    const spawnU = 0.46, spawnV = 0.46, spawnClearBase = 0.09;
    const RS = 2 * S; // region size in world units, for worldâ†’UV conversion
    trees = trees.filter(t => {
      const v = expandVariant(t.v);
      const tv = TREE_VARIANTS[v];
      if (!tv) return true;
      // Build collider group list: use colGroups if defined, else single collider
      const groups = tv.colGroups || [{ colOff: tv.colOff, colR: tv.colR }];
      for (const cg of groups) {
        const cx = t.x + cg.colOff[0] / RS;
        const cz = t.z + cg.colOff[1] / RS;
        const rUV = cg.colR / RS;
        const du = cx - spawnU, dv = cz - spawnV;
        if (Math.sqrt(du * du + dv * dv) - rUV <= spawnClearBase) return false;
      }
      return true;
    });
  }
  const treePositions = trees.map((t, i) => {
    const wx = -S + t.x * 2 * S + ox;
    const wz = -S + t.z * 2 * S + oz;
    const wy = getBlendedHeight(hills, t.x, t.z, gx, gz);
    const variant = expandVariant(t.v);
    const tv = TREE_VARIANTS[variant] || TREE_VARIANTS.dry;
    // x,y,z = primary collider center (the "real" position of this tree for game logic)
    // billX,billY,billZ = billboard anchor (visual rendering only)
    const colX = wx + tv.colOff[0];
    const colZ = wz + tv.colOff[1];
    const colY = getBlendedHeight(hills, (colX - ox + S) / (2*S), (colZ - oz + S) / (2*S), gx, gz);
    const pos = {
      x: colX, y: colY, z: colZ,         // game position = collider center
      colX: colX, colZ: colZ, colR: tv.colR, // collider (matches x,z)
      billX: wx, billY: wy, billZ: wz,   // billboard visual anchor
    };
    // Multi-collider support: if colGroups defined, store extra colliders
    if (tv.colGroups) {
      pos.extraCols = tv.colGroups.slice(1).map(cg => ({
        colX: wx + cg.colOff[0], colZ: wz + cg.colOff[1], colR: cg.colR
      }));
    }
    return pos;
  });

  // Rock data â€” filter by collider vs region bounds [0,1]
  const filteredRocks = config.items.rocks.filter(r => {
    const rUV = ROCK_COLLISION_RADIUS_BASE * r.scale / (2 * S);
    if (r.x - rUV < 0 || r.x + rUV > 1) return false;
    if (r.z - rUV < 0 || r.z + rUV > 1) return false;
    return true;
  });
  const rocks = filteredRocks.map((r, i) => {
    const wx = -S + r.x * 2 * S + ox;
    const wz = -S + r.z * 2 * S + oz;
    const wy = getBlendedHeight(hills, r.x, r.z, gx, gz);
    const rockH = 0.175 * r.scale;
    return { x: wx, y: wy, z: wz, visY: wy + rockH * 0.5, colX: wx, colZ: wz, colR: ROCK_COLLISION_RADIUS_BASE * r.scale, rotY: r.rotY, scale: r.scale, h: rockH, meshIdx: i % ROCK_MESH_COUNT };
  });

  // Stick data â€” filter by collider vs region bounds [0,1]
  const stickColRUV = STICK_PASSTHROUGH_RADIUS / (2 * S);
  const stickColOffZUV = STICK_COL_OFFSET_Z / (2 * S);
  const filteredSticks = (config.items.sticks || []).filter(st => {
    const cz = st.z + stickColOffZUV;
    if (st.x - stickColRUV < 0 || st.x + stickColRUV > 1) return false;
    if (cz - stickColRUV < 0 || cz + stickColRUV > 1) return false;
    return true;
  });
  const sticks = filteredSticks.map(st => {
    const wx = -S + st.x * 2 * S + ox;
    const wz = -S + st.z * 2 * S + oz;
    const wy = getBlendedHeight(hills, st.x, st.z, gx, gz);
    // x,y,z = collider center (game position)
    // visX,visY,visZ = visual mesh position (tiny Y lift to prevent z-fighting)
    const colCZ = wz + STICK_COL_OFFSET_Z;
    return { x: wx, y: wy, z: colCZ, visX: wx, visY: wy + 0.01, visZ: wz, colX: wx, colZ: colCZ, colR: STICK_PASSTHROUGH_RADIUS, rotY: st.rotY, scale: st.scale, flip: st.flip || 0 };
  });

  // Minable data
  const minables = config.items.minables.map(cluster => {
    const baseWx = -S + cluster.x * 2 * S + ox;
    const baseWz = -S + cluster.z * 2 * S + oz;
    const mat = cluster.material;
    return {
      material: mat,
      cubes: cluster.cubes.map(c => {
        const wx = baseWx + c.dx * 2 * S;
        const wz = baseWz + c.dz * 2 * S;
        const sy = c.sy * 0.7;
        const cubeU = cluster.x + c.dx;
        const cubeV = cluster.z + c.dz;
        const cubeWy = getBlendedHeight(hills, cubeU, cubeV, gx, gz);
        return {
          x: wx, y: cubeWy + sy * 0.5, z: wz,
          rotY: c.rotY, rotZ: c.rotZ,
          sx: c.sx * 0.7, sy: sy, sz: c.sz * 0.7,
          glowSize: Math.max(c.sx, c.sy, c.sz) * 0.7 * 1.8,
          health: 1.0, mined: false,
        };
      }),
      // Convert baked UV colliders to world space
      colliders: cluster.colliders.map(col => {
        const wx = baseWx + col.dx * 2 * S;
        const wz = baseWz + col.dz * 2 * S;
        const wr = col.r * 2 * S;
        return { x: wx, z: wz, radius: wr, colX: wx, colZ: wz, colR: wr };
      }),
    };
  });

  // === Bake mineral mask per region on CPU ===
  // JS hash matching GLSL: hash(vec2 p) { p=fract(p*vec2(123.34,456.21)); p+=dot(p,p+45.32); return fract(p.x*p.y); }
  function fract(v) { return ((v % 1) + 1) % 1; }
  function jsHash(px, py) {
    let x = fract(px * 123.34), y = fract(py * 456.21);
    const d = x * (x + 45.32) + y * (y + 45.32);
    x = fract(x + d); y = fract(y + d);
    return fract(x * y);
  }

  function bakeMineralMask(glCtx, maskData, MASK_RES) {
    const tex = glCtx.createTexture();
    glCtx.bindTexture(glCtx.TEXTURE_2D, tex);
    glCtx.texImage2D(glCtx.TEXTURE_2D, 0, glCtx.LUMINANCE, MASK_RES, MASK_RES, 0, glCtx.LUMINANCE, glCtx.UNSIGNED_BYTE, maskData);
    glCtx.texParameteri(glCtx.TEXTURE_2D, glCtx.TEXTURE_MIN_FILTER, glCtx.NEAREST);
    glCtx.texParameteri(glCtx.TEXTURE_2D, glCtx.TEXTURE_MAG_FILTER, glCtx.NEAREST);
    glCtx.texParameteri(glCtx.TEXTURE_2D, glCtx.TEXTURE_WRAP_S, glCtx.CLAMP_TO_EDGE);
    glCtx.texParameteri(glCtx.TEXTURE_2D, glCtx.TEXTURE_WRAP_T, glCtx.CLAMP_TO_EDGE);
    return tex;
  }

  // Bake mineral mask texture from collider circles
  // 64x64 texture, each pixel stores the mask value (0-255)
  const MASK_RES = 128;
  const maskData = new Uint8Array(MASK_RES * MASK_RES);
  // Collect all circles for this region (in region-local UV 0-1 space)
  const blueCircles = [];
  for (const cluster of minables) {
    const mat = MINABLE_MATERIALS[cluster.material];
    if (!mat.crystalGroundOverlay) continue;
    for (const col of cluster.colliders) {
      const mult = col.radius < 0.08 ? 3.0 : col.radius < 0.15 ? 2.2 : 1.5;
      const u = (col.x - ox + S) / (2 * S);
      const v = (col.z - oz + S) / (2 * S);
      const rUV = (col.radius * mult) / (2 * S);
      blueCircles.push({ u, v, r: rUV });

      // Scatter small satellite squares around edges on all sides
      // Seeded from collider position for determinism
      let seed = (col.x * 127.1 + col.z * 311.7) * 43758.5453;
      const nextRand = () => { seed = (seed * 16807 + 0.5) % 2147483647; return (seed & 0xffff) / 0xffff; };
      const numSatellites = 5 + Math.floor(nextRand() * 4); // 5-8 per collider
      for (let s = 0; s < numSatellites; s++) {
        // Random angle around the square
        const angle = nextRand() * Math.PI * 2;
        // Distance: just outside the edge, 1.1-2.2x radius
        const distMult = 1.1 + nextRand() * 1.1;
        const dist = rUV * distMult;
        const su = u + Math.cos(angle) * dist;
        const sv = v + Math.sin(angle) * dist;
        // Size: smaller further away (30%-15% of parent radius)
        const sizeFrac = 0.30 - (distMult - 1.1) * 0.14;
        const sr = rUV * Math.max(sizeFrac, 0.10);
        blueCircles.push({ u: su, v: sv, r: sr });
      }
    }
  }
  // Paint mask by iterating each circle's bounding box (much faster than
  // testing every pixel against every circle). Since the test is an axis-aligned
  // square (max(|du|,|dv|) < r), the bounding box in pixels is exact.
  for (const c of blueCircles) {
    const pxMin = Math.max(0, Math.floor((c.u - c.r) * MASK_RES));
    const pxMax = Math.min(MASK_RES - 1, Math.floor((c.u + c.r) * MASK_RES));
    const pyMin = Math.max(0, Math.floor((c.v - c.r) * MASK_RES));
    const pyMax = Math.min(MASK_RES - 1, Math.floor((c.v + c.r) * MASK_RES));
    for (let py = pyMin; py <= pyMax; py++) {
      for (let px = pxMin; px <= pxMax; px++) {
        const u = (px + 0.5) / MASK_RES;
        const v = (py + 0.5) / MASK_RES;
        const d = Math.max(Math.abs(u - c.u), Math.abs(v - c.v));
        if (d < c.r) maskData[py * MASK_RES + px] = 255;
      }
    }
  }
  // Hole punch pass: only process pixels that were set
  for (let py = 0; py < MASK_RES; py++) {
    for (let px = 0; px < MASK_RES; px++) {
      if (maskData[py * MASK_RES + px] === 0) continue;
      const u = (px + 0.5) / MASK_RES;
      const v = (py + 0.5) / MASK_RES;
      const wx = ox + (-S + u * 2 * S);
      const wz = oz + (-S + v * 2 * S);
      const sf = 0.42 * 12.0;
      const hx = Math.floor(wx * sf), hz = Math.floor(wz * sf);
      const hr = jsHash(hx + 33.3, hz + 33.3);
      const nL = jsHash(hx - 1 + 33.3, hz + 33.3) >= 0.68 ? 1 : 0;
      const nR = jsHash(hx + 1 + 33.3, hz + 33.3) >= 0.68 ? 1 : 0;
      const nU = jsHash(hx + 33.3, hz - 1 + 33.3) >= 0.68 ? 1 : 0;
      const nD = jsHash(hx + 33.3, hz + 1 + 33.3) >= 0.68 ? 1 : 0;
      if (nL + nR + nU + nD === 0) {
        const j = jsHash(hx + 88.8, hz + 88.8);
        const jx = j >= 0.5 ? 1 : 0, jz = j >= 0.7 ? 1 : 0;
        const hrBlend = hr * 0.7 + jsHash(hx + jx + 33.3, hz + jz + 33.3) * 0.3;
        if (hrBlend >= 0.68) maskData[py * MASK_RES + px] = 0;
      }
    }
  }
  const mineralMaskTex = bakeMineralMask(gl, maskData, MASK_RES);

  // Build small mineral overlay mesh: one terrain-hugging quad per cluster
  // Each cluster's colliders define a bounding box; we subdivide it into a
  // small grid so it follows terrain height. Much cheaper than full terrain.
  let mineralMesh = null;
  if (blueCircles.length > 0) {
    const mVerts = [];
    const mIdx = [];
    let mVi = 0;
    const SUB = 4; // subdivisions per cluster quad

    for (const cluster of minables) {
      // Find bounding box of this cluster's collider circles in UV space
      let uMin = 1, uMax = 0, vMin = 1, vMax = 0;
      for (const col of cluster.colliders) {
        const mult = col.radius < 0.08 ? 3.0 : col.radius < 0.15 ? 2.2 : 1.5;
        const cu = (col.x - ox + S) / (2 * S);
        const cv = (col.z - oz + S) / (2 * S);
        const cr = (col.radius * mult) / (2 * S);
        uMin = Math.min(uMin, cu - cr);
        uMax = Math.max(uMax, cu + cr);
        vMin = Math.min(vMin, cv - cr);
        vMax = Math.max(vMax, cv + cr);
      }
      // Clamp to valid range with padding for satellite squares (scatter up to 2.2x radius out)
      const maxScatter = 0.05; // generous padding for satellites
      uMin = Math.max(-0.02, uMin - maxScatter);
      uMax = Math.min(1.02, uMax + maxScatter);
      vMin = Math.max(-0.02, vMin - maxScatter);
      vMax = Math.min(1.02, vMax + maxScatter);

      // Build subdivided quad grid
      const baseVi = mVi;
      for (let sj = 0; sj <= SUB; sj++) {
        for (let si = 0; si <= SUB; si++) {
          const u = uMin + (si / SUB) * (uMax - uMin);
          const v = vMin + (sj / SUB) * (vMax - vMin);
          const lx = -S + u * 2 * S;
          const lz = -S + v * 2 * S;
          const ly = getBlendedHeight(hills, u, v, gx, gz) + 0.005;
          mVerts.push(lx, ly, lz, u, v);
          mVi++;
        }
      }
      for (let sj = 0; sj < SUB; sj++) {
        for (let si = 0; si < SUB; si++) {
          const tl = baseVi + sj * (SUB + 1) + si;
          const tr = tl + 1;
          const bl = tl + (SUB + 1);
          const br = bl + 1;
          mIdx.push(tl, bl, tr, tr, bl, br);
        }
      }
    }

    if (mIdx.length > 0) {
      const mVbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, mVbo);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mVerts), gl.STATIC_DRAW);
      const mIbo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mIbo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mIdx), gl.STATIC_DRAW);
      mineralMesh = { vbo: mVbo, ibo: mIbo, idxCount: mIdx.length };
    }
  }

  return {
    gx, gz, ox, oz, configIdx, hills, biomeName: assignment.biome,
    terrain, treeVarIdx: trees.map(t => expandVariant(t.v)), treePositions, rocks, sticks, minables, mineralMaskTex, mineralMesh
  };
}

// Active regions cache: key "gx,gz" -> region data
const regionCache = new Map();

function getRegion(gx, gz) {
  const key = gx * 1000 + gz;
  if (!regionCache.has(key)) {
    regionCache.set(key, buildRegion(gx, gz));
  }
  return regionCache.get(key);
}

// Preallocated buffers for getActiveRegions (avoids per-frame GC pressure)
const _frustumMat = new Float32Array(16);
const _frustumPlanes = [new Float32Array(4), new Float32Array(4), new Float32Array(4), new Float32Array(4)];
const _activeRegions = [];

// Returns array of regions visible in the current camera view
function getActiveRegions(playerX, playerZ, proj, view) {
  // Build combined proj*view matrix for frustum testing
  const m = _frustumMat;
  for (let r = 0; r < 4; r++) {
    for (let c = 0; c < 4; c++) {
      m[r * 4 + c] = proj[c] * view[r * 4] + proj[4 + c] * view[r * 4 + 1] + proj[8 + c] * view[r * 4 + 2] + proj[12 + c] * view[r * 4 + 3];
    }
  }
  // Extract frustum planes (left, right, bottom, top) into preallocated arrays
  // For ortho, we only need these 4 (near/far are huge)
  const p0 = _frustumPlanes[0], p1 = _frustumPlanes[1], p2 = _frustumPlanes[2], p3 = _frustumPlanes[3];
  p0[0]=m[3]+m[0]; p0[1]=m[7]+m[4]; p0[2]=m[11]+m[8];  p0[3]=m[15]+m[12]; // left
  p1[0]=m[3]-m[0]; p1[1]=m[7]-m[4]; p1[2]=m[11]-m[8];  p1[3]=m[15]-m[12]; // right
  p2[0]=m[3]+m[1]; p2[1]=m[7]+m[5]; p2[2]=m[11]+m[9];  p2[3]=m[15]+m[13]; // bottom
  p3[0]=m[3]-m[1]; p3[1]=m[7]-m[5]; p3[2]=m[11]-m[9];  p3[3]=m[15]-m[13]; // top
  // Normalize planes
  for (let i = 0; i < 4; i++) {
    const p = _frustumPlanes[i];
    const len = Math.sqrt(p[0]*p[0] + p[1]*p[1] + p[2]*p[2]);
    if (len > 0) { p[0]/=len; p[1]/=len; p[2]/=len; p[3]/=len; }
  }

  _activeRegions.length = 0;
  const hs = S; // half-size of region
  for (let gz = -GRID_HALF; gz <= GRID_HALF; gz++) {
    for (let gx = -GRID_HALF; gx <= GRID_HALF; gx++) {
      const cx = gx * REGION_SIZE;
      const cz = gz * REGION_SIZE;
      // Test region AABB against frustum (use generous Y range)
      let visible = true;
      for (let i = 0; i < 4; i++) {
        const p = _frustumPlanes[i];
        // Find the corner most in the direction of the plane normal
        const px = p[0] > 0 ? cx + hs : cx - hs;
        const py = p[1] > 0 ? 2.0 : 0;  // generous height range
        const pz = p[2] > 0 ? cz + hs : cz - hs;
        if (p[0]*px + p[1]*py + p[2]*pz + p[3] < -1.0) {
          visible = false;
          break;
        }
      }
      if (visible) {
        _activeRegions.push(getRegion(gx, gz));
      }
    }
  }
  return _activeRegions;
}

// Helper: get hill height at an absolute world position
// Fast path uses regionCache to avoid re-deriving biome/config
function getWorldHeight(wx, wz) {
  const gx = Math.round(wx / REGION_SIZE);
  const gz = Math.round(wz / REGION_SIZE);
  const cgx = Math.max(-GRID_HALF, Math.min(GRID_HALF, gx));
  const cgz = Math.max(-GRID_HALF, Math.min(GRID_HALF, gz));
  const lx = wx - cgx * REGION_SIZE;
  const lz = wz - cgz * REGION_SIZE;
  const u = (lx + S) / (2 * S);
  const v = (lz + S) / (2 * S);
  // Fast path: use cached region if available
  const key = cgx * 1000 + cgz;
  const cached = regionCache.get(key);
  if (cached) return getBlendedHeight(cached.hills, u, v, cgx, cgz);
  // Slow path: derive from biome config
  const assignment = getRegionAssignment(cgx, cgz);
  const biome = BIOMES[assignment.biome];
  const config = biome.configs[assignment.configIdx];
  const hills = config.terrain.hills || [];
  return getBlendedHeight(hills, u, v, cgx, cgz);
}

// --- Character (collision cylinder) ---
// Cylinder: radius 0.15, height 0.5 (roughly half tree height)
const CHAR_RADIUS = 0.15;
const CHAR_HEIGHT = 0.5;
const CHAR_SPEED = 4.0; // world units per second
const CAM_DEADZONE = 1.20; // camera deadzone radius in world units
const STEP_DT = 1 / 120; // fixed physics step (~8.33ms)
const MAX_STEPS = 8;      // max sub-steps per frame (prevents spiral of death)

// Generate cylinder mesh (reuses cubeProg shader)
const CYL_SEGS = 12;
const cylVerts = [];
const cylIdx = [];

// Side faces
for (let i = 0; i < CYL_SEGS; i++) {
  const a0 = (i / CYL_SEGS) * Math.PI * 2;
  const a1 = ((i + 1) / CYL_SEGS) * Math.PI * 2;
  const c0 = Math.cos(a0), s0 = Math.sin(a0);
  const c1 = Math.cos(a1), s1 = Math.sin(a1);
  const nx0 = c0, nz0 = s0, nx1 = c1, nz1 = s1;
  const base = cylVerts.length / 6;
  // 4 verts per quad: bottom-left, bottom-right, top-right, top-left
  cylVerts.push(
    c0*0.5, -0.5, s0*0.5,  nx0, 0, nz0,
    c1*0.5, -0.5, s1*0.5,  nx1, 0, nz1,
    c1*0.5,  0.5, s1*0.5,  nx1, 0, nz1,
    c0*0.5,  0.5, s0*0.5,  nx0, 0, nz0,
  );
  cylIdx.push(base, base+1, base+2, base, base+2, base+3);
}

// Top cap
const topBase = cylVerts.length / 6;
cylVerts.push(0, 0.5, 0,  0, 1, 0); // center
for (let i = 0; i < CYL_SEGS; i++) {
  const a = (i / CYL_SEGS) * Math.PI * 2;
  cylVerts.push(Math.cos(a)*0.5, 0.5, Math.sin(a)*0.5,  0, 1, 0);
}
for (let i = 0; i < CYL_SEGS; i++) {
  cylIdx.push(topBase, topBase + 1 + i, topBase + 1 + ((i + 1) % CYL_SEGS));
}

// Bottom cap
const botBase = cylVerts.length / 6;
cylVerts.push(0, -0.5, 0,  0, -1, 0);
for (let i = 0; i < CYL_SEGS; i++) {
  const a = (i / CYL_SEGS) * Math.PI * 2;
  cylVerts.push(Math.cos(a)*0.5, -0.5, Math.sin(a)*0.5,  0, -1, 0);
}
for (let i = 0; i < CYL_SEGS; i++) {
  cylIdx.push(botBase, botBase + 1 + ((i + 1) % CYL_SEGS), botBase + 1 + i);
}

const cylVertData = new Float32Array(cylVerts);
const cylIdxData = new Uint16Array(cylIdx);
const cylIdxCount = cylIdx.length;

const cylVBO = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cylVBO);
gl.bufferData(gl.ARRAY_BUFFER, cylVertData, gl.STATIC_DRAW);

const cylIBO = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylIBO);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cylIdxData, gl.STATIC_DRAW);

// Character state
const player = {
  x: -0.4,
  z: -0.4,
  y: 0,  // computed from terrain
};

// WASD input tracking (use KeyCode for reliable multi-key)
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Gamepad input
const gamepadState = { lx: 0, lz: 0 };
const DEADZONE = 0.15;

// Touch-to-move: single finger hold moves player toward touch direction
const touchMoveState = { active: false, screenX: 0, screenY: 0, _startX: 0, _startY: 0, _holdTimer: 0 };

function pollGamepad() {
  try {
    const gamepads = navigator.getGamepads();
    for (const gp of gamepads) {
      if (!gp) continue;
      let lx = gp.axes[0] || 0;
      let ly = gp.axes[1] || 0;
      if (Math.abs(lx) < DEADZONE) lx = 0;
      if (Math.abs(ly) < DEADZONE) ly = 0;
      gamepadState.lx = lx;
      gamepadState.lz = ly;
      return;
    }
  } catch(e) {}
  gamepadState.lx = 0;
  gamepadState.lz = 0;
}

// Convert world position to UV for terrain height lookup
// --- Collision interaction table ---
// RULE: "collision with a tree" always means the tree's collider circle (colX, colZ, colR),
// never the billboard anchor or billboard bounding box. The collider represents the visible
// trunk/canopy mass and is the only geometry used for proximity checks, spawn clearance,
// overlap testing, and player blocking.
// Each object type has: blocksPlayer (pushes player out), debug viz style.
// Future: add blocksNPC, blocksProjectile, etc.
const COLLIDER_TYPES = {
  tree:    { blocksPlayer: true,  debugColor: [1.0, 0.15, 0.1],  debugStyle: 'solid'  },
  rock:    { blocksPlayer: true,  debugColor: [1.0, 0.85, 0.1],  debugStyle: 'solid'  },
  minable: { blocksPlayer: true,  debugColor: [0.7, 0.15, 0.9],  debugStyle: 'solid'  },
  stick:   { blocksPlayer: false, debugColor: [0.2, 0.85, 0.85], debugStyle: 'dotted' },
};

// Build unified collider list per region (called once at region init, no per-frame alloc)
function buildRegionColliders(reg) {
  const colliders = [];
  for (const t of reg.treePositions) {
    colliders.push({ type: 'tree', colX: t.colX, colZ: t.colZ, colR: t.colR, src: t });
    if (t.extraCols) {
      for (const ec of t.extraCols) {
        colliders.push({ type: 'tree', colX: ec.colX, colZ: ec.colZ, colR: ec.colR, src: t });
      }
    }
  }
  for (const r of reg.rocks) {
    colliders.push({ type: 'rock', colX: r.colX, colZ: r.colZ, colR: r.colR, src: r });
  }
  for (const cluster of reg.minables) {
    for (const col of cluster.colliders) {
      colliders.push({ type: 'minable', colX: col.colX, colZ: col.colZ, colR: col.colR, src: col });
    }
  }
  for (const st of reg.sticks) {
    colliders.push({ type: 'stick', colX: st.colX, colZ: st.colZ, colR: st.colR, src: st });
  }
  reg.allColliders = colliders;
}

function resolveCollisions(activeRegions) {
  for (const reg of activeRegions) {
    if (!reg.allColliders) buildRegionColliders(reg);
    for (const col of reg.allColliders) {
      const ct = COLLIDER_TYPES[col.type];
      if (!ct || !ct.blocksPlayer) continue;
      const minDist = CHAR_RADIUS + col.colR;
      const dx = player.x - col.colX, dz = player.z - col.colZ;
      const distSq = dx * dx + dz * dz;
      if (distSq < minDist * minDist && distSq > 0.000001) {
        const dist = Math.sqrt(distSq);
        const push = (minDist - dist) / dist;
        player.x += dx * push;
        player.z += dz * push;
      }
    }
  }
  // Clamp to world grid bounds
  const worldHalf = (GRID_HALF + 0.5) * REGION_SIZE;
  player.x = Math.max(-worldHalf + CHAR_RADIUS, Math.min(worldHalf - CHAR_RADIUS, player.x));
  player.z = Math.max(-worldHalf + CHAR_RADIUS, Math.min(worldHalf - CHAR_RADIUS, player.z));
}

// --- Matrix helpers ---
const _orthoMat = new Float32Array(16);
function ortho(left, right, bottom, top, near, far) {
  const lr = 1 / (left - right);
  const bt = 1 / (bottom - top);
  const nf = 1 / (near - far);
  _orthoMat[0] = -2*lr; _orthoMat[1] = 0; _orthoMat[2] = 0; _orthoMat[3] = 0;
  _orthoMat[4] = 0; _orthoMat[5] = -2*bt; _orthoMat[6] = 0; _orthoMat[7] = 0;
  _orthoMat[8] = 0; _orthoMat[9] = 0; _orthoMat[10] = 2*nf; _orthoMat[11] = 0;
  _orthoMat[12] = (left+right)*lr; _orthoMat[13] = (top+bottom)*bt; _orthoMat[14] = (far+near)*nf; _orthoMat[15] = 1;
  return _orthoMat;
}

const _viewMat = new Float32Array(16);
const _eyeVec = new Float32Array(3);
const _upVec = new Float32Array([0, 1, 0]);
function lookAt(eye, center, up) {
  // Forward (z axis)
  let zx = eye[0]-center[0], zy = eye[1]-center[1], zz = eye[2]-center[2];
  let l = Math.sqrt(zx*zx+zy*zy+zz*zz);
  zx /= l; zy /= l; zz /= l;
  // Right (x axis) = up cross z
  let xx = up[1]*zz-up[2]*zy, xy = up[2]*zx-up[0]*zz, xz = up[0]*zy-up[1]*zx;
  l = Math.sqrt(xx*xx+xy*xy+xz*xz);
  xx /= l; xy /= l; xz /= l;
  // True up (y axis) = z cross x
  const yx = zy*xz-zz*xy, yy = zz*xx-zx*xz, yz = zx*xy-zy*xx;
  _viewMat[0] = xx; _viewMat[1] = yx; _viewMat[2] = zx; _viewMat[3] = 0;
  _viewMat[4] = xy; _viewMat[5] = yy; _viewMat[6] = zy; _viewMat[7] = 0;
  _viewMat[8] = xz; _viewMat[9] = yz; _viewMat[10] = zz; _viewMat[11] = 0;
  _viewMat[12] = -(xx*eye[0]+xy*eye[1]+xz*eye[2]);
  _viewMat[13] = -(yx*eye[0]+yy*eye[1]+yz*eye[2]);
  _viewMat[14] = -(zx*eye[0]+zy*eye[1]+zz*eye[2]);
  _viewMat[15] = 1;
  return _viewMat;
}

// --- Interactive Camera ---
let camRotY = Math.PI / 4;        // horizontal orbit angle
let camRotX = Math.atan(1 / Math.sqrt(2)); // elevation (~35.26Ã‚Â° isometric)
let camDist = 8;  // ortho half-size (zoom level)
let camTarget = [-0.4, 0, -0.4];        // look-at point (Y fixed — ortho iso needs only XZ)

// Right-click drag to pan/orbit
let isDragging = false;
let lastMouse = [0, 0];

canvas.addEventListener('contextmenu', e => e.preventDefault());

canvas.addEventListener('mousedown', e => {
  if (e.button === 2) {
    isDragging = true;
    lastMouse[0] = e.clientX; lastMouse[1] = e.clientY;
  }
});

window.addEventListener('mouseup', e => {
  if (e.button === 2) isDragging = false;
});

window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - lastMouse[0];
  const dy = e.clientY - lastMouse[1];
  lastMouse[0] = e.clientX; lastMouse[1] = e.clientY;

  // Pan the target in the ground plane relative to camera orientation
  const panSpeed = 0.02 * (camDist / 8);
  const sinY = Math.sin(camRotY);
  const cosY = Math.cos(camRotY);

  // Right vector on ground plane
  camTarget[0] -= (cosY * dx + sinY * dy) * panSpeed;
  camTarget[2] -= (-sinY * dx + cosY * dy) * panSpeed;
  if (!render._cameraPanned) {
    // First pan movement — freeze current viz bias offset
    render._panFrozenBiasX = render._vizBiasX || 0;
    render._panFrozenBiasZ = render._vizBiasZ || 0;
  }
  render._cameraPanned = true;
  render._camUncapped = false; render._panReturnSpeed = 0;
});

// Scroll to zoom â€” use precomputed level table for consistency
const zoomTable = [8]; // index 0 = default
// Build zoom-in levels
let _d = 8;
while (_d > 2.01) { _d -= _d * 0.13; zoomTable.unshift(Math.max(2, _d)); }
// Build zoom-out levels
_d = 8;
while (_d < 19.9) { _d += _d * 0.195; zoomTable.push(Math.min(20, _d)); }
const zoomDefaultIdx = zoomTable.indexOf(8);
let zoomIdx = zoomDefaultIdx;

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  if (e.deltaY > 0 && zoomIdx < zoomTable.length - 1) { zoomIdx++; }
  else if (e.deltaY < 0 && zoomIdx > 0) { zoomIdx--; }
  camDist = zoomTable[zoomIdx];
}, { passive: false });

// Touch pinch zoom for tablets + single-touch movement
let touchStartDist = 0;
let touchStartCamDist = 0;
let touchIsPinching = false;
canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 2) {
    e.preventDefault();
    touchIsPinching = true;
    touchMoveState.active = false; // cancel move during pinch
    clearTimeout(touchMoveState._holdTimer);
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchStartDist = Math.sqrt(dx * dx + dy * dy);
    touchStartCamDist = camDist;
  } else if (e.touches.length === 1) {
    // Single touch: activate movement after small drag or short hold
    touchIsPinching = false;
    touchMoveState.screenX = e.touches[0].clientX;
    touchMoveState.screenY = e.touches[0].clientY;
    touchMoveState.active = false;
    touchMoveState._startX = e.touches[0].clientX;
    touchMoveState._startY = e.touches[0].clientY;
    // Activate after 150ms hold even without drag
    clearTimeout(touchMoveState._holdTimer);
    touchMoveState._holdTimer = setTimeout(() => {
      if (!touchIsPinching && !touchMoveState.active) touchMoveState.active = true;
    }, 150);
  }
}, { passive: false });
canvas.addEventListener('touchmove', e => {
  if (e.touches.length === 2) {
    e.preventDefault();
    touchIsPinching = true;
    touchMoveState.active = false;
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const ratio = touchStartDist / dist;
    camDist = Math.max(2, Math.min(20, touchStartCamDist * ratio));
  } else if (e.touches.length === 1 && !touchIsPinching) {
    e.preventDefault();
    touchMoveState.screenX = e.touches[0].clientX;
    touchMoveState.screenY = e.touches[0].clientY;
    // Activate after moving a small distance from start (deadzone to avoid accidental taps)
    if (!touchMoveState.active) {
      const ddx = touchMoveState.screenX - touchMoveState._startX;
      const ddy = touchMoveState.screenY - touchMoveState._startY;
      if (ddx * ddx + ddy * ddy > 10 * 10) touchMoveState.active = true;
    }
  }
}, { passive: false });
canvas.addEventListener('touchend', e => {
  clearTimeout(touchMoveState._holdTimer);
  if (e.touches.length === 0) {
    touchMoveState.active = false;
    touchIsPinching = false;
  } else if (e.touches.length === 1 && touchIsPinching) {
    // Went from 2 fingers to 1 — don't start moving, wait for fresh single touch
    touchIsPinching = false;
    touchMoveState.active = false;
  }
});
canvas.addEventListener('touchcancel', () => {
  clearTimeout(touchMoveState._holdTimer);
  touchMoveState.active = false;
  touchIsPinching = false;
});

// --- Fullscreen toggle ---
const fsBtn = document.getElementById('fsBtn');
const fsIcon = document.getElementById('fsIcon');

const expandSVG = '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>';
const shrinkSVG = '<polyline points="4 14 4 20 10 20"/><polyline points="20 10 20 4 14 4"/><line x1="14" y1="10" x2="20" y2="4"/><line x1="4" y1="20" x2="10" y2="14"/>';

fsBtn.addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

document.addEventListener('fullscreenchange', () => {
  fsIcon.innerHTML = document.fullscreenElement ? shrinkSVG : expandSVG;
});

// --- Stats toggle ---
const statsWrap = document.getElementById('statsWrap');
const statsPanel = document.getElementById('stats');
const statsToggle = document.getElementById('statsToggle');
const statsArrow = document.getElementById('statsArrow');
let statsOpen = true;

// FPS cap
let fpsCap = 0; // 0 = uncapped
let lastFrameTime = 0;
const fpsCapBtn = document.getElementById('fpsCapBtn');

function updateFpsCapBtn() {
  if (fpsCap > 0) {
    fpsCapBtn.innerHTML = '60';
    fpsCapBtn.style.background = 'linear-gradient(180deg, #1a1a3a 0%, #0a0a1f 100%)';
    fpsCapBtn.title = 'FPS cap: 60';
  } else {
    fpsCapBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="rgba(255,255,255,0.7)" stroke-width="2.5" stroke-linecap="round"><line x1="5" y1="19" x2="19" y2="5"/></svg>';
    fpsCapBtn.style.background = 'linear-gradient(180deg, #2a2a30 0%, #0a0a0f 100%)';
    fpsCapBtn.title = 'FPS cap: off';
  }
}

fpsCapBtn.addEventListener('click', () => {
  fpsCap = fpsCap > 0 ? 0 : 60;
  updateFpsCapBtn();
});
updateFpsCapBtn();

statsToggle.addEventListener('click', () => {
  statsOpen = !statsOpen;
  const fsBtn = document.getElementById('fsBtn');
  const colBtn = document.getElementById('colBtn');
  const hillBtn = document.getElementById('hillBtn');
  const biomeHud = document.getElementById('biomeHud');
  if (statsOpen) {
    statsPanel.style.display = '';
    fsBtn.style.display = '';
    colBtn.style.display = '';
    hillBtn.style.display = '';
    biomeHud.style.display = '';
    fpsCapBtn.style.display = '';
    statsArrow.innerHTML = '<polyline points="15 18 9 12 15 6"/>';
    statsToggle.title = 'Hide UI';
  } else {
    statsPanel.style.display = 'none';
    fsBtn.style.display = 'none';
    colBtn.style.display = 'none';
    hillBtn.style.display = 'none';
    biomeHud.style.display = 'none';
    fpsCapBtn.style.display = 'none';
    statsArrow.innerHTML = '<polyline points="9 18 15 12 9 6"/>';
    statsToggle.title = 'Show UI';
  }
});

let showColliders = false;
const colBtn = document.getElementById('colBtn');
colBtn.addEventListener('click', () => {
  showColliders = !showColliders;
  colBtn.classList.toggle('active', showColliders);
});

const hillBtn = document.getElementById('hillBtn');
hillBtn.addEventListener('click', () => {
  window._debugFlatTerrain = !window._debugFlatTerrain;
  hillBtn.classList.toggle('active', window._debugFlatTerrain);
  regionCache.clear();
});

// --- Biome HUD: custom config dropdown ---
const regionCoordsEl = document.getElementById('regionCoords');
const biomeDropdown = document.getElementById('biomeDropdown');
const biomeSelected = document.getElementById('biomeSelected');
const biomeOptions = document.getElementById('biomeOptions');
const configDropdown = document.getElementById('configDropdown');
const configSelected = document.getElementById('configSelected');
const configOptions = document.getElementById('configOptions');

const biomeNames = Object.keys(BIOMES); // ['rock', 'forest', 'desert']

function populateBiomeDropdown(currentBiome) {
  biomeSelected.textContent = currentBiome.charAt(0).toUpperCase() + currentBiome.slice(1);
  biomeOptions.innerHTML = '';
  for (const bKey of biomeNames) {
    const opt = document.createElement('div');
    opt.className = 'biome-opt' + (bKey === currentBiome ? ' active' : '');
    opt.textContent = bKey.charAt(0).toUpperCase() + bKey.slice(1);
    opt.dataset.biome = bKey;
    opt.addEventListener('click', (e) => {
      e.stopPropagation();
      const newBiome = opt.dataset.biome;
      const pgx = Math.round(player.x / REGION_SIZE);
      const pgz = Math.round(player.z / REGION_SIZE);
      // Switch biome, default to first config
      regionBiomeMap.set(pgx * 1000 + pgz, { biome: newBiome, configIdx: 0 });
      for (let dz = -1; dz <= 1; dz++) {
        for (let dx = -1; dx <= 1; dx++) {
          regionCache.delete((pgx + dx) * 1000 + (pgz + dz));
        }
      }
      biomeOptions.classList.remove('open');
      populateDropdowns();
    });
    biomeOptions.appendChild(opt);
  }
}

function populateConfigDropdown(currentBiome, currentConfigIdx) {
  configSelected.textContent = (currentConfigIdx + 1);
  configOptions.innerHTML = '';
  const configs = BIOMES[currentBiome].configs;
  for (let i = 0; i < configs.length; i++) {
    const opt = document.createElement('div');
    opt.className = 'cfg-opt' + (i === currentConfigIdx ? ' active' : '');
    opt.textContent = i + 1;
    opt.dataset.idx = i;
    opt.addEventListener('click', (e) => {
      e.stopPropagation();
      const idx = parseInt(opt.dataset.idx);
      const pgx = Math.round(player.x / REGION_SIZE);
      const pgz = Math.round(player.z / REGION_SIZE);
      const curAssignment = getRegionAssignment(pgx, pgz);
      regionBiomeMap.set(pgx * 1000 + pgz, { biome: curAssignment.biome, configIdx: idx });
      for (let dz = -1; dz <= 1; dz++) {
        for (let dx = -1; dx <= 1; dx++) {
          regionCache.delete((pgx + dx) * 1000 + (pgz + dz));
        }
      }
      configOptions.classList.remove('open');
      populateDropdowns();
    });
    configOptions.appendChild(opt);
  }
}

function populateDropdowns() {
  const pgx = Math.round(player.x / REGION_SIZE);
  const pgz = Math.round(player.z / REGION_SIZE);
  const assignment = getRegionAssignment(pgx, pgz);
  populateBiomeDropdown(assignment.biome);
  populateConfigDropdown(assignment.biome, assignment.configIdx);
  regionCoordsEl.textContent = pgx + ', ' + pgz;
}
populateDropdowns();

biomeDropdown.addEventListener('click', (e) => {
  e.stopPropagation();
  configOptions.classList.remove('open');
  biomeOptions.classList.toggle('open');
});
configDropdown.addEventListener('click', (e) => {
  e.stopPropagation();
  biomeOptions.classList.remove('open');
  configOptions.classList.toggle('open');
});
document.addEventListener('click', () => {
  configOptions.classList.remove('open');
  biomeOptions.classList.remove('open');
});

gl.enable(gl.DEPTH_TEST);

let frameCount = 0;
let lastFpsTime = performance.now();
let drawCalls = 0;
let tris = 0;
let frameMs = 0;
let frameMsMin = Infinity;
let frameMsMax = 0;
const statsEl = document.getElementById('stats');
let statsText = '';

// Tracked draw call
function draw(mode, count, type, offset) {
  gl.drawElements(mode, count, type, offset);
  drawCalls++;
  tris += count / 3;
}

function biomeGroundTex(name) {
  return name === 'forest' ? grassGroundTex : name === 'desert' ? desertGroundTex : rockGroundTex;
}

const _biomePriority = { desert: 0, rock: 1, forest: 2 };
function _biomePriorityCmp(a, b) { return (_biomePriority[a.biomeName] || 0) - (_biomePriority[b.biomeName] || 0); }

function render(rafTime) {
  if (fpsCap > 0) {
    const minInterval = 1000 / fpsCap;
    if (rafTime - lastFrameTime < minInterval * 0.75) {
      requestAnimationFrame(render);
      return;
    }
    // Advance lastFrameTime by interval (not to rafTime) so timing stays
    // aligned to the target cadence. Clamp to prevent spiral if we fall behind.
    lastFrameTime += minInterval;
    if (rafTime - lastFrameTime > minInterval) lastFrameTime = rafTime;
  }
  const frameStart = performance.now();
  drawCalls = 0;
  tris = 0;
  frameCount++;
  const now = frameStart;
  if (now - lastFpsTime >= 1000) {
    const elapsed = now - lastFpsTime;
    const rawFps = frameCount * 1000 / elapsed;
    // Rolling average over last 3 samples
    if (render._fpsHistory === undefined) render._fpsHistory = [];
    render._fpsHistory.push(rawFps);
    if (render._fpsHistory.length > 3) render._fpsHistory.shift();
    const fps = Math.ceil(render._fpsHistory.reduce((a, b) => a + b) / render._fpsHistory.length);
    statsText = `${fps} FPS | ${frameMs.toFixed(1)}ms (${frameMsMin.toFixed(1)}-${frameMsMax.toFixed(1)})`;
    // drawCalls/tris filled from previous frame
    frameCount = 0;
    // Advance by 1000ms (not reset to now) to keep windows aligned
    lastFpsTime += 1000;
    // Clamp if we fell way behind (e.g. tab was backgrounded)
    if (now - lastFpsTime > 1000) lastFpsTime = now;
    frameMsMin = Infinity;
    frameMsMax = 0;
  }
  gl.clearColor(0.03, 0.03, 0.05, 1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // --- Delta time ---
  const dt = Math.min((now - (render.lastTime || now)) / 1000, 0.05); // cap at 50ms
  render.lastTime = now;

  // --- Update character (WASD + gamepad movement) ---
  pollGamepad();
  // Screen-aligned: W=up, S=down, A=left, D=right
  // Isometric: screen-up=(-x,-z), screen-right=(+x,-z)
  let mx = 0, mz = 0;
  if (keys['KeyW']) { mx -= 1; mz -= 1; }
  if (keys['KeyS']) { mx += 1; mz += 1; }
  if (keys['KeyA']) { mx -= 1; mz += 1; }
  if (keys['KeyD']) { mx += 1; mz -= 1; }
  if (mx !== 0 || mz !== 0) {
    const len = Math.sqrt(mx * mx + mz * mz);
    mx /= len; mz /= len;
  }
  // Gamepad: rotate stick input by 45Ã‚Â° to match isometric view
  if (gamepadState.lx !== 0 || gamepadState.lz !== 0) {
    const slx = gamepadState.lx, sly = gamepadState.lz;
    mx += slx + sly;   // screen-right + screen-down -> world +x
    mz += -slx + sly;  // screen-down - screen-right -> world +z
    const cLen = Math.sqrt(mx * mx + mz * mz);
    if (cLen > 1) { mx /= cLen; mz /= cLen; }
  }
  // Touch-to-move: compute screen direction from player to touch, convert to iso world axes
  if (touchMoveState.active) {
    // Project player world pos to screen (CSS pixels)
    // Use the previous frame's proj/view (close enough since camera follows player)
    const pv = render._prevView, pp = render._prevProj;
    if (pv && pp) {
      // Multiply: clip = proj * view * vec4(player.x, player.y, player.z, 1)
      const pwx = player.x, pwy = player.y, pwz = player.z;
      const ex = pv[0]*pwx + pv[4]*pwy + pv[8]*pwz + pv[12];
      const ey = pv[1]*pwx + pv[5]*pwy + pv[9]*pwz + pv[13];
      const ez = pv[2]*pwx + pv[6]*pwy + pv[10]*pwz + pv[14];
      const ew = pv[3]*pwx + pv[7]*pwy + pv[11]*pwz + pv[15];
      const cx2 = pp[0]*ex + pp[4]*ey + pp[8]*ez + pp[12]*ew;
      const cy2 = pp[1]*ex + pp[5]*ey + pp[9]*ez + pp[13]*ew;
      const cw = pp[3]*ex + pp[7]*ey + pp[11]*ez + pp[15]*ew;
      // NDC
      const ndcX = cx2 / cw, ndcY = cy2 / cw;
      // CSS pixel position of player on screen
      const playerScreenX = (ndcX * 0.5 + 0.5) * window.innerWidth;
      const playerScreenY = (1 - (ndcY * 0.5 + 0.5)) * window.innerHeight;
      // Screen direction from player to touch
      let sdx = touchMoveState.screenX - playerScreenX;
      let sdy = touchMoveState.screenY - playerScreenY;
      const sLen = Math.sqrt(sdx * sdx + sdy * sdy);
      if (sLen > 5) { // small deadzone
        sdx /= sLen; sdy /= sLen;
        // Convert screen direction to isometric world axes (same as WASD/gamepad)
        // Screen right = (+sdx, 0): world (+x, -z) = iso right
        // Screen down  = (0, +sdy): world (+x, +z) = iso down
        mx += sdx + sdy;   // world +x
        mz += -sdx + sdy;  // world +z
        const tLen = Math.sqrt(mx * mx + mz * mz);
        if (tLen > 1) { mx /= tLen; mz /= tLen; }
      }
    }
  }
  // --- Fixed sub-step movement + collision (~120Hz) ---
  // Accumulate dt and consume in fixed chunks. This gives identical feel
  // at 30fps and 144fps: per-step displacement is always ~0.032 units,
  // so collision never misses and movement looks smooth.
  if (render._dtAccum === undefined) render._dtAccum = 0;
  render._dtAccum += dt;
  const steps = Math.min(Math.floor(render._dtAccum / STEP_DT), MAX_STEPS);
  render._dtAccum -= steps * STEP_DT;
  // Clamp leftover to prevent accumulation if we consistently hit MAX_STEPS
  if (render._dtAccum > STEP_DT * 2) render._dtAccum = STEP_DT * 2;

  // Gather nearby regions once per frame (player won't cross regions within sub-steps)
  const pgx = Math.round(player.x / REGION_SIZE);
  const pgz = Math.round(player.z / REGION_SIZE);
  if (!render._nearbyRegions) render._nearbyRegions = [];
  const nearbyRegions = render._nearbyRegions;
  nearbyRegions.length = 0;
  for (let dz = -1; dz <= 1; dz++) {
    for (let dx = -1; dx <= 1; dx++) {
      const gx = pgx + dx, gz = pgz + dz;
      if (gx < -GRID_HALF || gx > GRID_HALF || gz < -GRID_HALF || gz > GRID_HALF) continue;
      nearbyRegions.push(getRegion(gx, gz));
    }
  }

  for (let step = 0; step < steps; step++) {
    if (mx !== 0 || mz !== 0) {
      player.x += mx * CHAR_SPEED * STEP_DT;
      player.z += mz * CHAR_SPEED * STEP_DT;
    }
    resolveCollisions(nearbyRegions);
  }

  // Snap to terrain height (once per frame, after all sub-steps)
  player.y = getWorldHeight(player.x, player.z);

  // Update HUD if region changed
  const curRegX = pgx;
  const curRegZ = pgz;
  if (curRegX !== render.lastRegX || curRegZ !== render.lastRegZ) {
    render.lastRegX = curRegX;
    render.lastRegZ = curRegZ;
    populateDropdowns();
  }

  // --- Camera deadzone ---
  // Single deadzone ring. Player inside: camera doesn't move.
  // Player crosses edge: camera follows (capped to player speed).
  // Player stops: camera lerps until edge encompasses player collider.
  // Right-click pan: deadzone suspended. Next movement lerps back (or snaps if off screen).
  // Settled: skip all processing until player nears edge.
  const isMoving = mx !== 0 || mz !== 0;

  if (render._cameraPanned && isMoving) {
    // Check if player collider is visible on screen using previous frame's matrices
    const pv = render._prevView, pp = render._prevProj;
    let playerOnScreen = false;
    if (pv && pp) {
      const pwx = player.x, pwy = player.y, pwz = player.z;
      const ex = pv[0]*pwx + pv[4]*pwy + pv[8]*pwz + pv[12];
      const ey = pv[1]*pwx + pv[5]*pwy + pv[9]*pwz + pv[13];
      const ez = pv[2]*pwx + pv[6]*pwy + pv[10]*pwz + pv[14];
      const ew = pv[3]*pwx + pv[7]*pwy + pv[11]*pwz + pv[15];
      const cx2 = pp[0]*ex + pp[4]*ey + pp[8]*ez + pp[12]*ew;
      const cy2 = pp[1]*ex + pp[5]*ey + pp[9]*ez + pp[13]*ew;
      const cw = pp[3]*ex + pp[7]*ey + pp[11]*ez + pp[15]*ew;
      if (cw !== 0) {
        const ndcX = cx2 / cw, ndcY = cy2 / cw;
        playerOnScreen = Math.abs(ndcX) < 1.0 && Math.abs(ndcY) < 1.0;
      }
    }
    render._cameraPanned = false;
    render._camSettled = false;
    if (playerOnScreen) {
      // Player on screen — let deadzone follow handle it, uncapped speed
      render._camUncapped = true;
    } else {
      // Player off screen — instant snap
      camTarget[0] = player.x;
      camTarget[2] = player.z;
    }
  }

  // Wake from settled only if player is near/past the edge.
  if (isMoving && render._camSettled) {
    const sdx = player.x - camTarget[0];
    const sdz = player.z - camTarget[2];
    const distSq = sdx * sdx + sdz * sdz;
    const wakeR = CAM_DEADZONE - CHAR_RADIUS;
    if (distSq > wakeR * wakeR) {
      render._camSettled = false;
    }
  }

  if (!render._cameraPanned && !render._camSettled) {
  let offX = player.x - camTarget[0];
  let offZ = player.z - camTarget[2];
  let offDist = Math.sqrt(offX * offX + offZ * offZ);

  const outsideDeadzone = offDist > CAM_DEADZONE;

  if (isMoving) {
    if (outsideDeadzone) {
      const overshoot = offDist - CAM_DEADZONE;
      if (render._camUncapped) {
        // Returning from pan: modulate speed by movement direction.
        // Dot product of movement dir and offset dir: +1 = moving away from camera,
        // -1 = moving toward camera. Lerp speed between 4 (toward) and 11 (away).
        // Slightly slower when zoomed in: 85% speed at +8.
        const offNx = offX / offDist, offNz = offZ / offDist;
        const dot = mx * offNx + mz * offNz; // -1 to +1
        const t = dot * 0.5 + 0.5; // 0 (toward) to 1 (away)
        const zoomInSteps = Math.max(0, zoomDefaultIdx - zoomIdx);
        const zoomScale = 1 - zoomInSteps * (0.15 / 8); // 1.0 at default, 0.85 at +8
        const speed = (4 + t * 7) * zoomScale;
        render._panReturnSpeed = speed; // store for stopped branch continuity
        const followLerp = 1 - Math.exp(-speed * dt);
        const move = overshoot * followLerp;
        camTarget[0] += offNx * move;
        camTarget[2] += offNz * move;
      } else {
        // Normal play: capped to player speed
        const followLerp = 1 - Math.exp(-15 * dt);
        const move = Math.min(overshoot * followLerp, CHAR_SPEED * dt);
        camTarget[0] += (offX / offDist) * move;
        camTarget[2] += (offZ / offDist) * move;
      }
    }
    // Inside deadzone: camera stays still. Re-settle.
    if (!outsideDeadzone) {
      render._camSettled = true;
      render._camUncapped = false; render._panReturnSpeed = 0;
    }
  } else {
    // Player stopped. If outside deadzone, follow back.
    if (outsideDeadzone) {
      const overshoot = offDist - CAM_DEADZONE;
      if (render._camUncapped) {
        // Continue at whatever speed the moving branch was using
        const speed = render._panReturnSpeed || 8;
        const followLerp = 1 - Math.exp(-speed * dt);
        const move = overshoot * followLerp;
        camTarget[0] += (offX / offDist) * move;
        camTarget[2] += (offZ / offDist) * move;
      } else {
        const followLerp = 1 - Math.exp(-15 * dt);
        const move = Math.min(overshoot * followLerp, CHAR_SPEED * dt);
        camTarget[0] += (offX / offDist) * move;
        camTarget[2] += (offZ / offDist) * move;
      }
    }
    // Recompute after potential correction
    offX = player.x - camTarget[0];
    offZ = player.z - camTarget[2];
    offDist = Math.sqrt(offX * offX + offZ * offZ);
    // Lerp toward player until edge encompasses player collider
    const targetDist = CAM_DEADZONE - CHAR_RADIUS;
    const gap = offDist - targetDist;
    if (gap > 0.002) {
      let move;
      if (gap < 0.06) {
        move = Math.min(gap, 0.48 * dt);
      } else {
        move = gap * (1 - Math.exp(-8 * dt));
      }
      camTarget[0] += (offX / offDist) * move;
      camTarget[2] += (offZ / offDist) * move;
    } else {
      render._camSettled = true;
      render._camUncapped = false; render._panReturnSpeed = 0;
    }
  }
  } // end !cameraPanned && !camSettled

  // Store for debug visualization (only when deadzone actively moved)
  if (!render._cameraPanned && !render._camSettled) {
    render._camCenterX = camTarget[0];
    render._camCenterZ = camTarget[2];
  }

  const aspect = canvas.width / canvas.height;
  const proj = ortho(-camDist * aspect, camDist * aspect, -camDist, camDist, -50, 50);

  // When zoomed in past default, bias the visual look-at point toward the player.
  // This gradually centers the player as the user zooms in closer.
  // During pan: bias frozen. After pan (uncapped): lerp from frozen to live bias
  // to avoid visual jump. Normal play: live bias directly.
  let vizTargetX = camTarget[0], vizTargetZ = camTarget[2];
  if (render._cameraPanned) {
    // Use frozen bias from when pan started
    vizTargetX += render._panFrozenBiasX || 0;
    vizTargetZ += render._panFrozenBiasZ || 0;
  } else if (zoomIdx < zoomDefaultIdx) {
    const zoomT = 1 - (zoomIdx / zoomDefaultIdx); // 0 at default, 1 at max zoom-in
    const bias = zoomT * 0.80; // max 80% toward player at closest zoom
    const liveBiasX = (player.x - camTarget[0]) * bias;
    const liveBiasZ = (player.z - camTarget[2]) * bias;
    if (render._camUncapped) {
      // Returning from pan — lerp from frozen bias to live bias
      if (render._transitionBiasX === undefined) {
        render._transitionBiasX = render._panFrozenBiasX || 0;
        render._transitionBiasZ = render._panFrozenBiasZ || 0;
      }
      const biasLerp = 1 - Math.exp(-6 * dt);
      render._transitionBiasX += (liveBiasX - render._transitionBiasX) * biasLerp;
      render._transitionBiasZ += (liveBiasZ - render._transitionBiasZ) * biasLerp;
      vizTargetX += render._transitionBiasX;
      vizTargetZ += render._transitionBiasZ;
      // Store displayed bias (transition value) for potential pan snapshot
      render._vizBiasX = render._transitionBiasX;
      render._vizBiasZ = render._transitionBiasZ;
    } else {
      // Normal: use live bias directly
      vizTargetX += liveBiasX;
      vizTargetZ += liveBiasZ;
      render._transitionBiasX = undefined;
      // Store for potential pan snapshot
      render._vizBiasX = liveBiasX;
      render._vizBiasZ = liveBiasZ;
    }
  } else {
    render._vizBiasX = 0;
    render._vizBiasZ = 0;
    render._transitionBiasX = undefined;
  }

  // Fixed isometric direction (no distance needed for ortho, just direction)
  const isoDist = 20;
  _eyeVec[0] = vizTargetX + isoDist * Math.cos(camRotX) * Math.sin(camRotY);
  _eyeVec[1] = camTarget[1] + isoDist * Math.sin(camRotX);
  _eyeVec[2] = vizTargetZ + isoDist * Math.cos(camRotX) * Math.cos(camRotY);
  // Reuse camTarget array temporarily for lookAt (restored after)
  const savedX = camTarget[0], savedZ = camTarget[2];
  camTarget[0] = vizTargetX; camTarget[2] = vizTargetZ;
  const view = lookAt(_eyeVec, camTarget, _upVec);
  camTarget[0] = savedX; camTarget[2] = savedZ;

  // Pixel-snap the view matrix to eliminate sub-pixel jitter on sprites/textures.
  // In ortho, world units per pixel = (2 * camDist) / canvas.height
  // We snap the view's translation so the projected origin lands on exact pixels.
  const worldPerPixelX = (2 * camDist * aspect) / canvas.width;
  const worldPerPixelY = (2 * camDist) / canvas.height;
  // Project the origin through the view matrix to get its screen-space offset
  // view[12] and view[13] are the translation in view-space (x, y)
  const viewTx = view[12];
  const viewTy = view[13];
  // Snap to pixel grid
  view[12] = Math.round(viewTx / worldPerPixelX) * worldPerPixelX;
  view[13] = Math.round(viewTy / worldPerPixelY) * worldPerPixelY;

  // Store proj/view for touch-to-move player projection (used next frame)
  if (!render._prevView) render._prevView = new Float32Array(16);
  if (!render._prevProj) render._prevProj = new Float32Array(16);
  render._prevView.set(view);
  render._prevProj.set(proj);

  // Get visible regions via frustum culling
  const activeRegions = getActiveRegions(player.x, player.z, proj, view);

  // --- Draw ground for all active regions (opaque, no alpha blend) ---
  // Priority draw order: desert (lowest) â†’ rock â†’ forest (highest).
  // Higher-priority regions draw last so their overlap strips naturally
  // overwrite lower-priority cores, creating the interlocking edge effect
  // with the preferred biome always winning at boundaries.
  gl.useProgram(prog);
  gl.disable(gl.DEPTH_TEST);
  gl.uniformMatrix4fv(uProj, false, proj);
  gl.uniformMatrix4fv(uView, false, view);
  gl.uniform3f(uPlayerPos, player.x, player.y, player.z);

  gl.uniform1f(uMineralOnly, 0.0);
  gl.enableVertexAttribArray(aPos);
  gl.enableVertexAttribArray(aUV);

  // Sort active regions by biome draw priority (in place, no allocation)
  activeRegions.sort(_biomePriorityCmp);

  for (const reg of activeRegions) {
    const localTex = biomeGroundTex(reg.biomeName);
    gl.bindBuffer(gl.ARRAY_BUFFER, reg.terrain.vbo);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, reg.terrain.ibo);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(aUV, 2, gl.FLOAT, false, stride, 3 * 4);
    gl.uniform3f(uWorldOffset, reg.ox, 0, reg.oz);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, localTex);
    gl.uniform1i(uLocalTex, 1);
    draw(gl.TRIANGLES, reg.terrain.idxCount, gl.UNSIGNED_SHORT, 0);
  }

  // Pass 2: Mineral ground overlay (uses discard, no blend needed)
  gl.uniform1f(uMineralOnly, 1.0);
  gl.activeTexture(gl.TEXTURE0);
  gl.uniform1i(uMineralMask, 0);
  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_2D, mineralColorTex);
  gl.uniform1i(uMineralColorTex, 2);
  for (const reg of activeRegions) {
    if (!reg.mineralMesh) continue;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, reg.mineralMaskTex);
    gl.bindBuffer(gl.ARRAY_BUFFER, reg.mineralMesh.vbo);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, reg.mineralMesh.ibo);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, stride, 0);
    gl.vertexAttribPointer(aUV, 2, gl.FLOAT, false, stride, 3 * 4);
    gl.uniform3f(uWorldOffset, reg.ox, 0, reg.oz);
    draw(gl.TRIANGLES, reg.mineralMesh.idxCount, gl.UNSIGNED_SHORT, 0);
  }

  gl.enable(gl.DEPTH_TEST);

  // --- Sort all objects by screen Y (lower on screen = closer to viewer = drawn last) ---
  const vyX = view[1], vyY = view[5], vyZ = view[9], vyW = view[13];

  // Reusable sortable pool â€” avoids per-frame object allocation
  if (!render._sortPool) render._sortPool = [];
  const pool = render._sortPool;
  let sortCount = 0;
  function pushSortable(type, sortKey, data) {
    if (sortCount >= pool.length) pool.push({ type: '', sortKey: 0, data: null });
    const s = pool[sortCount++];
    s.type = type; s.sortKey = sortKey; s.data = data;
  }

  if (treesLoaded === treesToLoad) {
    for (const reg of activeRegions) {
      for (let i = 0; i < reg.treePositions.length; i++) {
        const t = reg.treePositions[i];
        const screenY = vyX * t.billX + vyY * t.billY + vyZ * t.billZ + vyW;
        t._treeVarIdx = reg.treeVarIdx[i];
        pushSortable('tree', screenY, t);
      }
    }
  }
  // Rocks
  for (const reg of activeRegions) {
    for (const r of reg.rocks) {
      const screenY = vyX * r.x + vyY * r.visY + vyZ * r.z + vyW;
      pushSortable('rock', screenY, r);
    }
  }
  // Sticks (forest decoration)
  for (const reg of activeRegions) {
    for (const st of reg.sticks) {
      const screenY = vyX * st.visX + vyY * st.visY + vyZ * st.visZ + vyW;
      pushSortable('stick', screenY, st);
    }
  }
  // Minable cubes
  const time = now * 0.001;
  for (const reg of activeRegions) {
    for (const cluster of reg.minables) {
      const cubes = cluster.cubes;
      const n = cubes.length;
      // Ensure sorted rank exists for wave pulse
      if (!cluster._sortedIdx) {
        cluster._sortedIdx = Array.from({length: n}, (_, i) => i);
        cluster._sortedIdx.sort((a, b) => cubes[a].x - cubes[b].x);
        cluster._rank = new Float32Array(n);
        for (let r = 0; r < n; r++) cluster._rank[cluster._sortedIdx[r]] = r;
      }
      const wave = (time * 0.4) % 2.0;
      const pos = wave <= 1.0 ? wave : 2.0 - wave;
      for (let ci = 0; ci < n; ci++) {
        const c = cubes[ci];
        if (c.mined) continue;
        const rank = cluster._rank[ci] / (n - 1 || 1);
        c._waveProx = 1.0 - Math.min(1.0, Math.abs(rank - pos) * 3.0);
        c._material = cluster.material;
        const screenY = vyX * c.x + vyY * c.y + vyZ * c.z + vyW;
        pushSortable('minable', screenY, c);
      }
    }
  }
  // Player
  const pScreenY = vyX * player.x + vyY * player.y + vyZ * player.z + vyW;
  pushSortable('player', pScreenY, player);
  // Sort only the active entries (0..sortCount-1) in descending sortKey order
  // We sort a view of the pool without modifying array length
  const sortEnd = sortCount;
  for (let gap = sortEnd >> 1; gap > 0; gap >>= 1) {
    for (let i = gap; i < sortEnd; i++) {
      const tmp = pool[i];
      let j = i;
      while (j >= gap && pool[j - gap].sortKey < tmp.sortKey) {
        pool[j] = pool[j - gap];
        j -= gap;
      }
      pool[j] = tmp;
    }
  }

  // Pre-set player position for distance shadow in cube shader
  gl.useProgram(cubeProg);
  gl.uniform3f(cUPlayerWorldPos, player.x, player.y, player.z);
  gl.uniform3f(cUCamPos, _eyeVec[0], _eyeVec[1], _eyeVec[2]);

  // Sorted pass: pure painter's algorithm, no depth testing
  // Back-face culling on 3D objects prevents seeing through them
  gl.disable(gl.DEPTH_TEST);
  gl.depthMask(false);

  let lastType = '';
  let lastTreeVar = -1;
  let lastMinableMat = null;
  for (let si = 0; si < sortCount; si++) {
    const obj = pool[si];
    if (obj.type === 'tree') {
      gl.disable(gl.CULL_FACE);
      if (lastType !== 'tree') {
        gl.useProgram(treeProg);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.bindBuffer(gl.ARRAY_BUFFER, treeVBO);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, treeIBO);
        gl.enableVertexAttribArray(tAPos);
        gl.vertexAttribPointer(tAPos, 3, gl.FLOAT, false, 5 * 4, 0);
        gl.enableVertexAttribArray(tAUV);
        gl.vertexAttribPointer(tAUV, 2, gl.FLOAT, false, 5 * 4, 3 * 4);
        gl.uniformMatrix4fv(tUProj, false, proj);
        gl.uniformMatrix4fv(tUView, false, view);
        gl.activeTexture(gl.TEXTURE0);
        gl.uniform1i(tUTreeTex, 0);
        gl.uniform3f(tUTreePlayerPos, player.x, player.y, player.z);
        lastType = 'tree';
      }
      if (lastTreeVar !== obj.data._treeVarIdx) {
        gl.bindTexture(gl.TEXTURE_2D, treeTextures[obj.data._treeVarIdx]);
        const sz = (TREE_VARIANTS[obj.data._treeVarIdx] || TREE_VARIANTS.dry).size;
        gl.uniform2f(tUTreeSize, sz[0], sz[1]);
        lastTreeVar = obj.data._treeVarIdx;
      }
      gl.uniform3f(tUTreePos, obj.data.billX, obj.data.billY, obj.data.billZ);
      gl.uniform1f(tUTreeScale, 1.0);
      draw(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

    } else if (obj.type === 'rock') {
      if (lastType === 'tree') gl.disable(gl.BLEND);
      if (lastType !== 'rock' && lastType !== 'minable') {
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
      }
      if (lastType !== 'rock') {
        gl.useProgram(cubeProg);
        gl.uniformMatrix4fv(cUProj, false, proj);
        gl.uniformMatrix4fv(cUView, false, view);
        gl.uniform3f(cUColor, 0.28, 0.26, 0.24);
        gl.uniform1f(cUEmissive, 0.0);
        gl.uniform1f(cUIsRock, 1.0);
        gl.uniform1f(cUShininess, 0.0);
      }
      const r = obj.data;
      const rm = rockMeshes[r.meshIdx];
      gl.bindBuffer(gl.ARRAY_BUFFER, rm.vbo);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rm.ibo);
      gl.enableVertexAttribArray(cAPos);
      gl.vertexAttribPointer(cAPos, 3, gl.FLOAT, false, 6 * 4, 0);
      gl.enableVertexAttribArray(cANormal);
      gl.vertexAttribPointer(cANormal, 3, gl.FLOAT, false, 6 * 4, 3 * 4);
      const model = buildModelMatrix(r.x, r.visY, r.z, r.rotY, 0.0, r.h);
      gl.uniformMatrix4fv(cUModel, false, model);
      draw(gl.TRIANGLES, rm.triCount, gl.UNSIGNED_SHORT, 0);
      lastType = 'rock';

    } else if (obj.type === 'stick') {
      if (lastType === 'tree') gl.disable(gl.BLEND);
      gl.disable(gl.CULL_FACE);
      if (lastType !== 'stick') {
        gl.useProgram(cubeProg);
        gl.uniformMatrix4fv(cUProj, false, proj);
        gl.uniformMatrix4fv(cUView, false, view);
        gl.bindBuffer(gl.ARRAY_BUFFER, stickVBO);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, stickIBO);
        gl.enableVertexAttribArray(cAPos);
        gl.vertexAttribPointer(cAPos, 3, gl.FLOAT, false, 6 * 4, 0);
        gl.enableVertexAttribArray(cANormal);
        gl.vertexAttribPointer(cANormal, 3, gl.FLOAT, false, 6 * 4, 3 * 4);
      }
      const st = obj.data;
      const sz = st.flip ? -st.scale : st.scale;

      // Fake shadow: same mesh, slightly larger + offset, dark
      gl.uniform3f(cUColor, 0.06, 0.04, 0.02);
      gl.uniform1f(cUEmissive, 0.0);
      gl.uniform1f(cUIsRock, 0.0);
      gl.uniform1f(cUShininess, 0.0);
      const shScale = st.scale * 1.05;
      const shSz = st.flip ? -shScale : shScale;
      const shModel = buildModelMatrix(st.visX + 0.01, st.visY - 0.003, st.visZ + 0.01, st.rotY, 0.0, shScale, shScale, shSz);
      gl.uniformMatrix4fv(cUModel, false, shModel);
      draw(gl.TRIANGLES, stickTriCount, gl.UNSIGNED_SHORT, 0);

      // Fill pass
      gl.uniform3f(cUColor, 0.52, 0.30, 0.10);
      gl.uniform1f(cUEmissive, 0.30);
      const model = buildModelMatrix(st.visX, st.visY, st.visZ, st.rotY, 0.0, st.scale, st.scale, sz);
      gl.uniformMatrix4fv(cUModel, false, model);
      draw(gl.TRIANGLES, stickTriCount, gl.UNSIGNED_SHORT, 0);
      lastType = 'stick';

    } else if (obj.type === 'minable') {
      if (lastType === 'tree') gl.disable(gl.BLEND);
      if (lastType !== 'rock' && lastType !== 'minable') {
        gl.enable(gl.CULL_FACE);
        gl.cullFace(gl.BACK);
      }
      const c = obj.data;
      const mat = MINABLE_MATERIALS[c._material];
      if (lastType !== 'minable') {
        gl.useProgram(cubeProg);
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVBO);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIBO);
        gl.enableVertexAttribArray(cAPos);
        gl.vertexAttribPointer(cAPos, 3, gl.FLOAT, false, 6 * 4, 0);
        gl.enableVertexAttribArray(cANormal);
        gl.vertexAttribPointer(cANormal, 3, gl.FLOAT, false, 6 * 4, 3 * 4);
        gl.uniformMatrix4fv(cUProj, false, proj);
        gl.uniformMatrix4fv(cUView, false, view);
        gl.uniform1f(cUIsRock, 0.0);
        lastMinableMat = null;
      }
      if (lastMinableMat !== c._material) {
        gl.uniform3f(cUColor, mat.color[0], mat.color[1], mat.color[2]);
        lastMinableMat = c._material;
      }
      const waveProx = c._waveProx || 0;
      gl.uniform1f(cUEmissive, mat.emissiveBase + mat.emissiveWave * waveProx);
      gl.uniform1f(cUShininess, mat.shininess * waveProx);
      const model = buildModelMatrix(c.x, c.y, c.z, c.rotY, c.rotZ, c.sx, c.sy, c.sz);
      gl.uniformMatrix4fv(cUModel, false, model);
      draw(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
      lastType = 'minable';

    } else {
      // Player - needs depth test for proper cylinder self-occlusion
      if (lastType === 'tree') gl.disable(gl.BLEND);
      gl.disable(gl.CULL_FACE);
      gl.enable(gl.DEPTH_TEST);
      gl.depthMask(true);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      gl.useProgram(cubeProg);
      gl.bindBuffer(gl.ARRAY_BUFFER, cylVBO);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cylIBO);
      gl.enableVertexAttribArray(cAPos);
      gl.vertexAttribPointer(cAPos, 3, gl.FLOAT, false, 6 * 4, 0);
      gl.enableVertexAttribArray(cANormal);
      gl.vertexAttribPointer(cANormal, 3, gl.FLOAT, false, 6 * 4, 3 * 4);
      gl.uniformMatrix4fv(cUProj, false, proj);
      gl.uniformMatrix4fv(cUView, false, view);
      gl.uniform3f(cUColor, 0.7, 0.85, 0.3);
      gl.uniform1f(cUEmissive, 0.05);
      gl.uniform1f(cUIsRock, 0.0);
      gl.uniform1f(cUShininess, 0.0);
      const charModel = buildModelMatrix(
        player.x, player.y + CHAR_HEIGHT * 0.5, player.z, 0, 0,
        CHAR_RADIUS * 2, CHAR_HEIGHT, CHAR_RADIUS * 2
      );
      gl.uniformMatrix4fv(cUModel, false, charModel);
      draw(gl.TRIANGLES, cylIdxCount, gl.UNSIGNED_SHORT, 0);
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      lastType = 'player';
    }
  }
  if (lastType === 'tree') gl.disable(gl.BLEND);
  gl.disable(gl.CULL_FACE);
  gl.enable(gl.DEPTH_TEST);
  gl.depthMask(true);

  // --- DEBUG: Draw collider outlines when toggled (on top of everything) ---
  if (showColliders) {
    gl.disable(gl.DEPTH_TEST);
    gl.useProgram(dbgProg);
    gl.bindBuffer(gl.ARRAY_BUFFER, dbgRingVBO);
    gl.enableVertexAttribArray(dbgAPos);
    gl.vertexAttribPointer(dbgAPos, 3, gl.FLOAT, false, 0, 0);
    gl.uniformMatrix4fv(dbgUProj, false, proj);
    gl.uniformMatrix4fv(dbgUView, false, view);

    // All colliders - drawn from unified allColliders list using COLLIDER_TYPES config
    for (const reg of activeRegions) {
      if (!reg.allColliders) buildRegionColliders(reg);
      for (const col of reg.allColliders) {
        const ct = COLLIDER_TYPES[col.type];
        if (!ct) continue;
        const isDotted = ct.debugStyle === 'dotted';
        if (isDotted) {
          gl.bindBuffer(gl.ARRAY_BUFFER, dbgDottedVBO);
          gl.vertexAttribPointer(dbgAPos, 3, gl.FLOAT, false, 0, 0);
        }
        gl.uniform3f(dbgUColor, ct.debugColor[0], ct.debugColor[1], ct.debugColor[2]);
        // Collider ring Y: always sample ground height at the collider's XZ position
        // This ensures the ring sits on the terrain directly under the 2D collision circle
        const cy = getWorldHeight(col.colX, col.colZ);
        gl.uniform3f(dbgUCenter, col.colX, cy, col.colZ);
        gl.uniform1f(dbgURadius, col.colR);
        if (isDotted) {
          gl.drawArrays(gl.LINES, 0, DBG_DOTTED_SEGS * 2);
          gl.bindBuffer(gl.ARRAY_BUFFER, dbgRingVBO);
          gl.vertexAttribPointer(dbgAPos, 3, gl.FLOAT, false, 0, 0);
        } else {
          gl.drawArrays(gl.LINE_LOOP, 0, DBG_RING_SEGS);
        }
      }
    }

    // Player collider - lime green
    gl.uniform3f(dbgUColor, 0.3, 1.0, 0.1);
    gl.uniform3f(dbgUCenter, player.x, player.y, player.z);
    gl.uniform1f(dbgURadius, CHAR_RADIUS);
    gl.drawArrays(gl.LINE_LOOP, 0, DBG_RING_SEGS);

    // Camera deadzone ring — white when active, dark when settled
    const dzX = render._camCenterX, dzZ = render._camCenterZ;
    if (dzX !== undefined) {
      if (render._camSettled) {
        gl.uniform3f(dbgUColor, 0.15, 0.15, 0.18);
      } else {
        gl.uniform3f(dbgUColor, 0.9, 0.9, 1.0);
      }
      gl.uniform3f(dbgUCenter, dzX, 0, dzZ);
      gl.uniform1f(dbgURadius, CAM_DEADZONE);
      gl.drawArrays(gl.LINE_LOOP, 0, DBG_RING_SEGS);
    }

    gl.enable(gl.DEPTH_TEST);

    // Region coordinate labels
    textBegin(proj, view);
    for (const reg of activeRegions) {
      const wcx = reg.gx * REGION_SIZE;
      const wcz = reg.gz * REGION_SIZE;
      const wcy = getWorldHeight(wcx, wcz) + 0.1;
      textWorld('[' + reg.gx + ',' + reg.gz + ']', wcx, wcy, wcz, { scale: 12, r: 1, g: 1, b: 1, a: 0.9 });
    }
    textEnd();
  }

  // --- Draw glow billboards for minable materials that have glow enabled ---
  gl.useProgram(glowProg);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE); // additive blending
  gl.depthMask(false); // don't write depth

  gl.bindBuffer(gl.ARRAY_BUFFER, glowVBO);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glowIBO);
  gl.enableVertexAttribArray(gAPos);
  gl.vertexAttribPointer(gAPos, 3, gl.FLOAT, false, 3 * 4, 0);

  gl.uniformMatrix4fv(gUProj, false, proj);
  gl.uniformMatrix4fv(gUView, false, view);

  for (const reg of activeRegions) {
    for (const cluster of reg.minables) {
      const mat = MINABLE_MATERIALS[cluster.material];
      if (!mat.glow || !mat.glow.enabled) continue;
      gl.uniform3f(gUGlowColor, mat.glow.color[0], mat.glow.color[1], mat.glow.color[2]);
      for (const c of cluster.cubes) {
        if (c.mined) continue;
        const gdx = c.x - player.x;
        const gdz = c.z - player.z;
        const gDist = Math.sqrt(gdx * gdx + gdz * gdz);
        if (gDist > 14.0) continue;
        const distFade = 1.0 - Math.max(0, Math.min(1, (gDist - 8.0) / 6.0));
        const pulse = (0.06 + 0.10 * (c._waveProx || 0)) * distFade;
        gl.uniform3f(gUGlowPos, c.x, c.y, c.z);
        gl.uniform1f(gUGlowSize, c.glowSize * 1.3);
        gl.uniform1f(gUGlowAlpha, pulse);
        draw(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
      }
    }
  }

  gl.depthMask(true);
  gl.disable(gl.BLEND);

  // --- DEBUG: Region boundaries & border margins (shown with collider toggle) ---
  if (showColliders) {
    gl.disable(gl.DEPTH_TEST);
    gl.useProgram(lineProg);
    gl.uniformMatrix4fv(lineUProj, false, proj);
    gl.uniformMatrix4fv(lineUView, false, view);
    const LIFT = 0.08;

    function drawEdge(u0, v0, u1, v1, regOx, regOz) {
      const wx0 = -S + u0 * 2 * S + regOx;
      const wz0 = -S + v0 * 2 * S + regOz;
      const wx1 = -S + u1 * 2 * S + regOx;
      const wz1 = -S + v1 * 2 * S + regOz;
      const verts = new Float32Array([wx0, LIFT, wz0, wx1, LIFT, wz1]);
      if (!drawEdge._buf) drawEdge._buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, drawEdge._buf);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STREAM_DRAW);
      gl.enableVertexAttribArray(lineAPos);
      gl.vertexAttribPointer(lineAPos, 3, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.LINES, 0, 2);
    }

    function drawRect(u0, v0, u1, v1, regOx, regOz) {
      drawEdge(u0, v0, u1, v0, regOx, regOz);
      drawEdge(u1, v0, u1, v1, regOx, regOz);
      drawEdge(u1, v1, u0, v1, regOx, regOz);
      drawEdge(u0, v1, u0, v0, regOx, regOz);
    }

    for (const reg of activeRegions) {
      const ox = reg.gx * REGION_SIZE;
      const oz = reg.gz * REGION_SIZE;

      // Red: region boundary
      gl.uniform3f(lineUColor, 1.0, 0.2, 0.2);
      drawRect(0, 0, 1, 1, ox, oz);

      // Yellow: border margin â€” only on edges where neighbor is a different biome
      const bName = reg.biomeName;
      const regBiome = BIOMES[bName];
      const baseM = regBiome.borderMargin || 0.03;
      const nLA = getRegionAssignment(reg.gx - 1, reg.gz);
      const nRA = getRegionAssignment(reg.gx + 1, reg.gz);
      const nTA = getRegionAssignment(reg.gx, reg.gz - 1);
      const nBA = getRegionAssignment(reg.gx, reg.gz + 1);
      // Match buildRegion logic: only zero margin at top-left (-X) and top-right (-Z) world edges
      const isTopLeftEdge  = (reg.gx === -GRID_HALF);
      const isTopRightEdge = (reg.gz === -GRID_HALF);
      const nL = nLA && nLA.biome === bName ? 0 : (!nLA && isTopLeftEdge)  ? 0 : baseM;
      const nR = nRA && nRA.biome === bName ? 0 : baseM;
      const nT = nTA && nTA.biome === bName ? 0 : (!nTA && isTopRightEdge) ? 0 : baseM;
      const nB = nBA && nBA.biome === bName ? 0 : baseM;
      gl.uniform3f(lineUColor, 1.0, 1.0, 0.0);
      drawEdge(nL, nT, 1 - nR, nT, ox, oz);       // top
      drawEdge(1 - nR, nT, 1 - nR, 1 - nB, ox, oz); // right
      drawEdge(1 - nR, 1 - nB, nL, 1 - nB, ox, oz); // bottom
      drawEdge(nL, 1 - nB, nL, nT, ox, oz);         // left
    }
    gl.enable(gl.DEPTH_TEST);
  }

  // --- Update stats ---
  frameMs = performance.now() - frameStart;
  frameMsMin = Math.min(frameMsMin, frameMs);
  frameMsMax = Math.max(frameMsMax, frameMs);
  const zoomDisplay = zoomDefaultIdx - zoomIdx;
  statsEl.textContent = statsText + `\n${drawCalls} Draws | ${tris.toLocaleString()} Tris\nZoom ${zoomDisplay > 0 ? '+' : ''}${zoomDisplay} | ${GAME_VERSION}`;

  // Dismiss loader: pause â†’ fade crystal/dots â†’ fade black overlay
  if (!render._loaderDone) {
    render._loaderDone = true;
    const loader = document.getElementById('loader');
    if (loader) {
      const loaderCanvas = document.getElementById('loaderCanvas');
      // Step 1: Wait 500ms
      setTimeout(() => {
        // Step 2: Fade out crystal and dots (200ms)
        if (loaderCanvas) {
          loaderCanvas.style.transition = 'opacity 0.2s ease';
          loaderCanvas.style.opacity = '0';
        }
        // Step 3: After crystal fades, fade the black background (500ms)
        setTimeout(() => {
          loader.style.transition = 'opacity 0.5s ease';
          loader.style.opacity = '0';
          loader.addEventListener('transitionend', () => loader.remove());
        }, 250);
      }, 500);
    }
  }

  requestAnimationFrame(render);
}
// Initialize camera debug state so deadzone ring draws even before first movement
render._camCenterX = camTarget[0];
render._camCenterZ = camTarget[2];
render._camSettled = true;
render.lastRegX = -999;
render.lastRegZ = -999;
render();
</script>


</body></html>